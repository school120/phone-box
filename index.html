<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Phone Box ‚Ä¢ 12 Slots / Row (Blue strip = bottom)</title>
<style>
  :root{--bg:#0b1020;--card:#11183a;--muted:#9ab0e0}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:#fff;font-family:system-ui,-apple-system,Inter,Roboto,Segoe UI}
  header{padding:14px 16px;border-bottom:1px solid #ffffff1a;font-weight:800}
  main{max-width:1200px;margin:0 auto;padding:12px;display:grid;grid-template-columns:1.06fr .94fr;gap:16px}
  .card{background:#11183a;border:1px solid #ffffff1a;border-radius:16px;padding:14px}
  label{display:block;margin:10px 0 6px;color:var(--muted);font-size:14px}
  input[type="file"],select,button{width:100%;padding:14px 16px;border-radius:12px;border:1px solid #ffffff2b;background:#0f1738;color:#fff;font-size:16px}
  button.primary{background:linear-gradient(180deg,#3bc2f2,#1aa1d9);border:none;font-weight:800}
  small{color:var(--muted)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}

  /* Preview */
  #stage{position:relative;border:1px dashed #ffffff33;border-radius:12px;overflow:hidden;background:#0c1333;min-height:240px;touch-action:none}
  #img{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:none;z-index:0}
  #overlay{position:absolute;inset:0;pointer-events:none;z-index:1}

  .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:12px}
  .pill{display:inline-block;padding:.2rem .6rem;border-radius:999px;background:#ffffff24;font-size:12px}

  .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:6px;margin:10px 0}
  .slot{background:#0f1738;border:1px solid #ffffff24;aspect-ratio:3/5;border-radius:8px;position:relative}
  .slot span{position:absolute;inset:auto 6px 6px 6px;font-size:12px;color:#9ab0ff}
  .slot.present{outline:2px solid rgba(0,200,0,.85); background:linear-gradient(transparent, rgba(0,200,0,.18))}
  .slot.empty{outline:2px solid rgba(255,0,0,.85); background:linear-gradient(transparent, rgba(255,0,0,.18))}

  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid #ffffff1f;padding:10px 6px;text-align:left}
  tr.missing{background:#ff50501a}
  tr.ok{opacity:.95}

  @media (max-width: 900px){
    main{grid-template-columns:1fr}
    header{font-size:18px}
    .row{grid-template-columns:1fr}
  }
</style>
</head>
<body>
<header>üì± Phone Box ‚Äî Rectangles sit above the printed numbers (12 per row)</header>

<main>
  <section class="card" id="left">
    <div id="stage">
      <img id="img" alt="preview">
      <canvas id="overlay"></canvas>
    </div>
    <div class="toolbar">
      <span class="pill" id="status"></span>
    </div>
    <div class="grid" id="boxGrid"></div>
    <table>
      <thead><tr><th>Slot</th><th>Expected</th><th>Status</th></tr></thead>
      <tbody id="results"></tbody>
    </table>
  </section>

  <section class="card">
    <label>Box</label>
    <select id="box"></select>

    <label style="margin-top:10px">Roster CSV (auto-loads /data/roster.csv)</label>
    <div class="row" style="align-items:end">
      <small id="rosterStatus">Loading‚Ä¶</small>
      <input id="rosterFile" type="file" accept=".csv">
    </div>

    <label style="margin-top:10px">Upload a box photo</label>
    <input id="photo" type="file" accept="image/*" capture="environment">

    <div class="row" style="margin-top:10px">
      <div>
        <label>Edge crop % (ignore left/right)</label>
        <input id="edgePct" type="range" min="0" max="15" step="1" value="4">
      </div>
      <div>
        <label>Blue sensitivity</label>
        <input id="blueSens" type="range" min="10" max="90" step="5" value="45">
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <div>
        <label>Row height % of gap</label>
        <input id="rowPct" type="range" min="50" max="90" step="5" value="70">
      </div>
      <div>
        <label>Guide opacity</label>
        <input id="guideAlpha" type="range" min="20" max="100" step="5" value="90">
      </div>
    </div>

    <div class="toolbar">
      <button id="auto" class="primary">Auto Align</button>
      <button id="tapRows">Quick Tap Rows</button>
      <button id="resetRows">Reset</button>
      <button id="analyze" disabled>Analyze (Green/Red)</button>
      <label style="margin-left:8px"><input id="snapTicks" type="checkbox" checked> Snap to white ticks</label>
      <label style="margin-left:8px"><input id="showGuides" type="checkbox" checked> Show guides</label>
    </div>
  </section>
</main>

<script>
/* ----- constants ----- */
const ROWS=5, SLOTS_PER_ROW=12, TOTAL_SLOTS=ROWS*SLOTS_PER_ROW;

/* ----- UI refs ----- */
const img=document.getElementById('img');
const stage=document.getElementById('stage');
const overlay=document.getElementById('overlay');
const ctx=overlay.getContext('2d');

const statusEl=document.getElementById('status');
const boxSel=document.getElementById('box');
const rosterFile=document.getElementById('rosterFile');
const rosterStatus=document.getElementById('rosterStatus');
const resultsBody=document.getElementById('results');
const boxGrid=document.getElementById('boxGrid');

const photo=document.getElementById('photo');
const autoBtn=document.getElementById('auto');
const tapRowsBtn=document.getElementById('tapRows');
const resetRowsBtn=document.getElementById('resetRows');
const analyzeBtn=document.getElementById('analyze');

const edgePctEl=document.getElementById('edgePct');
const blueSensEl=document.getElementById('blueSens');
const rowPctEl=document.getElementById('rowPct');
const guideAlphaEl=document.getElementById('guideAlpha');
const snapTicksEl=document.getElementById('snapTicks');
const showGuidesEl=document.getElementById('showGuides');

const edgeCrop=()=>+edgePctEl.value/100;
const blueSens=()=>+blueSensEl.value/100;
const rowFrac=()=>+rowPctEl.value/100;
const guideAlpha=()=>+guideAlphaEl.value/100;
const setStatus=t=>statusEl.textContent=t||'';

/* ----- state ----- */
let current=null; // {image,W,H}
let roster=[];
let rowBottoms=[];       // full-res y for top of blue band (row bottom)
let bandLR=[];          // per row: {xL,xR}
let wallsByRow=[];      // per row: 13 x's
let rois=[];            // 60 rects
let occMask=[];
let quickTap=false, quickYs=[];

/* ----- boxes ----- */
(function fillBoxes(){
  const ids=[], grades=['9','10','11','12'], letters=['A','B','C','D','E','F'];
  grades.forEach(g=>letters.forEach(l=>ids.push(g+l))); ids.push('SM1','SM2');
  boxSel.innerHTML=ids.map(x=>`<option>${x}</option>`).join('');
})();

/* ----- roster ----- */
function parseCSV(text){
  const rows=[]; let row=[], cur='', inQ=false; const push=()=>{row.push(cur);cur='';};
  for(let i=0;i<text.length;i++){
    const ch=text[i], nx=text[i+1];
    if(inQ){ if(ch==='"'&&nx==='"'){cur+='"';i++;} else if(ch==='"'){inQ=false;} else cur+=ch; }
    else{ if(ch==='"') inQ=true; else if(ch===',') push();
      else if(ch==='\n'||ch==='\r'){ if(ch==='\r'&&nx==='\n') i++; push(); rows.push(row); row=[]; }
      else cur+=ch; }
  } push(); if(row.length) rows.push(row);
  const header = rows.shift().map(h=>h.trim());
  return rows.filter(r=>r.some(x=>x&&x.trim()!=='')).map(r=>{const o={}; header.forEach((h,i)=>o[h]=r[i]||''); return o;});
}
async function loadRoster(){
  rosterStatus.textContent='Loading /data/roster.csv‚Ä¶';
  try{
    const res=await fetch('/data/roster.csv',{cache:'no-store'});
    if(res.ok){ roster=parseCSV(await res.text()); rosterStatus.textContent='Loaded /data/roster.csv ‚úì'; return; }
  }catch{}
  rosterStatus.textContent='Could not load /data/roster.csv (upload below).';
}
loadRoster();
rosterFile.addEventListener('change',()=>{
  const f=rosterFile.files[0]; if(!f) return;
  const r=new FileReader();
  r.onload=()=>{ roster=parseCSV(r.result||''); rosterStatus.textContent='Loaded from file ‚úì'; };
  r.readAsText(f);
});
function namesForBox(boxId){
  const out={};
  for(const r of roster){
    const sec=(r['Security Number']||r['SecurityNumber']||'').toUpperCase().replace(/\s+/g,'');
    const m=sec.match(/^(SM\d|\d{1,2}[A-F])[- ]?(\d{1,2})$/);
    if(!m) continue; const box=m[1], slot=+m[2];
    if(box===boxId) out[slot]=r['Full Name']||r['FullName']||'';
  }
  return out;
}

/* ----- image loading ----- */
photo.addEventListener('change', e=>{
  const f=e.target.files[0]; if(!f) return;
  const url=URL.createObjectURL(f); const im=new Image();
  im.onload=()=>{ current={image:im,W:im.naturalWidth,H:im.naturalHeight}; img.src=url; img.style.display='block'; sizeStage(); draw(); setStatus('Photo loaded. Tap Auto Align.'); };
  im.onerror=()=>setStatus('Could not load image.'); im.src=url;
});
window.addEventListener('resize', sizeStage);
function sizeStage(){
  if(!current) return;
  const W=stage.clientWidth, H=Math.max(240, Math.round(W*(current.H/current.W)));
  stage.style.height=H+'px';
  const dpr=window.devicePixelRatio||1;
  overlay.style.width=W+'px'; overlay.style.height=H+'px';
  overlay.width=Math.round(W*dpr); overlay.height=Math.round(H*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0); // use CSS pixels for drawing
}

/* ----- buttons ----- */
autoBtn.addEventListener('click', async ()=>{
  if(!current) return alert('Upload a photo first.');
  analyzeBtn.disabled=true;
  setStatus('Detecting blue strips‚Ä¶');
  rowBottoms = await detectBlueStrips(current.image, edgeCrop(), blueSens());
  if(rowBottoms.length!==ROWS){ setStatus('Could not find 5 strips. Use Quick Tap Rows and tap each strip.'); draw(); return; }

  bandLR=[]; wallsByRow=[];
  for(const yB of rowBottoms){
    bandLR.push(await bandInterior(current.image, yB, edgeCrop(), blueSens()));
  }
  for(let r=0;r<ROWS;r++){
    const {xL,xR}=bandLR[r];
    wallsByRow[r]=buildWalls(current.image, rowBottoms[r], xL, xR, snapTicksEl.checked);
  }
  buildROIs();
  draw();
  analyzeBtn.disabled=false;
  setStatus('Aligned. Tap ‚ÄúAnalyze‚Äù.');
});

tapRowsBtn.addEventListener('click', ()=>{
  if(!current) return alert('Upload a photo first.');
  quickTap=true; quickYs=[]; setStatus('Tap each blue number strip once (5 taps)‚Ä¶');
});
resetRowsBtn.addEventListener('click', ()=>{ rowBottoms=[]; bandLR=[]; wallsByRow=[]; rois=[]; occMask=[]; draw(); setStatus('Reset.'); });

stage.addEventListener('pointerdown', async e=>{
  if(!quickTap||!current) return;
  const {iy}=screenToImage(e.clientX,e.clientY);
  quickYs.push(iy); drawTapLine(iy);
  if(quickYs.length===ROWS){
    quickTap=false; rowBottoms=quickYs.slice().sort((a,b)=>a-b);
    bandLR=[]; wallsByRow=[];
    for(const yB of rowBottoms){ bandLR.push(await bandInterior(current.image, yB, edgeCrop(), blueSens())); }
    for(let r=0;r<ROWS;r++){ const {xL,xR}=bandLR[r]; wallsByRow[r]=buildWalls(current.image, rowBottoms[r], xL, xR, snapTicksEl.checked); }
    buildROIs(); draw(); analyzeBtn.disabled=false; setStatus('Rows set. Tap ‚ÄúAnalyze‚Äù.');
  }
});

analyzeBtn.addEventListener('click', ()=>{
  if(rois.length!==TOTAL_SLOTS) return alert('Align rows first.');
  occMask = rois.map(r => slotOccupied(cropROI(r)));
  paintOverlay();
  const names=namesForBox(boxSel.value||'');
  resultsBody.innerHTML='';
  for(let i=0;i<TOTAL_SLOTS;i++){
    const slot=i+1, expected=names[slot]||'';
    const status = occMask[i] ? (expected?'present':'unexpected phone') : (expected?'missing':'empty');
    const tr=document.createElement('tr');
    tr.className = status==='missing'?'missing':(status==='present'?'ok':'');
    tr.innerHTML=`<td>${slot}</td><td>${expected}</td><td><span class="pill">${status}</span></td>`;
    resultsBody.appendChild(tr);
  }
  [...boxGrid.children].forEach((d,i)=>{ d.classList.toggle('present',!!occMask[i]); d.classList.toggle('empty',!occMask[i]); });
  setStatus('Colorized: green=phone, red=empty.');
});

/* ----- core vision ----- */
// row bottoms (top edge of blue number strip)
async function detectBlueStrips(imgEl, edge, sens){
  const W=imgEl.naturalWidth, H=imgEl.naturalHeight;
  const c=document.createElement('canvas'); c.width=W; c.height=H; const g=c.getContext('2d');
  g.drawImage(imgEl,0,0,W,H); const {data}=g.getImageData(0,0,W,H);
  const x0=Math.round(W*edge), x1=Math.round(W*(1-edge));
  const hueMin=190, hueMax=265, sMin=0.18+0.40*sens, vMin=0.22+0.30*sens;
  const score=new Float32Array(H);
  for(let y=0;y<H;y++){
    let b=0,cnt=0;
    for(let x=x0;x<=x1;x+=2){
      const i=(y*W+x)*4, R=data[i],G=data[i+1],B=data[i+2];
      const {h,s,v}=rgb2hsv(R,G,B);
      if(h>hueMin&&h<hueMax&&s>sMin&&v>vMin) b++;
      cnt++;
    }
    score[y]=cnt?b/cnt:0;
  }
  const s2=smooth(score,8);
  const peaks=pickSpread(peaksAbove(s2,0.35),ROWS,Math.round(H/7)).slice(0,ROWS).sort((a,b)=>a-b);
  return peaks;
}

// interior x-range for numbers band on that row
async function bandInterior(imgEl, yBottom, edge, sens){
  const W=imgEl.naturalWidth, H=imgEl.naturalHeight;
  const c=document.createElement('canvas'); c.width=W; c.height=H; const g=c.getContext('2d');
  g.drawImage(imgEl,0,0,W,H); const {data}=g.getImageData(0,0,W,H);
  const L=Math.round(W*edge), R=Math.round(W*(1-edge));
  const bandH=Math.max(8,Math.round(H*0.02)), y0=Math.min(H-2,yBottom+2), y1=Math.min(H-1,y0+bandH);
  const blue=new Float32Array(W).fill(0);
  for(let x=L;x<=R;x++){
    let cnt=0,b=0;
    for(let y=y0;y<=y1;y++){
      const i=(y*W+x)*4, R0=data[i],G0=data[i+1],B0=data[i+2];
      const {h,s,v}=rgb2hsv(R0,G0,B0);
      if(h>190&&h<265&&s>(0.18+0.30*sens)&&v>(0.22+0.20*sens)) b++; cnt++;
    }
    blue[x]=cnt?b/cnt:0;
  }
  const sb=smooth(blue,4), thr=0.33*Math.max(...sb);
  // longest contiguous run above thr
  let bestLen=0, bxL=L, bxR=R, cur=null;
  for(let x=L;x<=R;x++){
    if(sb[x]>thr){ if(cur===null) cur=x; }
    else if(cur!==null){ const len=x-1-cur; if(len>bestLen){bestLen=len; bxL=cur; bxR=x-1;} cur=null; }
  }
  if(cur!==null){ const len=R-cur; if(len>bestLen){bestLen=len; bxL=cur; bxR=R;} }
  const pad=Math.round((bxR-bxL)*0.01); bxL+=pad; bxR-=pad;
  if(bxR-bxL<60){ bxL=L; bxR=R; } // fallback
  return {xL:bxL, xR:bxR};
}

// 13 walls (12 slots): equal split, optional tick snap
function buildWalls(imgEl, yBottom, xL, xR, snap){
  const per=(xR-xL)/SLOTS_PER_ROW;
  let start=xL;
  if(snap){
    const s=scoreTickStarts(imgEl, yBottom, xL, per);
    if(s!=null) start=s;
  }
  const walls = Array.from({length:SLOTS_PER_ROW+1},(_,k)=>Math.round(start+k*per));
  // monotonic guarantee
  for(let i=1;i<walls.length;i++){ if(walls[i]<=walls[i-1]) walls[i]=walls[i-1]+1; }
  return walls;
}
function scoreTickStarts(imgEl, yBottom, xL, per){
  const W=imgEl.naturalWidth,H=imgEl.naturalHeight;
  const c=document.createElement('canvas'); c.width=W; c.height=H; const g=c.getContext('2d');
  g.drawImage(imgEl,0,0,W,H); const {data}=g.getImageData(0,0,W,H);
  const band=Math.max(8,Math.round(H*0.02));
  const y0=Math.min(H-2,yBottom+2), y1=Math.min(H-1,y0+band);
  const delta=per*0.20;
  let best=null,bestScore=-1;
  for(let s=xL-delta; s<=xL+delta; s+=Math.max(1, per/40)){
    let sum=0;
    for(let k=0;k<=SLOTS_PER_ROW;k++){
      const x=Math.round(s+k*per); if(x<0||x>=W) continue;
      let sc=0,cnt=0;
      for(let y=y0;y<=y1;y++){
        const i=(y*W+x)*4, R0=data[i],G0=data[i+1],B0=data[i+2];
        const {s:sat,v}=rgb2hsv(R0,G0,B0);
        if(v>0.72 && sat<0.35) sc++; cnt++;
      }
      sum += cnt?sc/cnt:0;
    }
    if(sum>bestScore){ bestScore=sum; best=s; }
  }
  return best;
}

/* build ROIs strictly above numbers; height = % of gap to next strip */
function buildROIs(){
  rois=[]; if(!rowBottoms.length) return;
  const gaps=[]; for(let i=1;i<rowBottoms.length;i++) gaps.push(rowBottoms[i]-rowBottoms[i-1]);
  const avgGap = gaps.length?gaps.reduce((a,b)=>a+b,0)/gaps.length: Math.round(current.H/6);
  for(let r=0;r<ROWS;r++){
    const yB=rowBottoms[r];
    const gap=(r<ROWS-1? rowBottoms[r+1]-rowBottoms[r] : avgGap);
    const h=Math.max(12, Math.round(gap*rowFrac()));
    const yT=Math.max(0, yB - h);
    const W=wallsByRow[r]||[];
    for(let i=0;i<SLOTS_PER_ROW;i++){
      const x0=W[i], x1=W[i+1];
      rois.push({x:x0, y:yT, w:Math.max(1,x1-x0), h:yB-yT, row:r, col:i});
    }
  }
}

/* ----- occupancy ----- */
function cropROI(r){ const c=document.createElement('canvas'); c.width=r.w; c.height=r.h; c.getContext('2d').drawImage(current.image,r.x,r.y,r.w,r.h,0,0,r.w,r.h); return c; }
function slotOccupied(c){
  const k=c.getContext('2d');
  const cx=Math.round(c.width*0.18), cw=Math.round(c.width*0.64);
  const cy=Math.round(c.height*0.15), ch=Math.round(c.height*0.60);
  const {data}=k.getImageData(cx,cy,cw,ch);
  const cols=new Float32Array(cw).fill(0); const dark=130;
  for(let y=0;y<ch;y++){ for(let x=0;x<cw;x++){ const i=(y*cw+x)*4; const L=0.299*data[i]+0.587*data[i+1]+0.114*data[i+2]; if(L<dark) cols[x]++; } }
  for(let x=0;x<cw;x++) cols[x]/=ch;
  let best=0,run=0; for(let x=0;x<cw;x++){ if(cols[x]>0.45){ run++; best=Math.max(best,run);} else run=0; }
  return best>=Math.round(cw*0.22);
}

/* ----- drawing (retina-safe) ----- */
function draw(){
  ctx.clearRect(0,0,overlay.width,overlay.height); if(!current) return;
  const viewW = overlay.width/(window.devicePixelRatio||1);
  const viewH = overlay.height/(window.devicePixelRatio||1);
  const sx=viewW/current.W, sy=viewH/current.H, a=guideAlpha();

  if(showGuidesEl.checked){
    // row bottoms
    ctx.strokeStyle=`rgba(50,208,255,${a})`; ctx.lineWidth=2;
    for(const y of rowBottoms){ ctx.beginPath(); ctx.moveTo(0,y*sy); ctx.lineTo(viewW,y*sy); ctx.stroke(); }
    // vertical walls (short, around the blue band area only so no tall ‚Äúwhite poles‚Äù)
    ctx.strokeStyle=`rgba(255,255,255,${a})`; ctx.lineWidth=2;
    for(let r=0;r<ROWs; r++){} // guard typo
    for(let r=0;r<wallsByRow.length;r++){
      const y=rowBottoms[r]*sy;
      const h=24; // small marker for visual check
      (wallsByRow[r]||[]).forEach(x=>{ const xx=x*sx; ctx.beginPath(); ctx.moveTo(xx,y-h); ctx.lineTo(xx,y+h); ctx.stroke(); });
    }
  }
  if(rois.length===TOTAL_SLOTS){
    ctx.strokeStyle='rgba(255,255,255,.95)'; ctx.lineWidth=2;
    for(const r of rois){ ctx.strokeRect(r.x*sx, r.y*sy, r.w*sx, r.h*sy); }
  }
}
function paintOverlay(){
  if(rois.length!==TOTAL_SLOTS) return;
  const viewW = overlay.width/(window.devicePixelRatio||1);
  const viewH = overlay.height/(window.devicePixelRatio||1);
  const sx=viewW/current.W, sy=viewH/current.H;
  ctx.clearRect(0,0,overlay.width,overlay.height);
  for(let i=0;i<rois.length;i++){
    const r=rois[i]; ctx.fillStyle = occMask[i] ? 'rgba(0,200,0,.35)' : 'rgba(255,0,0,.35)';
    ctx.fillRect(r.x*sx, r.y*sy, r.w*sx, r.h*sy);
  }
  if(showGuidesEl.checked){
    ctx.strokeStyle='rgba(255,255,255,.9)'; ctx.lineWidth=1.5;
    for(const r of rois){ ctx.strokeRect(r.x*sx, r.y*sy, r.w*sx, r.h*sy); }
  }
}

/* ----- helpers ----- */
function rgb2hsv(r,g,b){ r/=255; g/=255; b/=255; const max=Math.max(r,g,b),min=Math.min(r,g,b),d=max-min; let h=0; if(d!==0){ if(max===r) h=((g-b)/d)%6; else if(max===g) h=(b-r)/d+2; else h=(r-g)/d+4; h*=60; if(h<0)h+=360; } const s=max===0?0:d/max, v=max; return {h,s,v}; }
function smooth(a,w){const o=new Float32Array(a.length); for(let i=0;i<a.length;i++){let s=0,c=0; for(let k=-w;k<=w;k++){const j=i+k; if(j<0||j>=a.length) continue; s+=a[j]; c++;} o[i]=s/c;} return o;}
function peaksAbove(series, frac){ const m=Math.max(...series); const out=[]; if(!m) return out; for(let y=1;y<series.length-1;y++){ if(series[y]>=frac*m && series[y]>=series[y-1] && series[y]>=series[y+1]) out.push(y);} return out; }
function pickSpread(peaks, need, minDist){ const out=[]; for(const p of peaks){ if(out.every(q=>Math.abs(q-p)>minDist)) out.push(p); if(out.length>=need) break; } return out.sort((a,b)=>a-b); }
function screenToImage(cx,cy){ const r=overlay.getBoundingClientRect(); const x=(cx-r.left)/r.width*current.W; const y=(cy-r.top)/r.height*current.H; return {ix:x, iy:y}; }
function drawTapLine(yImg){ const viewH=overlay.height/(window.devicePixelRatio||1); const sy=viewH/current.H, y=yImg*sy; ctx.save(); ctx.strokeStyle='rgba(50,208,255,.9)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(overlay.width/(window.devicePixelRatio||1),y); ctx.stroke(); ctx.restore(); }

/* ----- mini grid ----- */
(function initGrid(){
  boxGrid.innerHTML='';
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<SLOTS_PER_ROW;c++){
      const d=document.createElement('div'); d.className='slot';
      const s=document.createElement('span'); s.textContent=`#${r*SLOTS_PER_ROW + c + 1}`;
      d.appendChild(s); boxGrid.appendChild(d);
    }
  }
})();
</script>
</body>
</html>
