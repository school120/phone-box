<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Phone Box Attendance â€” Auto + Teach & Train</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">

<!-- CSV parsing -->
<script defer src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

<!-- ML for â€œteach & trainâ€ (all on-device) -->
<script defer src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.1"></script>

<style>
  :root { --bg:#0b1020; --card:#121833; --muted:#8ea0d0; --accent:#3ad0ff; }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu;background:var(--bg);color:#fff}
  header{padding:14px 16px;border-bottom:1px solid rgba(255,255,255,.1);display:flex;align-items:center;gap:12px}
  .badge{background:rgba(255,255,255,.1);padding:4px 8px;border-radius:999px;font-size:12px}
  main{max-width:1100px;margin:0 auto;padding:12px}
  .wrap{display:grid;grid-template-columns:1.05fr .95fr;gap:16px}
  .card{background:var(--card);border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  h2{margin:0 0 12px;font-weight:800}
  label{display:block;margin:.5rem 0 .35rem;color:var(--muted);font-size:14px}
  select,input[type="file"],button{width:100%;padding:12px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:#0e1533;color:#fff}
  button.primary{background:linear-gradient(180deg,#39bdf2,#1aa1d9);border:none;font-weight:700}
  small{color:var(--muted)}
  #stage{position:relative;width:100%;aspect-ratio:3/5;background:#0d1330;border-radius:12px;display:flex;align-items:center;justify-content:center;border:1px dashed rgba(255,255,255,.18);overflow:hidden}
  #img{width:100%;height:100%;object-fit:cover;display:none}
  #overlay{position:absolute;inset:0;pointer-events:none}
  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid rgba(255,255,255,.08);padding:8px 6px;text-align:left}
  tr.missing{background:rgba(255,80,80,.12)}
  tr.ok{opacity:.75}
  .pill{display:inline-block;padding:.15rem .45rem;border-radius:999px;background:rgba(255,255,255,.12);font-size:12px}
  .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:6px}
  .slot{background:#0f1738;border:1px solid rgba(255,255,255,.08);aspect-ratio:3/5;border-radius:8px;position:relative}
  .slot span{position:absolute;inset:auto 6px 6px 6px;font-size:10px;color:var(--muted)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  details summary{cursor:pointer}
  details > div{background:#0f1738;border:1px solid rgba(255,255,255,.1);border-radius:10px;padding:10px}
  @media (max-width: 820px) {
    main{padding:8px}
    .wrap{grid-template-columns:1fr;gap:12px}
    button,select,input[type="file"]{padding:14px 16px;font-size:16px}
    table{display:block;overflow-x:auto;-webkit-overflow-scrolling:touch;white-space:nowrap;border-radius:12px}
    th,td{padding:10px 8px}
  }
</style>
</head>
<body>
<header>
  <div style="font-weight:800">ðŸ“± Phone Box Attendance</div>
  <div class="badge">Auto-calibrate + Teach & Train</div>
</header>

<main>
  <div class="wrap">
    <section class="card">
      <h2>Scan a Box</h2>
      <div class="row">
        <div>
          <label>Choose box</label>
          <select id="box">
            <option value="">(no box)</option>
            <optgroup label="Grade Boxes" id="gradeBoxes"></optgroup>
            <optgroup label="Special"><option>SM1</option><option>SM2</option></optgroup>
          </select>
        </div>
        <div>
          <label>Roster CSV</label>
          <select id="rosterChoice">
            <option value="./data/roster.csv">Use repo roster (./data/roster.csv)</option>
            <option value="upload">Upload CSVâ€¦</option>
          </select>
          <input id="rosterUpload" type="file" accept=".csv" style="display:none;margin-top:6px" />
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <div>
          <label>Take/Upload a photo</label>
          <input id="photo" type="file" accept="image/*" capture="environment" />
        </div>
        <div>
          <label>Auto calibration</label>
          <div style="display:flex;gap:8px;flex-wrap:wrap">
            <button id="auto" class="primary">Auto-calibrate</button>
          </div>
          <small>Cyan = top edge of blue bars; yellow ticks = per-row left/right. Rectangles sit <b>directly above</b> the numbers.</small>
        </div>
      </div>

      <div id="stage" style="margin-top:12px">
        <img id="img" alt="preview"/>
        <canvas id="overlay"></canvas>
      </div>

      <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:12px;align-items:center">
        <button id="analyze" class="primary">Analyze Attendance</button>
        <label style="display:flex;align-items:center;gap:8px">
          <input id="showGuides" type="checkbox" checked style="width:auto"> Show guides
        </label>
        <label style="display:flex;align-items:center;gap:8px">
          <input id="showRects" type="checkbox" checked style="width:auto"> Show rectangles
        </label>
        <details style="margin-left:auto">
          <summary>Debug sliders</summary>
          <div style="display:grid;gap:8px;margin-top:8px">
            <label>Blue hue min (deg) <input id="hMin" type="range" min="170" max="210" step="1" value="190"></label>
            <label>Blue hue max (deg) <input id="hMax" type="range" min="230" max="280" step="1" value="255"></label>
            <label>Blue S min (0â€“1) <input id="sMin" type="range" min="0" max="1" step="0.01" value="0.35"></label>
            <label>Blue V min (0â€“1) <input id="vMin" type="range" min="0" max="1" step="0.01" value="0.25"></label>
            <label>Ignore X edges (% width) <input id="edge" type="range" min="0" max="12" step="1" value="4"></label>
            <label>Detect height (% row gap) <input id="detPct" type="range" min="40" max="100" step="5" value="70"></label>
            <div style="font-size:12px;color:#9ab">Blue tops: <span id="blueList">â€”</span></div>
          </div>
        </details>
      </div>

      <hr style="border:0;border-top:1px solid rgba(255,255,255,.08);margin:14px 0">

      <h2>Teach & Train</h2>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button id="teachToggle">Start Teach mode</button>
          <button id="trainBtn" class="primary">Train model</button>
          <label style="display:flex;align-items:center;gap:8px">
            <input id="useModel" type="checkbox" style="width:auto"> Use trained model in Analyze
          </label>
        </div>
        <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end">
          <button id="exportBtn">Export dataset</button>
          <label for="importInput" style="display:inline-flex;gap:8px;align-items:center">
            <input id="importInput" type="file" accept="application/json" style="display:none">
            <span style="border:1px solid rgba(255,255,255,.12);padding:12px 14px;border-radius:12px;cursor:pointer" onclick="document.getElementById('importInput').click()">Import dataset</span>
          </label>
        </div>
      </div>
      <small id="teachStatus">Dataset: 0 phone / 0 empty â€¢ Model: not trained</small>

      <small id="status" style="display:block;margin-top:8px"></small>
    </section>

    <section class="card">
      <h2>Results</h2>
      <div id="boxGrid" class="grid" style="margin-bottom:10px"></div>
      <table>
        <thead><tr><th>Slot</th><th>Expected</th><th>Status</th></tr></thead>
        <tbody id="results"></tbody>
      </table>
    </section>
  </div>
</main>

<script>
/* --------- Boilerplate UI --------- */
const BOX_IDS=[]; ['9','10','11','12'].forEach(g=>['A','B','C','D','E','F'].forEach(l=>BOX_IDS.push(`${g}${l}`)));
const gradeBoxes=document.getElementById('gradeBoxes'); BOX_IDS.forEach(id=>{const o=document.createElement('option');o.textContent=o.value=id;gradeBoxes.appendChild(o);});

const photo=document.getElementById('photo'), img=document.getElementById('img');
const overlay=document.getElementById('overlay'), ctx=overlay.getContext('2d');
const showGuides=document.getElementById('showGuides'), showRects=document.getElementById('showRects');
const statusEl=document.getElementById('status'), resultsBody=document.getElementById('results');
const rosterChoice=document.getElementById('rosterChoice'), rosterUpload=document.getElementById('rosterUpload');
const boxSel=document.getElementById('box'), boxGrid=document.getElementById('boxGrid');

const hMinEl=document.getElementById('hMin'), hMaxEl=document.getElementById('hMax');
const sMinEl=document.getElementById('sMin'), vMinEl=document.getElementById('vMin');
const edgeEl=document.getElementById('edge'), detPctEl=document.getElementById('detPct');
const blueListEl=document.getElementById('blueList');

let roster=[], currentImage=null;
rosterChoice.addEventListener('change',()=>{ rosterUpload.style.display = rosterChoice.value==='upload'?'block':'none'; });

/* --------- Roster --------- */
async function loadRoster(){
  return new Promise((resolve)=>{
    if(rosterChoice.value==='upload'){
      if(!rosterUpload.files[0]) return resolve([]);
      Papa.parse(rosterUpload.files[0], {header:true, complete:r=>resolve(r.data)});
    } else {
      Papa.parse('./data/roster.csv', {download:true, header:true, complete:r=>resolve(r.data)});
    }
  });
}
function securityToBoxSlot(sec){
  if(!sec) return null; const s=String(sec).replace(/\s+/g,'').toUpperCase();
  const m=s.match(/^(SM\d|\d{1,2}[A-F])[- ]?(\d{1,2})$/); if(!m) return null;
  return {box:m[1], slot:parseInt(m[2],10)};
}
function rosterByBox(boxId){
  const map={}; for(const row of roster){
    const info=securityToBoxSlot(row['Security Number']||row['SecurityNumber']);
    if(info && info.box===boxId) map[info.slot]=row['Full Name'];
  } return map;
}
function drawGrid(namesBySlot={}){
  boxGrid.innerHTML='';
  for(let r=0;r<5;r++) for(let c=0;c<12;c++){
    const idx=r*12+c+1;
    const d=document.createElement('div'); d.className='slot';
    const s=document.createElement('span'); s.textContent=namesBySlot[idx]||`#${idx}`;
    d.appendChild(s); boxGrid.appendChild(d);
  }
}

/* --------- Image load --------- */
photo.addEventListener('change',()=>{
  const f=photo.files[0]; if(!f) return;
  const url=URL.createObjectURL(f);
  const tmp=new Image();
  tmp.onload=()=>{
    const scaled=toMaxSize(tmp,1600);
    img.src = scaled.src; img.style.display='block';
    currentImage = scaled;
    resizeOverlay();
    setTimeout(autoCalibrate, 50);
  };
  tmp.src=url;
});
window.addEventListener('resize', resizeOverlay);
function resizeOverlay(){ if(!currentImage) return; overlay.width=img.clientWidth; overlay.height=img.clientHeight; drawOverlay(); }

/* --------- Auto calibration (blue bars â†’ per-row L/R â†’ 12 slots) --------- */
let rois=[], guides=null; // guides: {tops:[], LR:[[l,r]Ã—5], boundsByRow:[[13]Ã—5]}

document.getElementById('auto').addEventListener('click', autoCalibrate);
;[showGuides, showRects, hMinEl,hMaxEl,sMinEl,vMinEl,edgeEl,detPctEl].forEach(el=>el.addEventListener('input', ()=>{ if(currentImage) autoCalibrate(); }));

async function autoCalibrate(){
  if(!currentImage) return alert('Upload a photo first.');
  statusEl.textContent='Auto-calibratingâ€¦';

  const blue = await findBlueBarsPrecise(downscale(currentImage, 1400), {
    hueMin:parseInt(hMinEl.value,10), hueMax:parseInt(hMaxEl.value,10),
    sMin:parseFloat(sMinEl.value), vMin:parseFloat(vMinEl.value),
    edgeCrop:edgePct()
  });
  if(blue.tops.length!==5){ statusEl.textContent='Could not find 5 blue bars. Adjust sliders or reframe photo.'; drawOverlay({tops:[]}); return; }
  blueListEl.textContent = blue.tops.map(y=>y.toFixed(0)).join(', ');

  const small = downscale(currentImage, 1200);
  const ctxS = small.getContext('2d'); const im = ctxS.getImageData(0,0,small.width,small.height);
  const scaleX = small.width/currentImage.naturalWidth, scaleY = small.height/currentImage.naturalHeight;

  const gaps=[]; for(let i=1;i<blue.tops.length;i++) gaps.push(blue.tops[i]-blue.tops[i-1]);
  const avgGapBig = gaps.length? gaps.reduce((a,b)=>a+b,0)/gaps.length : currentImage.naturalHeight/5;
  const bandHSmall = Math.max(6, Math.round((avgGapBig*0.22)*scaleY));

  const boundsByRow=[]; const LR=[];
  for(const topYbig of blue.tops){
    const topY = Math.max(0, Math.round(topYbig*scaleY));
    const colBlue = blueAmountByColumn(im, topY+1, Math.min(im.height-1, topY+bandHSmall),
                                      parseInt(hMinEl.value,10), parseInt(hMaxEl.value,10),
                                      parseFloat(sMinEl.value), parseFloat(vMinEl.value));
    const [L,R] = findLargestBlueRun(colBlue, Math.round(im.width*edgePct()));
    LR.push([L,R]);
    const boundsSmall = equalBounds(L, R, 12);
    boundsByRow.push(boundsSmall.map(x=> Math.round(x/scaleX)));
  }

  const detectH = Math.max(10, Math.round(avgGapBig * (parseInt(detPctEl.value,10)/100)));
  const roisOut=[];
  for(let r=0;r<5;r++){
    const yBottom = Math.max(0, blue.tops[r]);
    const yTop = Math.max(0, yBottom - detectH);
    const bounds = boundsByRow[r];
    for(let c=0;c<12;c++){
      const x0=bounds[c], x1=bounds[c+1];
      const base = Math.round((x1-x0)*0.10);
      const edge = (c===0||c===11)? Math.round((x1-x0)*0.18) : 0;
      const xa = x0 + Math.max(base,edge);
      const xb = x1 - Math.max(base,edge);
      roisOut.push({
        x: xa/currentImage.naturalWidth,
        y: yTop/currentImage.naturalHeight,
        w: Math.max(1, xb-xa)/currentImage.naturalWidth,
        h: Math.max(1, yBottom-yTop)/currentImage.naturalHeight
      });
    }
  }
  rois = roisOut;
  guides = { tops: blue.tops, LR: LR.map(([l,r]) => [l/scaleX, r/scaleX]) };
  statusEl.textContent='Calibrated.';
  drawOverlay();
}

/* --------- Analyze (presence rule OR trained model) --------- */
document.getElementById('analyze').addEventListener('click', analyze);

async function analyze(){
  if(!rois.length) return alert('Calibrate first.');
  statusEl.textContent='Analyzingâ€¦';
  const names=boxSel.value ? rosterByBox(boxSel.value) : {};
  drawGrid(names);

  const rec=[];
  for(let i=0;i<rois.length;i++){
    const slot=i+1; const expected=names[slot]||'';
    const crop = cropROI(currentImage, rois[i]);
    let occ;
    if(useTrainedModel && headModel){ occ = await predictPhone(crop); }
    else { occ = slotOccupied(crop); }
    const status = occ ? (expected?'present':'unexpected phone') : (expected?'missing':'empty');
    rec.push({slot, expected, status});
  }
  resultsBody.innerHTML='';
  for(const r of rec){
    const tr=document.createElement('tr');
    tr.className = r.status==='missing' ? 'missing' : (r.status==='present' ? 'ok' : '');
    tr.innerHTML=`<td>${r.slot}</td><td>${r.expected||''}</td><td><span class="pill">${r.status}</span></td>`;
    resultsBody.appendChild(tr);
  }
  statusEl.textContent='Done.';
}

/* --------- Teach & Train --------- */
const teachToggle=document.getElementById('teachToggle');
const trainBtn=document.getElementById('trainBtn');
const teachStatus=document.getElementById('teachStatus');
const exportBtn=document.getElementById('exportBtn');
const importInput=document.getElementById('importInput');
const useModelEl=document.getElementById('useModel');

const TRAIN_KEY='phonebox_teach_dataset_v1';
let teachMode=false, dataset=loadDataset(); // {X: [emb], y:[0/1]}
let mobilenetModel=null, headModel=null, useTrainedModel=false;

teachToggle.addEventListener('click', ()=>{
  if(!rois.length) return alert('Calibrate first.');
  teachMode = !teachMode;
  overlay.style.pointerEvents = teachMode ? 'auto' : 'none';
  teachToggle.textContent = teachMode ? 'Stop Teach mode' : 'Start Teach mode';
  drawOverlay();
});

useModelEl.addEventListener('change', ()=>{ useTrainedModel = useModelEl.checked; });

overlay.addEventListener('click', async (e)=>{
  if(!teachMode || !currentImage) return;
  const rect=overlay.getBoundingClientRect();
  const x=(e.clientX-rect.left)/overlay.width;
  const y=(e.clientY-rect.top)/overlay.height;
  const idx = rois.findIndex(r => x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h);
  if(idx<0) return;
  const roi = rois[idx];
  const crop = cropROI(currentImage, roi);
  const label = await promptLabel(); // 1=phone, 0=empty
  if(label==null) return;
  const emb = await embedROI(crop);
  dataset.X.push(emb); dataset.y.push(label);
  saveDataset(dataset);
  drawOverlay(); updateTeachStatus();
});

trainBtn.addEventListener('click', async ()=>{
  if(dataset.y.length < 10) return alert('Add at least ~10 labeled examples (mix of phone & empty).');
  await ensureModels();
  const xs = tf.tensor2d(dataset.X);  // [N, 1024]
  const ys = tf.tensor2d(dataset.y.map(v=>[v]));
  await headModel.fit(xs, ys, {epochs:15, batchSize:16, shuffle:true, validationSplit:0.15});
  xs.dispose(); ys.dispose();
  updateTeachStatus(true);
  alert('Training complete. Enable "Use trained model" and run Analyze.');
});

exportBtn.addEventListener('click', ()=>{
  const blob = new Blob([JSON.stringify(dataset)], {type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='phonebox_dataset.json'; a.click();
});
importInput.addEventListener('change', ()=>{
  const f=importInput.files[0]; if(!f) return;
  const r=new FileReader(); r.onload=()=>{ dataset=JSON.parse(r.result); saveDataset(dataset); updateTeachStatus(); }; r.readAsText(f);
});

function updateTeachStatus(trained=false){
  const phones = dataset.y.filter(v=>v===1).length;
  const empties = dataset.y.filter(v=>v===0).length;
  const modelTxt = trained || headModel ? 'trained' : 'not trained';
  teachStatus.textContent = `Dataset: ${phones} phone / ${empties} empty â€¢ Model: ${modelTxt}`;
}

/* Label prompt UI (quick + mobile-friendly) */
function promptLabel(){
  return new Promise(res=>{
    const ok=confirm('Label this slot as PHONE? (Cancel = EMPTY)');
    res(ok?1:0);
  });
}

/* ML helpers */
async function ensureModels(){
  if(!mobilenetModel) mobilenetModel = await mobilenet.load(); // feature extractor
  if(!headModel){
    headModel = tf.sequential();
    headModel.add(tf.layers.dense({units:64, activation:'relu', inputShape:[1024]}));
    headModel.add(tf.layers.dropout({rate:0.2}));
    headModel.add(tf.layers.dense({units:1, activation:'sigmoid'}));
    headModel.compile({optimizer:tf.train.adam(0.001), loss:'binaryCrossentropy', metrics:['accuracy']});
  }
}
async function embedROI(cnv){
  await ensureModels();
  return tf.tidy(()=>{
    const t = tf.browser.fromPixels(cnv).toFloat();
    const r = tf.image.resizeBilinear(t, [224,224], true).div(255);
    const b = r.expandDims(0);
    const a = mobilenetModel.infer(b, 'conv_preds'); // [1,1024]
    const arr = a.squeeze().arraySync();
    return arr;
  });
}
async function predictPhone(cnv){
  await ensureModels();
  const emb = await embedROI(cnv);
  const p = headModel.predict(tf.tensor2d([emb]));
  const val = (await p.data())[0]; p.dispose();
  return val >= 0.5;
}

/* dataset persistence */
function loadDataset(){ try{ return JSON.parse(localStorage.getItem(TRAIN_KEY)) || {X:[],y:[]}; }catch{return {X:[],y:[]};} }
function saveDataset(d){ localStorage.setItem(TRAIN_KEY, JSON.stringify(d)); }

/* Teach overlay draw */
function drawOverlay(){
  ctx.clearRect(0,0,overlay.width,overlay.height);
  if(!currentImage) return;
  // guides
  if(showGuides.checked && guides && guides.tops){
    ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--accent')||'#3ad0ff';
    ctx.lineWidth=2;
    for(const y of guides.tops){
      const yy = y * (overlay.height/currentImage.naturalHeight);
      ctx.beginPath(); ctx.moveTo(0,yy); ctx.lineTo(overlay.width,yy); ctx.stroke();
    }
    if(guides.LR){
      ctx.strokeStyle='#ffd63a'; ctx.lineWidth=1.25;
      const h = Math.max(10, overlay.height*0.04);
      guides.LR.forEach(([L,R],i)=>{
        const y = guides.tops[i] * (overlay.height/currentImage.naturalHeight);
        const xL = L * (overlay.width/currentImage.naturalWidth);
        const xR = R * (overlay.width/currentImage.naturalWidth);
        ctx.beginPath(); ctx.moveTo(xL, y-h); ctx.lineTo(xL, y+h); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(xR, y-h); ctx.lineTo(xR, y+h); ctx.stroke();
      });
    }
  }
  // rectangles
  if(rois.length && showRects.checked){
    ctx.lineWidth=2;
    rois.forEach((r,i)=>{
      const x=r.x*overlay.width, y=r.y*overlay.height, w=r.w*overlay.width, h=r.h*overlay.height;
      // if teach mode, lightly fill a color based on last label added for that slot (optional)
      if(teachMode){
        ctx.fillStyle='rgba(0,0,0,0.15)'; ctx.fillRect(x,y,w,h);
      }
      ctx.strokeStyle='rgba(255,255,255,.95)'; ctx.strokeRect(x,y,w,h);
    });
  }
  overlay.style.pointerEvents = teachMode ? 'auto' : 'none';
}

/* --------- Low-level helpers (blue find, occupancy, etc.) --------- */
function toMaxSize(img, maxW=1600){
  const r=Math.min(1, maxW/img.naturalWidth);
  if(r===1) return img;
  const c=document.createElement('canvas'); c.width=Math.round(img.naturalWidth*r); c.height=Math.round(img.naturalHeight*r);
  c.getContext('2d').drawImage(img,0,0,c.width,c.height);
  const out=new Image(); out.src=c.toDataURL('image/jpeg',0.92); return out;
}
function edgePct(){ return (parseInt(edgeEl.value,10))/100; }
function downscale(img, maxW=900){ const r=Math.min(1,maxW/img.naturalWidth); const c=document.createElement('canvas'); c.width=Math.round(img.naturalWidth*r); c.height=Math.round(img.naturalHeight*r); c.getContext('2d').drawImage(img,0,0,c.width,c.height); return c; }
function rgb2hsv(r,g,b){ r/=255; g/=255; b/=255; const max=Math.max(r,g,b), min=Math.min(r,g,b), d=max-min; let h=0; if(d!==0){ if(max===r) h=((g-b)/d)%6; else if(max===g) h=(b-r)/d+2; else h=(r-g)/d+4; h*=60; if(h<0) h+=360; } const s=max===0?0:d/max, v=max; return {h,s,v}; }
function smooth1D(arr, w=5){ const out=new Float32Array(arr.length); for(let i=0;i<arr.length;i++){ let s=0,c=0; for(let k=-w;k<=w;k++){ const j=i+k; if(j<0||j>=arr.length) continue; s+=arr[j]; c++; } out[i]=s/c; } return out; }

/* precise blue bar finder: returns top edges */
async function findBlueBarsPrecise(canvas, {hueMin,hueMax,sMin,vMin,edgeCrop}){
  const cx=canvas.getContext('2d'), {width:W,height:H}=canvas;
  const {data}=cx.getImageData(0,0,W,H);
  const x0=Math.round(W*edgeCrop), x1=Math.round(W*(1-edgeCrop));
  const frac=new Float32Array(H);
  for(let y=0;y<H;y++){
    let cnt=0, blue=0;
    for(let x=x0;x<=x1;x+=2){
      const i=(y*W+x)*4; const {h,s,v}=rgb2hsv(data[i],data[i+1],data[i+2]);
      if((h>hueMin&&h<hueMax)&&s>=sMin&&v>=vMin) blue++; cnt++;
    }
    frac[y]=cnt?blue/cnt:0;
  }
  let s = smooth1D(frac,6);
  let peaks = pickPeaks(s,5,Math.round(H/8));
  if(peaks.length<5){
    for(let y=0;y<H;y++){
      let cnt=0, blue=0;
      for(let x=x0;x<=x1;x++){
        const i=(y*W+x)*4; const {h,s,v}=rgb2hsv(data[i],data[i+1],data[i+2]);
        const ok=(h>hueMin-5&&h<hueMax+5)&&s>=Math.max(0.2,sMin-0.1)&&v>=Math.max(0.18,vMin-0.07);
        if(ok) blue++; cnt++;
      }
      frac[y]=cnt?blue/cnt:0;
    }
    s=smooth1D(frac,8); peaks=pickPeaks(s,5,Math.round(H/9));
  }
  const tops=[]; const win=Math.round(H*0.035);
  for(const p of peaks){
    const a=Math.max(0,p-win), b=Math.min(H-1,p+win);
    let M=0; for(let y=a;y<=b;y++) M=Math.max(M,s[y]); const T=M*0.5;
    let top=p; for(let y=p;y>=a;y--){ if(s[y]>=T) top=y; else break; }
    tops.push(top);
  }
  return {tops:tops.sort((a,b)=>a-b)};
}
function pickPeaks(series,count,minDist){
  const idx=[...series].map((v,i)=>[v,i]).sort((a,b)=>b[0]-a[0]); const sel=[];
  for(const [,i] of idx){ if(sel.every(j=>Math.abs(j-i)>minDist)) sel.push(i); if(sel.length>=count) break; }
  return sel.sort((a,b)=>a-b);
}

function blueAmountByColumn(im, y0, y1, hueMin,hueMax,sMin,vMin){
  const {data,width:W}=im; const col=new Float32Array(W).fill(0);
  for(let x=0;x<W;x++){
    let s=0; for(let y=y0; y<=y1; y++){
      const i=(y*W+x)*4; const {h,s:S,v}=rgb2hsv(data[i],data[i+1],data[i+2]);
      if((h>hueMin&&h<hueMax)&&S>=sMin&&v>=vMin) s++;
    } col[x]=s;
  }
  return smooth1D(col,6);
}
function findLargestBlueRun(col, pad){
  const W=col.length, L=pad, R=W-pad-1;
  const thr = quantile([...col].slice(L,R+1), 0.55);
  let mask=new Uint8Array(W).fill(0); for(let x=L;x<=R;x++) mask[x]=col[x]>=thr?1:0;
  mask = close1D(mask, Math.max(1, Math.round(W/500)));
  const runs = runsFromMask(mask, L, R);
  if(!runs.length) return [L,R];
  let best=runs[0], width=best.end-best.start;
  for(const r of runs){ const w=r.end-r.start; if(w>width){ width=w; best=r; } }
  return [best.start, best.end];
}
function quantile(a,q){ const b=[...a].sort((x,y)=>x-y); const i=Math.max(0,Math.min(b.length-1, Math.floor(q*(b.length-1)))); return b[i]; }
function runsFromMask(mask, L, R){ const out=[]; let inRun=false, s=L; for(let x=L; x<=R; x++){ if(mask[x] && !inRun){ inRun=true; s=x; } if((!mask[x] || x===R) && inRun){ const e = (!mask[x] && x> L) ? x-1 : x; out.push({start:s,end:e}); inRun=false; } } return out; }
function close1D(mask, rad){ return erode1D(dilate1D(mask,rad),rad); }
function dilate1D(mask,rad){ const out=new Uint8Array(mask.length); for(let i=0;i<mask.length;i++){ let v=0; for(let k=-rad;k<=rad;k++){ const j=i+k; if(j>=0&&j<mask.length&&mask[j]){ v=1; break; } } out[i]=v; } return out; }
function erode1D(mask,rad){ const out=new Uint8Array(mask.length); for(let i=0;i<mask.length;i++){ let v=1; for(let k=-rad;k<=rad;k++){ const j=i+k; if(!(j>=0&&j<mask.length&&mask[j])){ v=0; break; } } out[i]=v; } return out; }
function equalBounds(L,R,n){ const step=(R-L)/n; const b=[L]; for(let i=1;i<n;i++) b.push(Math.round(L+i*step)); b.push(R); return b; }

function cropROI(imgEl, roi){
  const c=document.createElement('canvas'); const W=imgEl.naturalWidth, H=imgEl.naturalHeight;
  c.width=Math.round(roi.w*W); c.height=Math.round(roi.h*H);
  const sx=roi.x*W, sy=roi.y*H;
  c.getContext('2d').drawImage(imgEl, sx,sy, roi.w*W, roi.h*H, 0,0,c.width,c.height);
  return c;
}
function slotOccupied(c){
  const ctx=c.getContext('2d');
  const cx=Math.round(c.width*0.20), cw=Math.round(c.width*0.60);
  const cy=Math.round(c.height*0.15), ch=Math.round(c.height*0.60);
  const {data}=ctx.getImageData(cx,cy,cw,ch);
  const cols=new Float32Array(cw).fill(0); const dark=130;
  for(let y=0;y<ch;y++){ for(let x=0;x<cw;x++){ const i=(y*cw+x)*4; const L=0.299*data[i]+0.587*data[i+1]+0.114*data[i+2]; if(L<dark) cols[x]++; } }
  for(let x=0;x<cw;x++) cols[x]/=ch;
  let best=0,run=0; for(let x=0;x<cw;x++){ if(cols[x]>0.5){ run++; best=Math.max(best,run);} else run=0; }
  return best>=Math.round(cw*0.25);
}
</script>
</body>
</html>
