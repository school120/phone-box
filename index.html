<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Phone Box â€¢ 12 Slots / Row (7-tap + adaptive detector)</title>
<style>
  :root{--bg:#0b1020;--card:#11183a;--muted:#9ab0e0}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:#fff;font-family:system-ui,-apple-system,Inter,Roboto,Segoe UI}
  header{padding:14px 16px;border-bottom:1px solid #ffffff1a;font-weight:800}
  main{max-width:1200px;margin:0 auto;padding:12px;display:grid;grid-template-columns:1.06fr .94fr;gap:16px}
  .card{background:#11183a;border:1px solid #ffffff1a;border-radius:16px;padding:14px}
  label{display:block;margin:10px 0 6px;color:var(--muted);font-size:14px}
  input[type="file"],select,button{width:100%;padding:14px 16px;border-radius:12px;border:1px solid #ffffff2b;background:#0f1738;color:#fff;font-size:16px}
  button.primary{background:linear-gradient(180deg,#3bc2f2,#1aa1d9);border:none;font-weight:800}
  small{color:var(--muted)}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:12px}
  .pill{display:inline-block;padding:.2rem .6rem;border-radius:999px;background:#ffffff24;font-size:12px}

  #stage{position:relative;border:1px dashed #ffffff33;border-radius:12px;overflow:hidden;background:#0c1333;min-height:240px;touch-action:none}
  #img{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:none;z-index:0}
  #overlay{position:absolute;inset:0;pointer-events:none;z-index:1}

  .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:6px;margin:10px 0}
  .slot{background:#0f1738;border:1px solid #ffffff24;aspect-ratio:3/5;border-radius:8px;position:relative}
  .slot span{position:absolute;inset:auto 6px 6px 6px;font-size:12px;color:#9ab0ff}
  .slot.present{outline:2px solid rgba(0,200,0,.85); background:linear-gradient(transparent, rgba(0,200,0,.18))}
  .slot.empty{outline:2px solid rgba(255,0,0,.85); background:linear-gradient(transparent, rgba(255,0,0,.18))}

  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid #ffffff1f;padding:10px 6px;text-align:left}
  tr.missing{background:#ff50501a}
  tr.ok{opacity:.95}

  @media (max-width: 900px){
    main{grid-template-columns:1fr}
    header{font-size:18px}
  }
</style>
</head>
<body>
<header>ðŸ“± Phone Box â€” 7 taps (Left, Right, then 5 rows). 12 slots/row. Adaptive phone detector.</header>

<main>
  <section class="card">
    <div id="stage">
      <img id="img" alt="preview">
      <canvas id="overlay"></canvas>
    </div>
    <div class="toolbar">
      <span class="pill" id="status">Upload a photo to begin.</span>
    </div>
    <div class="grid" id="boxGrid"></div>
    <table>
      <thead><tr><th>Slot</th><th>Expected</th><th>Status</th></tr></thead>
      <tbody id="results"></tbody>
    </table>
  </section>

  <section class="card">
    <label>Box</label>
    <select id="box"></select>

    <label style="margin-top:10px">Roster CSV (auto-loads /data/roster.csv)</label>
    <div style="display:flex; gap:8px; align-items:center">
      <small id="rosterStatus">Loadingâ€¦</small>
      <input id="rosterFile" type="file" accept=".csv">
    </div>

    <label style="margin-top:10px">Upload a box photo</label>
    <input id="photo" type="file" accept="image/*" capture="environment">

    <div class="toolbar">
      <button id="start" class="primary">Start 7-tap Align</button>
      <button id="reset">Reset</button>
      <button id="analyze" disabled>Analyze (Green/Red)</button>
      <label><input id="showGuides" type="checkbox" checked> Show guides</label>
    </div>
  </section>
</main>

<script>
/* ===== constants ===== */
const ROWS=5, SLOTS_PER_ROW=12, TOTAL_SLOTS=ROWS*SLOTS_PER_ROW;

/* ===== UI refs ===== */
const img=document.getElementById('img');
const stage=document.getElementById('stage');
const overlay=document.getElementById('overlay');
const ctx=overlay.getContext('2d');
const statusEl=document.getElementById('status');
const resultsBody=document.getElementById('results');
const boxGrid=document.getElementById('boxGrid');

const boxSel=document.getElementById('box');
const rosterFile=document.getElementById('rosterFile');
const rosterStatus=document.getElementById('rosterStatus');

const photo=document.getElementById('photo');
const startBtn=document.getElementById('start');
const resetBtn=document.getElementById('reset');
const analyzeBtn=document.getElementById('analyze');
const showGuidesEl=document.getElementById('showGuides');

/* ===== state ===== */
let current=null; // {image,W,H}
let roster=[];
let Lx=null, Rx=null;     // global L/R ends of the number strip
let rowBottoms=new Array(ROWS).fill(null); // y per row (tap on blue bar)
let walls=[];             // 13 global walls (same for all rows)
let rois=[];              // 60 rects
let occMask=[];
let mode='idle';          // 'idle'|'tapL'|'tapR'|'tapRows'
let tapRowIndex=0;

const setStatus = t => statusEl.textContent=t||'';

/* ===== boxes ===== */
(function fillBoxes(){
  const ids=[], grades=['9','10','11','12'], letters=['A','B','C','D','E','F'];
  grades.forEach(g=>letters.forEach(l=>ids.push(g+l))); ids.push('SM1','SM2');
  boxSel.innerHTML=ids.map(x=>`<option>${x}</option>`).join('');
})();

/* ===== roster ===== */
function parseCSV(text){
  const rows=[]; let row=[], cur='', inQ=false; const push=()=>{row.push(cur);cur='';};
  for(let i=0;i<text.length;i++){
    const ch=text[i], nx=text[i+1];
    if(inQ){ if(ch==='"'&&nx==='"'){cur+='"';i++;} else if(ch==='"'){inQ=false;} else cur+=ch; }
    else{ if(ch==='"') inQ=true; else if(ch===',') push();
      else if(ch==='\n'||ch==='\r'){ if(ch==='\r'&&nx==='\n') i++; push(); rows.push(row); row=[]; }
      else cur+=ch; }
  } push(); if(row.length) rows.push(row);
  const header = rows.shift().map(h=>h.trim());
  return rows.filter(r=>r.some(x=>x&&x.trim()!=='')).map(r=>{const o={}; header.forEach((h,i)=>o[h]=r[i]||''); return o;});
}
async function loadRoster(){
  rosterStatus.textContent='Loading /data/roster.csvâ€¦';
  try{
    const res=await fetch('/data/roster.csv',{cache:'no-store'});
    if(res.ok){ roster=parseCSV(await res.text()); rosterStatus.textContent='Loaded /data/roster.csv âœ“'; return; }
  }catch{}
  rosterStatus.textContent='Could not load /data/roster.csv (upload below).';
}
loadRoster();
rosterFile.addEventListener('change',()=>{
  const f=rosterFile.files[0]; if(!f) return;
  const r=new FileReader();
  r.onload=()=>{ roster=parseCSV(r.result||''); rosterStatus.textContent='Loaded from file âœ“'; };
  r.readAsText(f);
});
function namesForBox(boxId){
  const out={};
  for(const r of roster){
    const sec=(r['Security Number']||r['SecurityNumber']||'').toUpperCase().replace(/\s+/g,'');
    const m=sec.match(/^(SM\d|\d{1,2}[A-F])[- ]?(\d{1,2})$/);
    if(!m) continue; const box=m[1], slot=+m[2];
    if(box===boxId) out[slot]=r['Full Name']||r['FullName']||'';
  }
  return out;
}

/* ===== image load & overlay sizing ===== */
photo.addEventListener('change', e=>{
  const f=e.target.files[0]; if(!f) return;
  const url=URL.createObjectURL(f); const im=new Image();
  im.onload=()=>{ current={image:im,W:im.naturalWidth,H:im.naturalHeight}; img.src=url; img.style.display='block'; sizeStage(); resetAll(); setStatus('Photo loaded. Tap â€œStart 7-tap Alignâ€.'); };
  im.onerror=()=>setStatus('Could not load image.'); im.src=url;
});
window.addEventListener('resize', sizeStage);
function sizeStage(){
  if(!current) return;
  const stageW=stage.clientWidth;
  const stageH=Math.max(240, Math.round(stageW*(current.H/current.W)));
  stage.style.height=stageH+'px';
  const dpr=window.devicePixelRatio||1;
  overlay.style.width=stageW+'px';
  overlay.style.height=stageH+'px';
  overlay.width=Math.round(stageW*dpr);
  overlay.height=Math.round(stageH*dpr);
  // draw in image pixels scaled to fit width
  const scale = stageW/current.W;
  ctx.setTransform(dpr*scale,0,0,dpr*scale,0,0);
  draw();
}

/* ===== interaction ===== */
startBtn.addEventListener('click', ()=>{
  if(!current) return alert('Upload a photo first.');
  resetAlignment();
  mode='tapL';
  setStatus('Tap the LEFT end of any blue number strip (near â€œ1â€).');
});
resetBtn.addEventListener('click', ()=>{ resetAll(); setStatus('Reset. Tap â€œStart 7-tap Alignâ€.'); });

stage.addEventListener('pointerdown', e=>{
  if(!current) return;
  const rect=overlay.getBoundingClientRect();
  const x=(e.clientX-rect.left)/(overlay.width/(window.devicePixelRatio||1)) * current.W;
  const y=(e.clientY-rect.top )/(overlay.height/(window.devicePixelRatio||1)) * current.H;

  if(mode==='tapL'){
    Lx=Math.max(0,Math.min(current.W-2, Math.round(x)));
    mode='tapR';
    setStatus('Now tap the RIGHT end of the blue strip (near â€œ12â€).');
    draw();
  }else if(mode==='tapR'){
    Rx=Math.max(Lx+10, Math.min(current.W-1, Math.round(x)));
    // build global 13 walls from Lx..Rx
    walls = Array.from({length:SLOTS_PER_ROW+1},(_,k)=>Math.round(Lx + k*(Rx-Lx)/SLOTS_PER_ROW));
    mode='tapRows'; tapRowIndex=0;
    setStatus('Now tap ON each blue strip (row bottom), topâ†’bottom: Row 1.');
    draw();
  }else if(mode==='tapRows'){
    rowBottoms[tapRowIndex]=Math.max(0,Math.min(current.H-1, Math.round(y)));
    tapRowIndex++;
    if(tapRowIndex<ROWS){
      setStatus(`Row ${tapRowIndex} set. Tap Row ${tapRowIndex+1}.`);
    }else{
      mode='idle';
      buildROIsFrom7Taps();
      analyzeBtn.disabled=false;
      setStatus('Aligned. Tap â€œAnalyze (Green/Red)â€.');
    }
    draw();
  }
});

analyzeBtn.addEventListener('click', ()=>{
  if(rois.length!==TOTAL_SLOTS){
    alert('Alignment incomplete. Do the 7 taps (Left, Right, then 5 rows).');
    return;
  }
  occMask = rois.map(r => slotOccupied(cropROI(r)));
  paintOverlay();
  const names = namesForBox(boxSel.value||'');
  resultsBody.innerHTML='';
  for(let i=0;i<TOTAL_SLOTS;i++){
    const slot=i+1, expected=names[slot]||'';
    const status = occMask[i] ? (expected?'present':'unexpected phone') : (expected?'missing':'empty');
    const tr=document.createElement('tr');
    tr.className = status==='missing'?'missing':(status==='present'?'ok':'');
    tr.innerHTML=`<td>${slot}</td><td>${expected}</td><td><span class="pill">${status}</span></td>`;
    resultsBody.appendChild(tr);
  }
  [...boxGrid.children].forEach((d,i)=>{ d.classList.toggle('present',!!occMask[i]); d.classList.toggle('empty',!occMask[i]); });
  setStatus('Done: green=phone, red=empty.');
});

/* ===== build ROIs from 7 taps ===== */
function buildROIsFrom7Taps(){
  rois=[];
  // derive gap per row to size rectangles (70% of gap up to next strip; last row â†’ average)
  const ys=rowBottoms.slice().sort((a,b)=>a-b);
  const gaps=[]; for(let i=1;i<ys.length;i++) gaps.push(ys[i]-ys[i-1]);
  const avg=gaps.length?gaps.reduce((a,b)=>a+b,0)/gaps.length: Math.round(current.H/6);

  for(let r=0;r<ROWS;r++){
    const yB=rowBottoms[r];
    const gap = (r<ROWS-1? rowBottoms[r+1]-rowBottoms[r] : avg);
    const h   = Math.max(12, Math.round(gap*0.70));
    const yT  = Math.max(0, yB - h);
    for(let i=0;i<SLOTS_PER_ROW;i++){
      const x0=walls[i], x1=walls[i+1];
      rois.push({x:x0,y:yT,w:Math.max(1,x1-x0),h:yB-yT,row:r,col:i});
    }
  }
}

/* ===== occupancy detection (adaptive 2-of-3 vote) ===== */
function cropROI(r){ const c=document.createElement('canvas'); c.width=r.w; c.height=r.h; c.getContext('2d').drawImage(current.image,r.x,r.y,r.w,r.h,0,0,r.w,r.h); return c; }

function slotOccupied(c) {
  const k = c.getContext('2d');

  // Slot ROI (center area)
  const cx = Math.round(c.width * 0.18),  cw = Math.round(c.width * 0.64);
  const cy = Math.round(c.height * 0.15), ch = Math.round(c.height * 0.62);

  // Foam reference: top band + side gutters (avoid center where phone lives)
  const refTopH  = Math.max(6, Math.round(ch * 0.18));
  const refGutW  = Math.max(6, Math.round(cw * 0.12));
  const refTop   = k.getImageData(cx, cy, cw, refTopH).data;
  const refLeft  = k.getImageData(cx, cy, refGutW, ch).data;
  const refRight = k.getImageData(cx + cw - refGutW, cy, refGutW, ch).data;

  const stats = (data) => {
    let sum=0, sum2=0, n=0;
    for (let i=0;i<data.length;i+=4) { const L=0.299*data[i]+0.587*data[i+1]+0.114*data[i+2]; sum+=L; sum2+=L*L; n++; }
    const mean=sum/n, std=Math.sqrt(Math.max(0, sum2/n - mean*mean));
    return {mean, std};
  };

  const r1=stats(refTop), r2=stats(refLeft), r3=stats(refRight);
  const foamMean = (r1.mean + r2.mean + r3.mean)/3;
  const foamStd  = Math.max(6, (r1.std + r2.std + r3.std)/3); // floor to avoid zero in flat light

  // Slot center image
  const roi = k.getImageData(cx, cy, cw, ch);
  const d = roi.data;

  // 1) DARKNESS vs local foam baseline
  const kStd = 1.1;                 // sensitivity to variance
  const margin = 10;                // absolute offset
  const darkThresh = foamMean - kStd*foamStd - margin;
  let darkCnt=0, sumL=0, nPix=d.length/4;
  for (let i=0;i<d.length;i+=4) {
    const L=0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
    if (L < darkThresh) darkCnt++;
    sumL += L;
  }
  const darkFrac = darkCnt / nPix;
  const roiMean  = sumL / nPix;
  const meanDrop = foamMean - roiMean; // overall darker than foam

  // 2) EDGE ENERGY (Sobel)
  const {edgeFrac, gradMean} = sobelEnergy(roi);

  // 3) PORT BAND DARKNESS (bottom-center)
  const pbY  = cy + Math.round(ch * 0.60);
  const pbH  = Math.max(4, Math.round(ch * 0.18));
  const pbX  = cx + Math.round(cw * 0.35);
  const pbW  = Math.max(8, Math.round(cw * 0.30));
  const pb   = k.getImageData(pbX, pbY, pbW, pbH).data;
  let pbDark=0; for (let i=0;i<pb.length;i+=4){
    const L=0.299*pb[i]+0.587*pb[i+1]+0.114*pb[i+2];
    if (L < (foamMean - 0.6*foamStd - 6)) pbDark++;
  }
  const portDarkFrac = pbDark / (pb.length/4);

  // votes (adaptive thresholds)
  const VOTE_DARK      = (darkFrac >= 0.22) || (meanDrop >= 12);
  const VOTE_EDGE      = (edgeFrac >= 0.15) && (gradMean >= 22);
  const VOTE_PORT      = (portDarkFrac >= 0.18);

  const votes = (VOTE_DARK?1:0) + (VOTE_EDGE?1:0) + (VOTE_PORT?1:0);
  return votes >= 2;
}

// Sobel helper on ImageData (RGBA)
function sobelEnergy(imgData) {
  const w = imgData.width, h = imgData.height, d = imgData.data;
  const gray = new Uint8Array(w*h);
  for (let y=0, i=0, j=0; y<h; y++) {
    for (let x=0; x<w; x++, i+=4, j++) {
      gray[j] = (0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2])|0;
    }
  }
  let strong=0, sum=0, cnt=0;
  for (let y=1; y<h-1; y++) {
    for (let x=1; x<w-1; x++) {
      const p = y*w + x;
      const gx = -gray[p-w-1] -2*gray[p-1] -gray[p+w-1] + gray[p-w+1] +2*gray[p+1] +gray[p+w+1];
      const gy = -gray[p-w-1] -2*gray[p-w] -gray[p-w+1] + gray[p+w-1] +2*gray[p+w] +gray[p+w+1];
      const mag = Math.hypot(gx, gy);
      sum += mag; cnt++;
      if (mag > 90) strong++;
    }
  }
  const edgeFrac = strong / Math.max(1,cnt);
  const gradMean = sum / Math.max(1,cnt);
  return { edgeFrac, gradMean };
}

/* ===== drawing ===== */
function draw(){
  ctx.clearRect(0,0,overlay.width,overlay.height); if(!current) return;

  // row cyan lines
  if(showGuidesEl.checked){
    ctx.strokeStyle='rgba(50,208,255,.9)'; ctx.lineWidth=2/(window.devicePixelRatio||1);
    for(const y of rowBottoms){ if(Number.isFinite(y)){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(current.W,y); ctx.stroke(); } }
  }
  // L/R markers
  if(showGuidesEl.checked){
    ctx.strokeStyle='rgba(255,255,255,.9)'; ctx.lineWidth=3/(window.devicePixelRatio||1);
    if(Number.isFinite(Lx)){ ctx.beginPath(); ctx.moveTo(Lx,0); ctx.lineTo(Lx,Math.min(current.H,40)); ctx.stroke(); }
    if(Number.isFinite(Rx)){ ctx.beginPath(); ctx.moveTo(Rx,0); ctx.lineTo(Rx,Math.min(current.H,40)); ctx.stroke(); }
  }
  // walls (short hash near top just as a sanity marker)
  if(showGuidesEl.checked && walls.length===SLOTS_PER_ROW+1){
    ctx.strokeStyle='rgba(255,255,255,.7)'; ctx.lineWidth=2/(window.devicePixelRatio||1);
    for(const x of walls){ ctx.beginPath(); ctx.moveTo(x,10); ctx.lineTo(x,26); ctx.stroke(); }
  }
  // rois
  if(rois.length===TOTAL_SLOTS){
    ctx.strokeStyle='rgba(255,255,255,.95)'; ctx.lineWidth=2/(window.devicePixelRatio||1);
    for(const r of rois) ctx.strokeRect(r.x,r.y,r.w,r.h);
  }
}
function paintOverlay(){
  if(rois.length!==TOTAL_SLOTS) return;
  ctx.clearRect(0,0,overlay.width,overlay.height);
  for(let i=0;i<rois.length;i++){
    const r=rois[i]; ctx.fillStyle = occMask[i] ? 'rgba(0,200,0,.35)' : 'rgba(255,0,0,.35)';
    ctx.fillRect(r.x,r.y,r.w,r.h);
  }
  ctx.strokeStyle='rgba(255,255,255,.9)'; ctx.lineWidth=1.5/(window.devicePixelRatio||1);
  for(const r of rois) ctx.strokeRect(r.x,r.y,r.w,r.h);
}

/* ===== utils & reset ===== */
function resetAlignment(){ Lx=null; Rx=null; rowBottoms=new Array(ROWS).fill(null); walls=[]; rois=[]; occMask=[]; draw(); analyzeBtn.disabled=true; }
function resetAll(){ resetAlignment(); resultsBody.innerHTML=''; }
function rgb2hsv(r,g,b){ r/=255; g/=255; b/=255; const max=Math.max(r,g,b),min=Math.min(r,g,b),d=max-min; let h=0; if(d!==0){ if(max===r) h=((g-b)/d)%6; else if(max===g) h=(b-r)/d+2; else h=(r-g)/d+4; h*=60; if(h<0)h+=360; } const s=max===0?0:d/max, v=max; return {h,s,v}; }

/* ===== mini grid ===== */
(function initGrid(){
  for(let r=0;r<ROWS;r++){ for(let c=0;c<SLOTS_PER_ROW;c++){
    const d=document.createElement('div'); d.className='slot';
    const s=document.createElement('span'); s.textContent=`#${r*SLOTS_PER_ROW + c + 1}`;
    d.appendChild(s); boxGrid.appendChild(d);
  }}}
)();
</script>
</body>
</html>
