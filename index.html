<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Phone Box Scanner (Auto blue strips â†’ 12 slots â†’ seam detector)</title>
<style>
  :root{--bg:#0b1020;--card:#10183a;--muted:#9ab0e0}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:#fff;font-family:system-ui,-apple-system,Inter,Roboto,Segoe UI}
  header{padding:12px 16px;border-bottom:1px solid #ffffff20;font-weight:800}
  main{max-width:1200px;margin:0 auto;padding:12px;display:grid;grid-template-columns:1.15fr .85fr;gap:16px}
  .card{background:var(--card);border:1px solid #ffffff1f;border-radius:16px;padding:14px}
  label{display:block;margin:10px 0 6px;color:var(--muted);font-size:14px}
  input[type=file],select,button{width:100%;padding:14px 16px;border-radius:12px;border:1px solid #ffffff30;background:#0f1738;color:#fff;font-size:16px}
  button.primary{background:linear-gradient(180deg,#3bc2f2,#1aa1d9);border:none;font-weight:800}
  small{color:var(--muted)}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:12px}
  .pill{display:inline-block;padding:.2rem .6rem;border-radius:999px;background:#ffffff24;font-size:12px}
  #stage{position:relative;border:1px dashed #ffffff33;border-radius:12px;overflow:hidden;background:#0c1333;min-height:260px;touch-action:none}
  #preview{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:none;z-index:0}
  #overlay{position:absolute;inset:0;pointer-events:none;z-index:1}
  .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:6px;margin:10px 0}
  .slot{background:#0f1738;border:1px solid #ffffff24;aspect-ratio:3/5;border-radius:8px;position:relative}
  .slot span{position:absolute;inset:auto 6px 6px 6px;font-size:12px;color:#9ab0ff}
  .slot.present{outline:2px solid rgba(0,200,0,.85); background:linear-gradient(transparent, rgba(0,200,0,.18))}
  .slot.empty{outline:2px solid rgba(255,0,0,.85); background:linear-gradient(transparent, rgba(255,0,0,.18))}
  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid #ffffff1f;padding:10px 6px;text-align:left}
  tr.missing{background:#ff50501a}
  tr.ok{opacity:.95}
  details{margin-top:8px}
  code{background:#00000040;padding:2px 6px;border-radius:6px}
  @media (max-width: 900px){ main{grid-template-columns:1fr} header{font-size:18px} }
</style>
</head>
<body>
<header>ðŸ“± Phone Box Scanner â€” Auto-detect blue strips â†’ 12 slots aligned to white separators â†’ seam-based phone detector.</header>

<main>
  <section class="card">
    <div id="stage">
      <img id="preview" alt="preview">
      <canvas id="overlay"></canvas>
    </div>
    <div class="toolbar">
      <span class="pill" id="status">Upload a photo to begin.</span>
    </div>
    <div class="grid" id="boxGrid"></div>
    <table>
      <thead><tr><th>Slot</th><th>Expected</th><th>Status</th></tr></thead>
      <tbody id="results"></tbody>
    </table>
  </section>

  <section class="card">
    <label>Box</label>
    <select id="box"></select>

    <label style="margin-top:10px">Roster CSV (auto-loads <code>/data/roster.csv</code>)</label>
    <div style="display:flex; gap:8px; align-items:center">
      <small id="rosterStatus">Loadingâ€¦</small>
      <input id="rosterFile" type="file" accept=".csv">
    </div>

    <label style="margin-top:10px">Upload a box photo</label>
    <input id="photo" type="file" accept="image/*" capture="environment">

    <div class="toolbar">
      <button id="auto" class="primary" disabled>Auto detect & analyze</button>
      <button id="reset">Reset</button>
      <label><input id="showGuides" type="checkbox" checked> Show guides</label>
    </div>

    <details>
      <summary>Advanced (only if needed)</summary>
      <label>Blue sensitivity (HSV Î”)</label>
      <input type="range" id="blueDelta" min="0" max="40" value="18">
      <small>Raise this if it says it canâ€™t find 5 blue bars.</small>
    </details>
  </section>
</main>

<!-- OpenCV.js -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script>
/* ===== UI & state ===== */
const ROWS=5, COLS=12, TOTAL=ROWS*COLS;
const stage = document.getElementById('stage');
const preview = document.getElementById('preview');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');
const statusEl = document.getElementById('status');
const autoBtn = document.getElementById('auto');
const resetBtn = document.getElementById('reset');
const showGuidesEl = document.getElementById('showGuides');
const photo = document.getElementById('photo');
const blueDelta = document.getElementById('blueDelta');
const resultsBody = document.getElementById('results');
const grid = document.getElementById('boxGrid');
const boxSel = document.getElementById('box');
const rosterFile = document.getElementById('rosterFile');
const rosterStatus = document.getElementById('rosterStatus');

let current = null; // {mat}
let rois = [];
let occ = [];
let roster = [];

/* ===== helpers ===== */
function setStatus(t){ statusEl.textContent = t; }
function sizeOverlayToImage(w,h){
  const stageW = stage.clientWidth;
  const dispH = Math.max(260, Math.round(stageW * (h/w)));
  stage.style.height = dispH+'px';
  const dpr = window.devicePixelRatio||1;
  overlay.style.width = stageW+'px';
  overlay.style.height= dispH+'px';
  overlay.width  = Math.round(stageW*dpr);
  overlay.height = Math.round(dispH*dpr);
  const scale = stageW/w;
  ctx.setTransform(dpr*scale,0,0,dpr*scale,0,0);
}
function clearOverlay(){ ctx.clearRect(0,0,overlay.width,overlay.height); }
function line(x1,y1,x2,y2,style='rgba(50,208,255,.9)',lw=2){ ctx.strokeStyle=style; ctx.lineWidth=lw/(window.devicePixelRatio||1); ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }
function rect(r,style='rgba(255,255,255,.9)',lw=2){ ctx.strokeStyle=style; ctx.lineWidth=lw/(window.devicePixelRatio||1); ctx.strokeRect(r.x,r.y,r.w,r.h); }

function parseCSV(text){
  const rows=[]; let row=[], cur='', inQ=false; const push=()=>{row.push(cur);cur='';};
  for(let i=0;i<text.length;i++){
    const ch=text[i], nx=text[i+1];
    if(inQ){ if(ch==='"'&&nx==='"'){cur+='"';i++;} else if(ch==='"'){inQ=false;} else cur+=ch; }
    else{ if(ch==='"') inQ=true; else if(ch===',') push();
      else if(ch==='\n'||ch==='\r'){ if(ch==='\r'&&nx==='\n') i++; push(); rows.push(row); row=[]; }
      else cur+=ch; }
  } push(); if(row.length) rows.push(row);
  const header = rows.shift().map(h=>h.trim());
  return rows.filter(r=>r.some(x=>x&&x.trim()!=='')).map(r=>{const o={}; header.forEach((h,i)=>o[h]=r[i]||''); return o;});
}
async function loadRoster(){
  rosterStatus.textContent='Loading /data/roster.csvâ€¦';
  try{
    const res=await fetch('/data/roster.csv',{cache:'no-store'});
    if(res.ok){ roster=parseCSV(await res.text()); rosterStatus.textContent='Loaded /data/roster.csv âœ“'; return; }
  }catch{}
  rosterStatus.textContent='Could not load /data/roster.csv (upload below).';
}
function namesForBox(boxId){
  const out={};
  for(const r of roster){
    const sec=(r['Security Number']||r['SecurityNumber']||'').toUpperCase().replace(/\s+/g,'');
    const m=sec.match(/^(SM\d|\d{1,2}[A-F])[- ]?(\d{1,2})$/);
    if(!m) continue; const box=m[1], slot=+m[2];
    if(box===boxId) out[slot]=r['Full Name']||r['FullName']||'';
  }
  return out;
}

/* ===== box list ===== */
(function fillBoxes(){
  const ids=[], grades=['9','10','11','12'], letters=['A','B','C','D','E','F'];
  grades.forEach(g=>letters.forEach(l=>ids.push(g+l))); ids.push('SM1','SM2');
  boxSel.innerHTML=ids.map(x=>`<option>${x}</option>`).join('');
})();

/* ===== OpenCV ready + image load ===== */
let cvReady=false;
window.Module = { onRuntimeInitialized() {
  cvReady=true;
  autoBtn.disabled=false;
  setStatus('OpenCV ready. Upload a photo.');
}};
window.addEventListener('resize', ()=>{ if(current) sizeOverlayToImage(current.mat.cols, current.mat.rows); });

photo.addEventListener('change', e=>{
  const f=e.target.files[0]; if(!f) return;
  const url=URL.createObjectURL(f);
  const im=new Image(); im.onload=()=>{
    preview.src=url; preview.style.display='block';
    const mat = cv.imread(im); // full res
    current = {mat};
    sizeOverlayToImage(mat.cols, mat.rows);
    clearOverlay(); rois=[]; occ=[];
    setStatus('Photo loaded. Tap â€œAuto detect & analyzeâ€.');
  };
  im.onerror=()=>setStatus('Could not load image.');
  im.src=url;
});
rosterFile.addEventListener('change',()=>{
  const f=rosterFile.files[0]; if(!f) return;
  const r=new FileReader(); r.onload=()=>{ roster=parseCSV(r.result||''); rosterStatus.textContent='Loaded from file âœ“'; };
  r.readAsText(f);
});
loadRoster();

/* ===== pipeline ===== */
autoBtn.addEventListener('click', ()=>{
  if(!cvReady) return alert('OpenCV is still loading.');
  if(!current) return alert('Upload a photo first.');
  try{
    runPipeline();
  }catch(err){
    console.error(err);
    setStatus('Error while analyzing. Try nudging Blue sensitivity.');
  }
});

function runPipeline(){
  const src = current.mat;
  // Resize longest side to ~1600 px for speed, keep quality
  const scale = 1600 / Math.max(src.cols, src.rows);
  const scaled = new cv.Mat();
  if(scale<1){ cv.resize(src, scaled, new cv.Size(0,0), scale, scale, cv.INTER_AREA); } else { src.copyTo(scaled); }

  /* 1) Blue number strips */
  const hsv = new cv.Mat(); cv.cvtColor(scaled, hsv, cv.COLOR_RGBA2RGB); cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);
  const delta = +blueDelta.value;
  const lower = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [100-delta, 60, 40, 0]);
  const upper = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [130+delta, 255, 255, 255]);
  const mask = new cv.Mat(); cv.inRange(hsv, lower, upper, mask);
  const kH = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(21,5));
  cv.morphologyEx(mask, mask, cv.MORPH_CLOSE, kH);
  cv.morphologyEx(mask, mask, cv.MORPH_OPEN,  kH);
  const contours = new cv.MatVector(), hierarchy = new cv.Mat();
  cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
  let bars=[];
  for(let i=0;i<contours.size();i++){
    const r = cv.boundingRect(contours.get(i));
    const ar = r.width / r.height;
    if(r.width > scaled.cols*0.35 && r.height > 6 && ar > 8){ bars.push(r); }
  }
  bars.sort((a,b)=>a.y-b.y);
  if(bars.length>ROWS) bars = bars.slice(0,ROWS);
  if(bars.length<ROWS){ setStatus('Could not find 5 blue bars. Raise â€œBlue sensitivityâ€.'); cleanup(); return; }

  /* 2) Vertical separators per row (Hough) â†’ 13 walls */
  const rowsY = bars.map(b=>b.y + b.height/2);
  let perRowWalls = [];
  for(const b of bars){
    const roi = scaled.roi(new cv.Rect(Math.max(0,b.x-20), Math.max(0,b.y-8), Math.min(scaled.cols-b.x+20, b.width+40), Math.min(scaled.rows-b.y+16, b.height+16)));
    const gray=new cv.Mat(); cv.cvtColor(roi, gray, cv.COLOR_RGBA2GRAY);
    const edges=new cv.Mat(); cv.Canny(gray, edges, 60, 160, 3, true);
    const lines = new cv.Mat();
    cv.HoughLinesP(edges, lines, 1, Math.PI/180, 30, 18, 6);
    let xs=[];
    for(let i=0;i<lines.rows;i++){
      const [x1,y1,x2,y2] = lines.intPtr(i);
      const len=Math.hypot(x2-x1,y2-y1);
      const ang = Math.atan2(y2-y1, x2-x1)*180/Math.PI;
      if(len>=14 && Math.abs(ang)>80){ xs.push((x1+x2)/2 + (b.x-20)); }
    }
    xs.sort((a,b)=>a-b);
    let walls;
    if(xs.length>=10){
      const samples = new cv.Mat(xs.length,1, cv.CV_32F);
      for(let i=0;i<xs.length;i++) samples.floatPtr(i,0)[0]=xs[i];
      const labels=new cv.Mat(), centers=new cv.Mat();
      cv.kmeans(samples, 13, labels, new cv.TermCriteria(cv.TermCriteria_EPS+cv.TermCriteria_MAX_ITER, 20, 1.0), 3, cv.KMEANS_PP_CENTERS, centers);
      walls = Array.from({length:13},(_,i)=>centers.floatPtr(i,0)[0]).sort((a,b)=>a-b);
      samples.delete(); labels.delete(); centers.delete();
    }else{
      walls = Array.from({length:13},(_,i)=> b.x + i*(b.width)/12);
    }
    perRowWalls.push(walls);
    gray.delete(); edges.delete(); roi.delete(); lines.delete();
  }

  /* 3) Build slot ROIs (above blue bars) */
  const gaps=[]; for(let i=1;i<rowsY.length;i++) gaps.push(rowsY[i]-rowsY[i-1]);
  const avgGap = gaps.length? gaps.reduce((a,b)=>a+b,0)/gaps.length : scaled.rows/6;
  rois = [];
  for(let r=0;r<ROWS;r++){
    const yB = rowsY[r];
    const gap = (r<ROWS-1? rowsY[r+1]-rowsY[r] : avgGap);
    const h   = Math.max(12, Math.round(gap*0.70));
    const yT  = Math.max(0, Math.round(yB - h));
    const walls = perRowWalls[r];
    for(let c=0;c<COLS;c++){
      const x0=Math.round(walls[c]), x1=Math.round(walls[c+1]);
      rois.push({x:x0,y:yT,w:Math.max(1,x1-x0),h:yB-yT,row:r,col:c});
    }
  }

  /* 4) Seam-based cap detection per slot */
  occ = rois.map(r => detectCap(scaled, r));

  /* 5) Overlay + roster */
  sizeOverlayToImage(scaled.cols, scaled.rows);
  clearOverlay();
  if(showGuidesEl.checked){
    rowsY.forEach(y => line(0,y,scaled.cols,y,'rgba(50,208,255,.9)',2));
    perRowWalls.forEach(walls => walls.forEach(x => line(x,10,x,26,'rgba(255,255,255,.7)',2)));
  }
  for(let i=0;i<rois.length;i++){
    const r=rois[i];
    ctx.fillStyle = occ[i] ? 'rgba(0,200,0,.35)' : 'rgba(255,0,0,.35)';
    ctx.fillRect(r.x,r.y,r.w,r.h);
    rect(r,'rgba(255,255,255,.9)',1.5);
  }

  const names = namesForBox(boxSel.value||'');
  resultsBody.innerHTML='';
  for(let i=0;i<TOTAL;i++){
    const slot=i+1, expected=names[slot]||'';
    const status = occ[i] ? (expected?'present':'unexpected phone') : (expected?'missing':'empty');
    const tr=document.createElement('tr');
    tr.className = status==='missing'?'missing':(status==='present'?'ok':'');
    tr.innerHTML=`<td>${slot}</td><td>${expected}</td><td><span class="pill">${status}</span></td>`;
    resultsBody.appendChild(tr);
  }
  [...grid.children].forEach((d,i)=>{ d.classList.toggle('present',!!occ[i]); d.classList.toggle('empty',!occ[i]); });
  setStatus('Done. Green = phone present, Red = empty. If rows were missed, raise â€œBlue sensitivityâ€.');

  function cleanup(){ [hsv, mask, lower, upper, scaled, contours, hierarchy].forEach(m=>{ try{ m.delete(); }catch{} }); }
  cleanup();
}

/* ===== seam detector (horizontal edge + dark band) ===== */
function detectCap(img /*cv.Mat RGBA*/, r){
  // Crop slot & gray
  const roi = img.roi(new cv.Rect(r.x, r.y, r.w, r.h));
  const gray = new cv.Mat(); cv.cvtColor(roi, gray, cv.COLOR_RGBA2GRAY);

  // Search region: upper 60% where caps live
  const y0 = Math.round(r.h * 0.06);
  const y1 = Math.round(r.h * 0.60);
  const hS = Math.max(12, y1 - y0);
  const xL = Math.round(r.w * 0.08);
  const xR = Math.round(r.w * 0.92);
  const wS = Math.max(12, xR - xL);
  const search = gray.roi(new cv.Rect(xL, y0, wS, hS));

  // Horizontal edge (Sobel Y)
  const sobY16 = new cv.Mat(), sobY = new cv.Mat();
  cv.Sobel(search, sobY16, cv.CV_16S, 0, 1, 3, 1, 0, cv.BORDER_DEFAULT);
  cv.convertScaleAbs(sobY16, sobY);
  const blur = new cv.Mat(); cv.GaussianBlur(sobY, blur, new cv.Size(3,3), 0);
  const thr = new cv.Mat(); cv.threshold(blur, thr, 0, 255, cv.THRESH_BINARY|cv.THRESH_OTSU);

  // Row profile: fraction of edge pixels per row
  const rowFrac = new Float32Array(hS);
  for(let y=0; y<hS; y++){
    const p = thr.ptr(y); let cnt=0;
    for(let x=0;x<wS;x++) if(p[x]) cnt++;
    rowFrac[y] = cnt / wS;
  }
  // Smooth
  const sm = new Float32Array(hS);
  for(let y=0;y<hS;y++){ let s=0,c=0; for(let k=-3;k<=3;k++){ const yy=y+k; if(yy>=0&&yy<hS){ s+=rowFrac[yy]; c++; } } sm[y]=s/c; }

  // Peak seam row
  let peakY=0, peakVal=-1; for(let y=0;y<hS;y++){ if(sm[y]>peakVal){ peakVal=sm[y]; peakY=y; } }
  const seamY = y0 + peakY; const seamCoverage = peakVal;

  // Foam baseline (top band + gutters)
  const refTopH = Math.max(4, Math.round(r.h * 0.10));
  const refTop  = gray.roi(new cv.Rect(Math.round(r.w*0.10), 0, Math.round(r.w*0.80), refTopH));
  const refL    = gray.roi(new cv.Rect(0, y0, Math.max(5, Math.round(r.w*0.10)), Math.max(8, Math.round(r.h*0.25))));
  const refR    = gray.roi(new cv.Rect(r.w - Math.max(5, Math.round(r.w*0.10)), y0, Math.max(5, Math.round(r.w*0.10)), Math.max(8, Math.round(r.h*0.25))));
  const stats = (mat)=>{ const m=new cv.Mat(), s=new cv.Mat(); cv.meanStdDev(mat,m,s); const rv={mean:m.doubleAt(0,0), std:s.doubleAt(0,0)}; m.delete(); s.delete(); return rv; };
  const a=stats(refTop), b=stats(refL), c=stats(refR);
  const foamMean = (a.mean+b.mean+c.mean)/3;
  const foamStd  = Math.max(6,(a.std+b.std+c.std)/3);

  // Darkness band just below the seam
  const bandTop = Math.min(r.h-4, seamY + Math.round(r.h*0.02));
  const bandH   = Math.max(6, Math.round(r.h*0.18));
  const bandY   = Math.min(r.h - bandH, bandTop);
  const band    = gray.roi(new cv.Rect(Math.round(r.w*0.12), bandY, Math.round(r.w*0.76), bandH));
  const bStats  = stats(band);
  const meanDrop = foamMean - bStats.mean;
  const darkThr = foamMean - 0.9*foamStd - 9;
  let darkCnt=0; const bArea = band.rows*band.cols;
  for(let y=0;y<band.rows;y++){ const p=band.ptr(y); for(let x=0;x<band.cols;x++){ if(p[x] < darkThr) darkCnt++; } }
  const bandDarkFrac = darkCnt / bArea;

  // Decision thresholds
  const SEAM_MIN   = 0.32;  // min seam coverage
  const SEAM_STRONG= 0.44;  // very wide seam
  const DROP_MIN   = 8;     // mean drop vs foam
  const DARK_FRAC  = 0.20;  // dark pixels in band

  const strongEdge = (seamCoverage >= SEAM_MIN);
  const veryEdge   = (seamCoverage >= SEAM_STRONG);
  const darkOK     = (meanDrop >= DROP_MIN) || (bandDarkFrac >= DARK_FRAC);
  const present = (strongEdge && darkOK) || veryEdge;

  // cleanup
  roi.delete(); gray.delete(); search.delete(); sobY16.delete(); sobY.delete(); blur.delete(); thr.delete();
  refTop.delete(); refL.delete(); refR.delete(); band.delete();
  return present;
}

/* ===== results grid ===== */
(function initGrid(){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const d=document.createElement('div'); d.className='slot';
      const s=document.createElement('span'); s.textContent=`#${r*COLS+c+1}`;
      d.appendChild(s); grid.appendChild(d);
    }
  }
})();
</script>
</body>
</html>
