<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Phone Box ‚Äì Trainable (color+edge kNN)</title>
<style>
  :root{--bg:#0b1020;--card:#10183a;--mut:#9ab0e0}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:#fff;font-family:system-ui,-apple-system,Inter,Roboto}
  header{padding:12px 16px;border-bottom:1px solid #ffffff22;font-weight:800}
  main{max-width:1200px;margin:0 auto;padding:12px;display:grid;grid-template-columns:1.15fr .85fr;gap:16px}
  .card{background:#10183a;border:1px solid #ffffff22;border-radius:16px;padding:14px}
  label{display:block;margin:8px 0 6px;color:var(--mut);font-size:14px}
  input[type=file],select,button{width:100%;padding:12px 14px;border-radius:12px;border:1px solid #ffffff33;background:#0f1738;color:#fff;font-size:16px}
  button.primary{background:linear-gradient(180deg,#39c2f2,#1aa1d9);border:none;font-weight:800}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:10px}
  .pill{display:inline-block;padding:.25rem .6rem;border-radius:999px;background:#ffffff24;font-size:12px}
  #stage{position:relative;border:1px dashed #ffffff33;border-radius:12px;overflow:hidden;background:#0c1333;min-height:260px}
  #preview{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:none}
  #overlay{position:absolute;inset:0;pointer-events:none}
  .mode{display:flex;gap:6px;flex-wrap:wrap}
  .mode > span{padding:.25rem .6rem;border-radius:999px;background:#ffffff18}
  .mode .on{background:#2cc36b}
  table{width:100%;border-collapse:collapse;margin-top:10px}
  th,td{border-bottom:1px solid #ffffff19;padding:8px 6px;text-align:left}
  tr.missing{background:#ff50501a}
  .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:6px;margin:10px 0}
  .slot{background:#0f1738;border:1px solid #ffffff24;aspect-ratio:3/5;border-radius:8px;position:relative}
  .slot.present{outline:2px solid rgba(0,200,0,.85)}
  .slot.empty{outline:2px solid rgba(255,0,0,.85)}
  .slot span{position:absolute;inset:auto 6px 6px 6px;font-size:12px;color:#9ab0ff}
  @media (max-width:900px){ main{grid-template-columns:1fr} header{font-size:18px} }
</style>
</head>
<body>
<header>üì± Phone Box ‚Äî Train it once (few clicks), then scan reliably. Color + edge k-NN, per-box models saved locally.</header>

<main>
  <section class="card">
    <div id="stage">
      <img id="preview" alt="preview">
      <canvas id="overlay"></canvas>
    </div>
    <div class="toolbar">
      <span class="pill" id="status">Upload a photo to begin.</span>
      <span class="mode"><span id="modeView" class="on">View</span><span id="modeTrain">Train</span><span id="modePredict">Predict</span></span>
    </div>

    <div class="grid" id="miniGrid"></div>

    <table>
      <thead><tr><th>Slot</th><th>Expected</th><th>Status</th></tr></thead>
      <tbody id="results"></tbody>
    </table>
  </section>

  <section class="card">
    <label>Box</label>
    <select id="box"></select>

    <label>Roster CSV (auto-loads /data/roster.csv)</label>
    <div style="display:flex;gap:8px;align-items:center">
      <small id="rosterStatus">Loading‚Ä¶</small>
      <input id="rosterFile" type="file" accept=".csv">
    </div>

    <label>Photo (rear camera ok)</label>
    <input id="photo" type="file" accept="image/*" capture="environment">

    <details style="margin-top:8px">
      <summary>Advanced</summary>
      <label>Blue sensitivity (HSV Œî)</label>
      <input type="range" id="blueDelta" min="0" max="40" value="18">
      <small>Raise if it can‚Äôt find 5 blue bars.</small>
    </details>

    <div class="toolbar">
      <button id="auto" class="primary" disabled>Find rows & slots</button>
      <button id="analyze">Analyze</button>
      <button id="reset">Reset</button>
      <label><input id="showGuides" type="checkbox" checked> Show guides</label>
    </div>

    <div class="toolbar">
      <button id="addPresent">‚ûï Add Present sample(s)</button>
      <button id="addEmpty">‚ûï Add Empty sample(s)</button>
      <button id="saveModel">üíæ Save model</button>
      <button id="clearModel">üßπ Clear model</button>
    </div>

    <small>Tip: In Train mode, click one or more slots first (they highlight). Then click ‚ÄúAdd Present‚Äù or ‚ÄúAdd Empty‚Äù. 6‚Äì12 samples total is plenty.</small>
  </section>
</main>

<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script>
/* ---------- constants ---------- */
const ROWS=5, COLS=12, TOTAL=ROWS*COLS;

/* ---------- dom refs ---------- */
const stage=document.getElementById('stage');
const overlay=document.getElementById('overlay');
const ctx=overlay.getContext('2d');
const preview=document.getElementById('preview');
const statusEl=document.getElementById('status');
const showGuides=document.getElementById('showGuides');
const photo=document.getElementById('photo');
const blueDelta=document.getElementById('blueDelta');
const autoBtn=document.getElementById('auto');
const analyzeBtn=document.getElementById('analyze');
const resetBtn=document.getElementById('reset');
const miniGrid=document.getElementById('miniGrid');
const resultsBody=document.getElementById('results');

const modeView=document.getElementById('modeView');
const modeTrain=document.getElementById('modeTrain');
const modePredict=document.getElementById('modePredict');

const addPresent=document.getElementById('addPresent');
const addEmpty=document.getElementById('addEmpty');
const saveModel=document.getElementById('saveModel');
const clearModel=document.getElementById('clearModel');

const boxSel=document.getElementById('box');
const rosterFile=document.getElementById('rosterFile');
const rosterStatus=document.getElementById('rosterStatus');

/* ---------- state ---------- */
let cvReady=false;
let current=null;   // {mat}
let bars=[];        // 5 blue bars rects
let walls=[];       // per row, 13 x positions
let rois=[];        // 60 slot rects {x,y,w,h,row,col}
let picked=new Set(); // selected slot idx (for training)
let roster=[];
let mode='view';    // 'view'|'train'|'predict'

/* ---------- helpers ---------- */
function setStatus(t){statusEl.textContent=t;}
function sizeOverlay(w,h){
  const sw=stage.clientWidth, sh=Math.max(260, Math.round(sw*(h/w)));
  stage.style.height=sh+'px';
  const dpr=window.devicePixelRatio||1;
  overlay.width=Math.round(sw*dpr); overlay.height=Math.round(sh*dpr);
  overlay.style.width=sw+'px'; overlay.style.height=sh+'px';
  const s=sw/w; ctx.setTransform(dpr*s,0,0,dpr*s,0,0);
}
function clearOverlay(){ctx.clearRect(0,0,overlay.width,overlay.height);}
function line(x1,y1,x2,y2,style='rgba(50,208,255,.9)',lw=2){ctx.strokeStyle=style;ctx.lineWidth=lw/(window.devicePixelRatio||1);ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.stroke();}
function rect(r,style='rgba(255,255,255,.9)',lw=2){ctx.strokeStyle=style;ctx.lineWidth=lw/(window.devicePixelRatio||1);ctx.strokeRect(r.x,r.y,r.w,r.h);}
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

/* ---------- boxes ---------- */
(function(){
  const ids=[], grades=['9','10','11','12'], letters=['A','B','C','D','E','F'];
  grades.forEach(g=>letters.forEach(l=>ids.push(g+l))); ids.push('SM1','SM2');
  boxSel.innerHTML=ids.map(x=>`<option>${x}</option>`).join('');
})();

/* ---------- roster ---------- */
function parseCSV(text){
  const rows=[]; let row=[],cur='',q=false; const push=()=>{row.push(cur);cur='';};
  for(let i=0;i<text.length;i++){
    const ch=text[i], nx=text[i+1];
    if(q){ if(ch==='"'&&nx==='"'){cur+='"';i++;} else if(ch==='"'){q=false;} else cur+=ch; }
    else{ if(ch==='"') q=true; else if(ch===',') push();
      else if(ch==='\n'||ch==='\r'){ if(ch==='\r'&&nx==='\n') i++; push(); rows.push(row); row=[]; }
      else cur+=ch; }
  } push(); if(row.length) rows.push(row);
  const header=rows.shift().map(h=>h.trim());
  return rows.filter(r=>r.some(x=>x&&x.trim()!=='')).map(r=>{const o={}; header.forEach((h,i)=>o[h]=r[i]||''); return o;});
}
async function loadRoster(){
  rosterStatus.textContent='Loading /data/roster.csv‚Ä¶';
  try{
    const res=await fetch('/data/roster.csv',{cache:'no-store'});
    if(res.ok){ roster=parseCSV(await res.text()); rosterStatus.textContent='Loaded ‚úì'; return; }
  }catch{}
  rosterStatus.textContent='Could not load /data/roster.csv (upload below).';
}
function namesForBox(id){
  const out={};
  for(const r of roster){
    const sec=(r['Security Number']||r['SecurityNumber']||'').toUpperCase().replace(/\s+/g,'');
    const m=sec.match(/^(SM\d|\d{1,2}[A-F])[- ]?(\d{1,2})$/);
    if(!m) continue; const box=m[1], slot=+m[2]; if(box===id) out[slot]=r['Full Name']||r['FullName']||'';
  }
  return out;
}
loadRoster();
rosterFile.addEventListener('change',()=>{
  const f=rosterFile.files[0]; if(!f) return;
  const r=new FileReader(); r.onload=()=>{ roster=parseCSV(r.result||''); rosterStatus.textContent='Loaded from file ‚úì'; };
  r.readAsText(f);
});

/* ---------- OpenCV init ---------- */
window.Module={onRuntimeInitialized(){cvReady=true;autoBtn.disabled=false;setStatus('OpenCV ready. Upload a photo.')}};
window.addEventListener('resize', ()=>{ if(current) sizeOverlay(current.mat.cols,current.mat.rows); });

/* ---------- image load ---------- */
photo.addEventListener('change',e=>{
  const f=photo.files[0]; if(!f) return;
  const url=URL.createObjectURL(f);
  const im=new Image(); im.onload=()=>{
    preview.src=url; preview.style.display='block';
    const mat=cv.imread(im);
    current={mat};
    sizeOverlay(mat.cols,mat.rows);
    clearOverlay(); bars=[]; walls=[]; rois=[]; picked.clear();
    setStatus('Photo loaded. Click ‚ÄúFind rows & slots‚Äù.');
  };
  im.onerror=()=>setStatus('Could not load image.');
  im.src=url;
});

/* ---------- modes ---------- */
function setMode(m){
  mode=m;
  modeView.classList.toggle('on',m==='view');
  modeTrain.classList.toggle('on',m==='train');
  modePredict.classList.toggle('on',m==='predict');
  setStatus(m==='train'?'Train mode: click slots, then ‚ÄúAdd Present/Empty‚Äù.':(m==='predict'?'Predict mode: press ‚ÄúAnalyze‚Äù.':'View mode.'));
}
modeView.onclick=()=>setMode('view');
modeTrain.onclick=()=>setMode('train');
modePredict.onclick=()=>setMode('predict');

/* ---------- mini grid ---------- */
(function initGrid(){
  for(let i=0;i<TOTAL;i++){
    const d=document.createElement('div'); d.className='slot'; d.dataset.idx=i;
    d.innerHTML=`<span>#${i+1}</span>`;
    d.addEventListener('click',()=>{
      if(mode!=='train') return;
      if(picked.has(i)) picked.delete(i); else picked.add(i);
      d.style.outline= picked.has(i) ? '3px solid #ffd54a' : '';
    });
    miniGrid.appendChild(d);
  }
})();

/* ---------- model storage (per box) ---------- */
function modelKey(){ return 'phonebox_model_' + (boxSel.value||''); }
function saveModelLS(model){ localStorage.setItem(modelKey(), JSON.stringify(model)); setStatus('Model saved for '+boxSel.value); }
function loadModelLS(){ try{ return JSON.parse(localStorage.getItem(modelKey())||'{"x":[],"y":[]}'); }catch{ return {x:[],y:[]} } }
function clearModelLS(){ localStorage.removeItem(modelKey()); setStatus('Cleared model for '+boxSel.value); }

/* ---------- features (color + edge) ---------- */
function featuresFromROI(mat, r){
  // crop ROI
  const roi=mat.roi(new cv.Rect(r.x,r.y,r.w,r.h));
  // cap band: upper 55%
  const y0=Math.round(r.h*0.06), h=Math.round(r.h*0.55), x0=Math.round(r.w*0.08), w=Math.round(r.w*0.84);
  const cap=roi.roi(new cv.Rect(x0,y0,w,h));
  const hsv=new cv.Mat(); cv.cvtColor(cap,hsv,cv.COLOR_RGBA2RGB); cv.cvtColor(hsv,hsv,cv.COLOR_RGB2HSV);
  const gray=new cv.Mat(); cv.cvtColor(cap,gray,cv.COLOR_RGBA2GRAY);
  const sob=new cv.Mat(); cv.Sobel(gray,sob,cv.CV_16S,0,1,3,1,0,cv.BORDER_DEFAULT); const abs=new cv.Mat(); cv.convertScaleAbs(sob,abs);

  // H histogram (16 bins), S histogram (8 bins)
  const hHist=new Array(16).fill(0), sHist=new Array(8).fill(0);
  for(let y=0;y<hsv.rows;y++){
    const p=hsv.ptr(y);
    for(let x=0;x<hsv.cols;x++){
      const H=p[x*3], S=p[x*3+1];
      hHist[Math.min(15, Math.floor(H/12))]++;   // 0..180 ‚Üí 16 bins
      sHist[Math.min(7,  Math.floor(S/32))]++;
    }
  }
  // Edge density profile (8 bins over rows)
  const rowBins=8, binH=Math.max(1, Math.floor(abs.rows/rowBins));
  const eFeat=new Array(rowBins).fill(0);
  for(let y=0;y<abs.rows;y++){
    const p=abs.ptr(y); let cnt=0;
    for(let x=0;x<abs.cols;x++) if(p[x]>90) cnt++;
    eFeat[Math.min(rowBins-1, Math.floor(y/binH))]+=cnt;
  }

  // normalize
  const norm=(a)=>{ const s=a.reduce((x,y)=>x+y,0)||1; return a.map(v=>v/s); };
  const fv=[...norm(hHist), ...norm(sHist), ...norm(eFeat)];

  // cleanup
  roi.delete(); cap.delete(); hsv.delete(); gray.delete(); sob.delete(); abs.delete();
  return fv;
}
function dist(a,b){ // cosine distance
  let dot=0, na=0, nb=0; for(let i=0;i<a.length;i++){ dot+=a[i]*b[i]; na+=a[i]*a[i]; nb+=b[i]*b[i]; }
  return 1 - (dot / (Math.sqrt(na)*Math.sqrt(nb) || 1));
}
function predictKNN(model, fv, k=5){
  const idx=[...Array(model.x.length).keys()].sort((i,j)=>dist(fv,model.x[i])-dist(fv,model.x[j])).slice(0,Math.min(k,model.x.length));
  let score=0; for(const i of idx) score += (model.y[i]==='present'?1:-1);
  return score>=0?'present':'empty';
}

/* ---------- pipeline: find bars ‚Üí 12 walls ‚Üí build ROIs ---------- */
autoBtn.addEventListener('click', ()=>{
  if(!cvReady||!current) return alert('OpenCV ready and photo loaded?');
  findSlots(current.mat);
});
function findSlots(src){
  const scaled=new cv.Mat(); const sc=1600/Math.max(src.cols,src.rows);
  if(sc<1) cv.resize(src,scaled,new cv.Size(0,0),sc,sc,cv.INTER_AREA); else src.copyTo(scaled);

  const hsv=new cv.Mat(); cv.cvtColor(scaled,hsv,cv.COLOR_RGBA2RGB); cv.cvtColor(hsv,hsv,cv.COLOR_RGB2HSV);
  const delta=+blueDelta.value;
  const lower=new cv.Mat(hsv.rows,hsv.cols,hsv.type(),[100-delta,60,40,0]);
  const upper=new cv.Mat(hsv.rows,hsv.cols,hsv.type(),[130+delta,255,255,255]);
  const mask=new cv.Mat(); cv.inRange(hsv,lower,upper,mask);
  const kH=cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(21,5));
  cv.morphologyEx(mask,mask,cv.MORPH_CLOSE,kH);
  cv.morphologyEx(mask,mask,cv.MORPH_OPEN,kH);

  const contours=new cv.MatVector(), hier=new cv.Mat();
  cv.findContours(mask,contours,hier,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);
  bars=[];
  for(let i=0;i<contours.size();i++){
    const r=cv.boundingRect(contours.get(i)); const ar=r.width/r.height;
    if(r.width>scaled.cols*0.35 && r.height>6 && ar>8) bars.push(r);
  }
  bars.sort((a,b)=>a.y-b.y);
  if(bars.length>ROWS) bars=bars.slice(0,ROWS);
  if(bars.length<ROWS){ setStatus('Could not find 5 blue bars. Raise Blue sensitivity.'); cleanup(); return; }

  const rowsY=bars.map(b=>b.y+b.height/2);
  walls=[];
  for(const b of bars){
    const roi=scaled.roi(new cv.Rect(Math.max(0,b.x-20), Math.max(0,b.y-8), Math.min(scaled.cols-b.x+20,b.width+40), Math.min(scaled.rows-b.y+16,b.height+16)));
    const gray=new cv.Mat(); cv.cvtColor(roi,gray,cv.COLOR_RGBA2GRAY);
    const edges=new cv.Mat(); cv.Canny(gray,edges,60,160,3,true);
    const lines=new cv.Mat(); cv.HoughLinesP(edges,lines,1,Math.PI/180,30,18,6);
    let xs=[];
    for(let i=0;i<lines.rows;i++){
      const [x1,y1,x2,y2]=lines.intPtr(i);
      const ang=Math.abs(Math.atan2(y2-y1,x2-x1)*180/Math.PI);
      if(Math.abs(ang)>80) xs.push((x1+x2)/2 + (b.x-20));
    }
    xs.sort((a,b)=>a-b);
    let w;
    if(xs.length>=10){
      const samples=new cv.Mat(xs.length,1,cv.CV_32F);
      for(let i=0;i<xs.length;i++) samples.floatPtr(i,0)[0]=xs[i];
      const labels=new cv.Mat(), centers=new cv.Mat();
      cv.kmeans(samples,13,labels,new cv.TermCriteria(cv.TermCriteria_EPS+cv.TermCriteria_MAX_ITER,20,1.0),3,cv.KMEANS_PP_CENTERS,centers);
      w=Array.from({length:13},(_,i)=>centers.floatPtr(i,0)[0]).sort((a,b)=>a-b);
      samples.delete(); labels.delete(); centers.delete();
    } else {
      w=Array.from({length:13},(_,i)=> b.x + i*b.width/12 );
    }
    walls.push(w);
    gray.delete(); edges.delete(); lines.delete(); roi.delete();
  }

  const gaps=[]; for(let i=1;i<rowsY.length;i++) gaps.push(rowsY[i]-rowsY[i-1]);
  const avgGap=gaps.length?gaps.reduce((a,b)=>a+b,0)/gaps.length:scaled.rows/6;
  rois=[];
  for(let r=0;r<ROWS;r++){
    const yB=rowsY[r], gap=(r<ROWS-1?rowsY[r+1]-rowsY[r]:avgGap);
    const h=Math.max(12,Math.round(gap*0.70)), yT=Math.max(0,Math.round(yB-h));
    const w=walls[r];
    for(let c=0;c<COLS;c++){
      const x0=Math.round(w[c]), x1=Math.round(w[c+1]);
      rois.push({x:x0,y:yT,w:Math.max(1,x1-x0),h:yB-yT,row:r,col:c});
    }
  }

  sizeOverlayToScaled(); drawGuides(rowsY);
  setStatus('Slots locked. Switch to Train or Predict.');
  function cleanup(){[scaled,hsv,mask,lower,upper,contours,hier].forEach(m=>{try{m.delete()}catch{}});}
  function sizeOverlayToScaled(){ sizeOverlay(scaled.cols,scaled.rows); }
}
function drawGuides(rowsY){
  clearOverlay();
  if(showGuides.checked){
    rowsY.forEach(y=>line(0,y, current.mat.cols, y, 'rgba(50,208,255,.9)',2));
    for(const w of walls) w.forEach(x=>line(x,10,x,26,'rgba(255,255,255,.7)',2));
  }
  rois.forEach(r=>rect(r,'rgba(255,255,255,.95)',1.6));
}

/* ---------- TRAIN: collect samples ---------- */
function addSamples(label){
  if(rois.length!==TOTAL){ alert('Run ‚ÄúFind rows & slots‚Äù first.'); return; }
  if(picked.size===0){ alert('In Train mode, click one or more slots, then add samples.'); return; }
  const model=loadModelLS();
  for(const i of picked){
    const fv=featuresFromROI(current.mat, rois[i]);
    model.x.push(fv); model.y.push(label);
  }
  saveModelLS(model);
  picked.clear();
  [...miniGrid.children].forEach(d=>d.style.outline='');
}
addPresent.onclick=()=>{ if(mode!=='train'){setMode('train');} addSamples('present'); };
addEmpty.onclick =()=>{ if(mode!=='train'){setMode('train');} addSamples('empty'); };
saveModel.onclick =()=> saveModelLS(loadModelLS());
clearModel.onclick=()=>{ clearModelLS(); };

/* ---------- PREDICT / ANALYZE ---------- */
analyzeBtn.addEventListener('click', ()=>{
  if(rois.length!==TOTAL){ alert('Run ‚ÄúFind rows & slots‚Äù first.'); return; }
  const model=loadModelLS();
  let occ;
  if(mode==='predict' && model.x.length>=4){
    occ = rois.map(r => predictKNN(model, featuresFromROI(current.mat,r))==='present');
  }else{
    // fallback quick heuristic if no model yet (seam + dark band)
    occ = rois.map(r => quickHeuristic(current.mat,r));
  }
  paintOverlay(occ);
  const names=namesForBox(boxSel.value||'');
  resultsBody.innerHTML='';
  for(let i=0;i<TOTAL;i++){
    const slot=i+1, expected=names[slot]||'';
    const status = occ[i] ? (expected?'present':'unexpected phone') : (expected?'missing':'empty');
    const tr=document.createElement('tr');
    tr.className = status==='missing'?'missing':(status==='present'?'ok':'');
    tr.innerHTML=`<td>${slot}</td><td>${expected}</td><td><span class="pill">${status}</span></td>`;
    resultsBody.appendChild(tr);
  }
  // mini grid colors
  [...miniGrid.children].forEach((d,i)=>{ d.classList.toggle('present',!!occ[i]); d.classList.toggle('empty',!occ[i]); });
});

function paintOverlay(occ){
  clearOverlay();
  for(let i=0;i<rois.length;i++){
    const r=rois[i];
    ctx.fillStyle = occ[i] ? 'rgba(0,200,0,.35)' : 'rgba(255,0,0,.35)';
    ctx.fillRect(r.x,r.y,r.w,r.h);
    rect(r,'rgba(255,255,255,.9)',1.2);
  }
}

/* ---------- quick heuristic (backup if no model yet) ---------- */
function quickHeuristic(img,r){
  // very lightweight seam + darkness
  const roi=img.roi(new cv.Rect(r.x,r.y,r.w,r.h));
  const gray=new cv.Mat(); cv.cvtColor(roi,gray,cv.COLOR_RGBA2GRAY);
  const y0=Math.round(r.h*0.06), y1=Math.round(r.h*0.60);
  const xL=Math.round(r.w*0.08), xR=Math.round(r.w*0.92);
  const search=gray.roi(new cv.Rect(xL,y0,Math.max(12,xR-xL),Math.max(12,y1-y0)));
  const sob16=new cv.Mat(), sob=new cv.Mat(); cv.Sobel(search,sob16,cv.CV_16S,0,1,3,1,0,cv.BORDER_DEFAULT); cv.convertScaleAbs(sob16,sob);
  const blur=new cv.Mat(); cv.GaussianBlur(sob,blur,new cv.Size(3,3),0);
  const thr=new cv.Mat(); cv.threshold(blur,thr,0,255,cv.THRESH_BINARY|cv.THRESH_OTSU);
  let best=0; for(let y=0;y<thr.rows;y++){ const p=thr.ptr(y); let c=0; for(let x=0;x<thr.cols;x++) if(p[x]) c++; best=Math.max(best, c/thr.cols); }
  const seam = best; // 0..1
  const bandTop = Math.min(r.h-4, (y0+Math.round((y1-y0)*0.5)) + Math.round(r.h*0.02));
  const bandH = Math.max(6, Math.round(r.h*0.18));
  const bandY = Math.min(r.h-bandH, bandTop);
  const band=gray.roi(new cv.Rect(Math.round(r.w*0.12), bandY, Math.round(r.w*0.76), bandH));
  const m=new cv.Mat(), s=new cv.Mat(); cv.meanStdDev(band,m,s);
  const bMean=m.doubleAt(0,0); m.delete(); s.delete();
  const foamTop=gray.roi(new cv.Rect(Math.round(r.w*0.10), 0, Math.round(r.w*0.80), Math.max(4,Math.round(r.h*0.10))));
  const m2=new cv.Mat(), s2=new cv.Mat(); cv.meanStdDev(foamTop,m2,s2);
  const foam=m2.doubleAt(0,0); m2.delete(); s2.delete();
  roi.delete(); gray.delete(); search.delete(); sob16.delete(); sob.delete(); blur.delete(); thr.delete(); band.delete(); foamTop.delete();
  return (seam>=0.34 && (foam-bMean>=8)) || (seam>=0.46);
}

/* ---------- reset ---------- */
resetBtn.onclick=()=>{ clearOverlay(); bars=[]; walls=[]; rois=[]; picked.clear(); [...miniGrid.children].forEach(d=>{d.style.outline=''; d.classList.remove('present','empty');}); resultsBody.innerHTML=''; setStatus('Reset. ‚ÄúFind rows & slots‚Äù.'); };

/* ---------- end ---------- */
</script>
</body>
</html>
