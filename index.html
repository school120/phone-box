<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Phone Box Checker – Auto Mode (No Corner Taps)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .card { background:#fff; border-radius:1rem; box-shadow:0 4px 20px rgba(0,0,0,.08); padding:1rem; }
    .btn { padding:.5rem .75rem; border:1px solid #ddd; border-radius:1rem; }
    .btn-primary { background:#111827; color:#fff; border-color:#111827; }
    .badge { display:inline-block; padding:.15rem .45rem; border-radius:.5rem; font-size:.75rem; border:1px solid #e5e7eb; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
</head>
<body class="min-h-screen bg-gray-50 text-gray-900">
  <div id="root" class="p-4 sm:p-6"></div>
  <script>
  const { useEffect, useRef, useState } = React;

  // Correct grid: 5 rows × 12 cols (60) to match your photos
  let GRID = { rows: 5, cols: 12 };
  const STORAGE_KEYS = { roster: 'roster' };

  const Storage = {
    save: (k,v)=> localStorage.setItem(k, JSON.stringify(v)),
    load: (k,f)=> { try { const r = localStorage.getItem(k); return r? JSON.parse(r): f; } catch { return f; } }
  };

  function parseSecurityNumber(sn=''){
    const s=String(sn).trim().toUpperCase(); if(!s) return null;
    let m=s.match(/^\s*(SM\d+)\s*[- ]?\s*(\d{1,2})\s*$/); if(m) return {box:m[1], slot: parseInt(m[2],10)};
    m=s.match(/^(.*?)(\d{1,2})$/); if(!m) return null; const box=m[1]; const slot=parseInt(m[2],10);
    if(!(slot>=1 && slot<=60)) return null; return {box, slot};
  }

  function robustThreshold(values){
    const arr=[...values].sort((a,b)=>a-b); const n=arr.length; if(!n) return 0.02;
    const med = n%2? arr[(n-1)/2] : (arr[n/2-1]+arr[n/2])/2;
    const absDev = arr.map(v=>Math.abs(v-med)).sort((a,b)=>a-b);
    const mad = n%2? absDev[(n-1)/2] : (absDev[n/2-1]+absDev[n/2])/2;
    let thr = med + 1.5*mad;
    if(!isFinite(thr) || thr<=0) thr = med*1.25 + 0.003;
    return Math.min(Math.max(thr, med*1.05), med+0.05);
  }

  function Header(){
    return React.createElement('div',{className:'mb-2'},[
      React.createElement('h1',{className:'text-2xl font-bold'},'Phone Box Checker – Auto Mode (No Corner Taps)'),
      React.createElement('p',{className:'text-xs text-gray-600'},'Assumes a 5×12 grid (60). Detects presence per bay, OCRs label strips, infers the box from your roster Security Numbers (9–12 A–F, SM1/SM2), and lists who is missing.')
    ]);
  }

  function App(){
    const [roster, setRoster] = useState(Storage.load(STORAGE_KEYS.roster, []));
    const [imageURL, setImageURL] = useState(null);
    const [busy, setBusy] = useState(false);
    const [results, setResults] = useState(null);
    const [flip, setFlip] = useState(false);
    const [debug, setDebug] = useState(false);

    const imgRef = useRef(null); const canvasRef = useRef(null);

    useEffect(()=>{ (async()=>{ try{ const res=await fetch('roster.csv',{cache:'no-store'}); if(res.ok){ const text=await res.text(); const parsed=Papa.parse(text,{header:true,skipEmptyLines:true}); const rows=parsed.data.map(r=>({ personId:String(r['Person ID']||r.personId||'').trim(), fullName:String(r['Full Name']||r.fullName||'').trim(), securityNumber:String(r['Security Number']||r.securityNumber||'').trim(), grade:String(r['Current Grade']||r.grade||'').trim(), email:String(r['Email 1']||r.email||'').trim() })).filter(r=>r.personId && r.fullName); if(rows.length) setRoster(rows); } }catch(e){} })(); },[]);

    const onUploadCSV = (file)=>{
      Papa.parse(file,{header:true,skipEmptyLines:true,complete:(res)=>{ const rows=res.data.map(r=>({ personId:String(r['Person ID']||'').trim(), fullName:String(r['Full Name']||'').trim(), securityNumber:String(r['Security Number']||'').trim(), grade:String(r['Current Grade']||'').trim(), email:String(r['Email 1']||'').trim() })).filter(r=>r.personId && r.fullName); setRoster(rows); Storage.save(STORAGE_KEYS.roster, rows); }});
    };

    const onPhoto = (file)=>{ setImageURL(URL.createObjectURL(file)); setResults(null); };

    const analyze = async ()=>{
      if(!imageURL) { alert('Take/Upload a photo first.'); return; }
      if(!window.cv) { alert('OpenCV not ready yet.'); return; }
      setBusy(true);

      const rows = flip ? GRID.cols : GRID.rows;
      const cols = flip ? GRID.rows : GRID.cols;

      const img = imgRef.current; const canvas = canvasRef.current; const W=img.naturalWidth, H=img.naturalHeight; const ctx=canvas.getContext('2d'); canvas.width=W; canvas.height=H; ctx.drawImage(img,0,0,W,H);

      const cv=window.cv; const src=cv.imread(canvas); const present=[]; const labels=[]; const scores=[];
      const cellW=Math.floor(W/cols), cellH=Math.floor(H/rows);

      const worker = await Tesseract.createWorker('eng');
      try{
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            const x=c*cellW, y=r*cellH, cw=cellW, ch=cellH;

            // ROI tuned for your photos
            const roi=new cv.Rect(x+Math.floor(cw*0.10), y+Math.floor(ch*0.08), Math.floor(cw*0.80), Math.floor(ch*0.70));
            const cell=src.roi(roi);
            const gray=new cv.Mat(); cv.cvtColor(cell,gray,cv.COLOR_RGBA2GRAY);
            const blur=new cv.Mat(); cv.GaussianBlur(gray,blur,new cv.Size(5,5),0,0,cv.BORDER_DEFAULT);
            const edges=new cv.Mat(); cv.Canny(blur,edges,35,120);
            const density = cv.countNonZero(edges)/(roi.width*roi.height);
            scores.push(density);
            gray.delete(); blur.delete(); edges.delete(); cell.delete();

            // OCR bottom strip
            const ly = y + Math.floor(ch*0.80); const lh = Math.floor(ch*0.18);
            const lroi = new cv.Rect(x+2, Math.min(ly,H-1), Math.max(1,cw-4), Math.max(1,lh));
            const lcell = src.roi(lroi);
            const lcanvas=document.createElement('canvas'); lcanvas.width=lroi.width; lcanvas.height=lroi.height; cv.imshow(lcanvas, lcell);
            const { data:{ text } } = await worker.recognize(lcanvas);
            labels.push(text.trim());
            lcell.delete();
          }
        }
      } finally { await worker.terminate(); }

      src.delete();

      const thr = robustThreshold(scores);
      for(const s of scores) present.push(s>thr);

      const cellInfo = labels.map((t)=>{
        const clean=t.replace(/[^A-Za-z0-9\-\s]/g,' ').replace(/\s+/g,' ').trim();
        const numMatch = clean.match(/(\d{1,2})/);
        const words = clean.split(' ').filter(Boolean);
        const last = words.find(w=>/^[A-Za-z][A-Za-z\-']+$/.test(w));
        return { label: clean, lastName: last||'', slotHint: numMatch? parseInt(numMatch[1],10): null };
      });

      const votes={};
      for(const info of cellInfo){
        if(!info.lastName || !info.slotHint) continue;
        const cands = roster.filter(r=> r.fullName.toLowerCase().includes(info.lastName.toLowerCase()));
        for(const cand of cands){ const p=parseSecurityNumber(cand.securityNumber); if(p && p.slot===info.slotHint){ votes[p.box]=(votes[p.box]||0)+1; } }
      }
      const inferredBox = Object.entries(votes).sort((a,b)=> b[1]-a[1])[0]?.[0] || null;

      const occupiedSlots = new Set(); for(let i=0;i<present.length;i++) if(present[i]) occupiedSlots.add(i+1);

      const missing=[]; const presentStudents=[];
      if(inferredBox){
        const boxStudents = roster.filter(r=>{ const p=parseSecurityNumber(r.securityNumber); return p && p.box===inferredBox; });
        boxStudents.forEach(stu=>{ const p=parseSecurityNumber(stu.securityNumber); if(!p) return; if(occupiedSlots.has(p.slot)) presentStudents.push(stu); else missing.push(stu); });
      }

      setBusy(false);
      setResults({ inferredBox, presentCount: occupiedSlots.size, missing, presentStudents, cellInfo, scores, thr, rows, cols });
    };

    return React.createElement('div',{className:'max-w-5xl mx-auto space-y-4'},[
      React.createElement(Header,{}),

      React.createElement('div',{className:'card'},[
        React.createElement('h2',{className:'text-lg font-semibold mb-2'},'1) Roster'),
        React.createElement('div',{className:'flex flex-wrap items-center gap-2 text-sm'},[
          React.createElement('label',{className:'btn'},['Upload CSV', React.createElement('input',{type:'file',accept:'.csv',className:'hidden',onChange:e=>{ const f=e.target.files?.[0]; if(f) onUploadCSV(f); }})]),
          React.createElement('a',{href:'roster.csv',className:'btn',download:true},'Download current roster.csv'),
          React.createElement('span',{className:'text-xs text-gray-500'},'We OCR the label under each bay to infer box automatically.')
        ])
      ]),

      React.createElement('div',{className:'card'},[
        React.createElement('h2',{className:'text-lg font-semibold mb-2'},'2) Take/Upload Photo'),
        React.createElement('div',{className:'flex flex-wrap items-center gap-2 text-sm mb-2'},[
          React.createElement('label',{className:'btn'},['Take/Upload Photo', React.createElement('input',{type:'file',accept:'image/*',capture:'environment',className:'hidden',onChange:e=>{ const f=e.target.files?.[0]; if(f) onPhoto(f); }}) ]),
          React.createElement('button',{className:'btn',onClick:()=>setFlip(v=>!v)}, 'Flip grid (', React.createElement('span',{className:'badge'},'rows↔cols'), ')'),
          React.createElement('label',{className:'flex items-center gap-2 text-xs'},[
            React.createElement('input',{type:'checkbox',checked:debug,onChange:e=>setDebug(e.target.checked)}),
            'Debug info'
          ]),
          React.createElement('button',{className:'btn btn-primary',onClick:analyze,disabled:busy || !imageURL}, busy? 'Analyzing…' : 'Analyze')
        ]),
        React.createElement('div',{className:'bg-gray-100 rounded-xl p-2'},[
          imageURL ? React.createElement('img',{src:imageURL,ref:imgRef,alt:'box',className:'w-full h-auto rounded'}) : React.createElement('div',{className:'text-sm text-gray-500 p-8'},'Add a photo (no corner taps needed).')
        ]),
        React.createElement('canvas',{ref:canvasRef,className:'hidden'})
      ]),

      results && React.createElement('div',{className:'card space-y-2'},[
        React.createElement('h3',{className:'font-semibold'},`Results ${results.inferredBox? '— Box '+results.inferredBox:''}`),
        React.createElement('div',{},`Detected occupied bays: ${results.presentCount} (grid ${results.rows}×${results.cols})`),
        debug && React.createElement('div',{className:'text-xs text-gray-500'},`Adaptive threshold=${results.thr.toFixed(4)}; sample densities: ${results.scores.slice(0,12).map(x=>x.toFixed(4)).join(', ')}...`),
        (results.missing && results.missing.length>0) ? React.createElement('div',{},[
          React.createElement('div',{className:'text-sm text-gray-700 font-medium'},'Missing phones ('+results.missing.length+')'),
          React.createElement('ul',{className:'list-disc list-inside text-sm'}, results.missing.map(stu=> React.createElement('li',{key:stu.personId}, `${stu.fullName} — ${stu.securityNumber}`)))
        ]) : React.createElement('div',{className:'text-green-700 text-sm'},'No missing phones detected for this roster/box.'),
        !results.inferredBox && React.createElement('div',{className:'text-xs text-amber-700'},'Could not infer a box. Make sure roster.csv is loaded and labels show a last name plus a slot number.')
      ])
    ]);
  }

  ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(App));
  </script>

  <!-- README (short)
    • Corrected grid to 5×12 (matches your photos). Use the “Flip grid” button if a box is rotated differently.
    • Presence detection now uses an adaptive threshold (median + 1.5×MAD) computed from all cells in the photo — more robust to lighting and glare.
    • ROI tuned (10% side margins, 8% top, 70% height) to avoid borders and focus on the phone body.
    • OCR of bottom label strips extracts a last name + slot number; we infer the box by matching to roster Security Numbers (supports 9–12 A–F and SM1/SM2 like 9B11, SM112, SM1‑12).
    • Keep repo private; place roster.csv at repo root or upload it at runtime.
  -->
</body>
</html>
