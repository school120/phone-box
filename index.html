<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Phone Box â€” 12Ã—5 Slots Above Numbers</title>
<style>
  :root{--bg:#0b1020;--card:#11183a;--muted:#9ab0e0}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:#fff;font-family:system-ui,-apple-system,Inter,Roboto,Segoe UI}
  header{padding:14px 16px;border-bottom:1px solid #ffffff1a;font-weight:800}
  main{max-width:1200px;margin:0 auto;padding:12px;display:grid;grid-template-columns:1.08fr 0.92fr;gap:16px}
  .card{background:#11183a;border:1px solid #ffffff1a;border-radius:16px;padding:14px}
  label{display:block;margin:10px 0 6px;color:var(--muted);font-size:14px}
  input[type="file"],select,button{width:100%;padding:14px 16px;border-radius:12px;border:1px solid #ffffff2b;background:#0f1738;color:#fff;font-size:16px}
  button.primary{background:linear-gradient(180deg,#3bc2f2,#1aa1d9);border:none;font-weight:800}
  small{color:var(--muted)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}

  #stage{position:relative;border:1px dashed #ffffff33;border-radius:12px;overflow:hidden;background:#0c1333;min-height:240px;touch-action:none}
  #img{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:none;z-index:0}
  #overlay{position:absolute;inset:0;pointer-events:none;z-index:1}

  .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:12px}
  .pill{display:inline-block;padding:.2rem .6rem;border-radius:999px;background:#ffffff24;font-size:12px}

  .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:6px;margin:10px 0}
  .slot{background:#0f1738;border:1px solid #ffffff24;aspect-ratio:3/5;border-radius:8px;position:relative}
  .slot span{position:absolute;inset:auto 6px 6px 6px;font-size:12px;color:#9ab0ff}
  .slot.present{outline:2px solid rgba(0,200,0,.85); background:linear-gradient(transparent, rgba(0,200,0,.18))}
  .slot.empty{outline:2px solid rgba(255,0,0,.85); background:linear-gradient(transparent, rgba(255,0,0,.18))}

  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid #ffffff1f;padding:10px 6px;text-align:left}
  tr.missing{background:#ff50501a}
  tr.ok{opacity:.95}

  @media (max-width: 900px){
    main{grid-template-columns:1fr}
    header{font-size:18px}
    .row{grid-template-columns:1fr}
  }
</style>
</head>
<body>
<header>ðŸ“± Phone Box â€” rectangles above each printed number (12Ã—5)</header>

<main>
  <section class="card">
    <div id="stage">
      <img id="img" alt="preview">
      <canvas id="overlay"></canvas>
    </div>
    <div class="toolbar">
      <span class="pill" id="status"></span>
    </div>
    <div class="grid" id="boxGrid"></div>
    <table>
      <thead><tr><th>Slot</th><th>Expected</th><th>Status</th></tr></thead>
      <tbody id="results"></tbody>
    </table>
  </section>

  <section class="card">
    <label>Box</label>
    <select id="box"></select>

    <label style="margin-top:10px">Roster CSV (auto-loads /data/roster.csv)</label>
    <div class="row" style="align-items:end">
      <small id="rosterStatus">Loadingâ€¦</small>
      <input id="rosterFile" type="file" accept=".csv">
    </div>

    <label style="margin-top:10px">Upload a box photo</label>
    <input id="photo" type="file" accept="image/*" capture="environment">

    <div class="row" style="margin-top:10px">
      <div>
        <label>Edge crop % (ignore left/right)</label>
        <input id="edgePct" type="range" min="0" max="15" step="1" value="4">
      </div>
      <div>
        <label>Blue sensitivity</label>
        <input id="blueSens" type="range" min="10" max="90" step="5" value="45">
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <div>
        <label>Row height % of gap</label>
        <input id="rowPct" type="range" min="50" max="90" step="5" value="70">
      </div>
      <div>
        <label>Guide opacity</label>
        <input id="guideAlpha" type="range" min="20" max="100" step="5" value="90">
      </div>
    </div>

    <div class="toolbar">
      <button id="auto" class="primary">Auto Align</button>
      <button id="tapRows">Quick Tap Rows</button>
      <button id="resetRows">Reset</button>
      <button id="analyze" disabled>Colorize + Compare</button>
      <label><input id="showGuides" type="checkbox" checked> Show guides</label>
    </div>
  </section>
</main>

<script>
/* ===== UI refs ===== */
const img = document.getElementById('img');
const stage = document.getElementById('stage');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');

const statusEl = document.getElementById('status');
const boxSel = document.getElementById('box');
const rosterFile = document.getElementById('rosterFile');
const rosterStatus = document.getElementById('rosterStatus');
const resultsBody = document.getElementById('results');
const boxGrid = document.getElementById('boxGrid');

const photo = document.getElementById('photo');
const autoBtn = document.getElementById('auto');
const tapRowsBtn = document.getElementById('tapRows');
const resetRowsBtn = document.getElementById('resetRows');
const analyzeBtn = document.getElementById('analyze');
const showGuidesEl = document.getElementById('showGuides');

const edgePctEl = document.getElementById('edgePct');
const blueSensEl = document.getElementById('blueSens');
const rowPctEl = document.getElementById('rowPct');
const guideAlphaEl = document.getElementById('guideAlpha');

const edgeCrop   = ()=> +edgePctEl.value/100;
const blueSens   = ()=> +blueSensEl.value/100;
const rowFrac    = ()=> +rowPctEl.value/100;
const guideAlpha = ()=> +guideAlphaEl.value/100;
const setStatus  = t => statusEl.textContent = t || '';

/* ===== State ===== */
let current=null;          // {image, W, H}
let roster=[];
let rowBottoms=[];         // y (full-res) of top edge of blue number strip
let boundsByRow=[];        // per row: 13 xs
let rois=[];               // 60 rects
let occMask=[];
let quickTap=false, quickYs=[];

/* ===== Box list ===== */
(function fillBoxes(){
  const ids=[], grades=['9','10','11','12'], letters=['A','B','C','D','E','F'];
  grades.forEach(g=>letters.forEach(l=>ids.push(g+l))); ids.push('SM1','SM2');
  boxSel.innerHTML = ids.map(x=>`<option>${x}</option>`).join('');
})();

/* ===== Roster ===== */
function parseCSV(text){
  const rows=[]; let row=[], cur='', inQ=false; const push=()=>{row.push(cur);cur='';};
  for(let i=0;i<text.length;i++){
    const ch=text[i], nx=text[i+1];
    if(inQ){ if(ch==='"'&&nx==='"'){cur+='"';i++;} else if(ch==='"'){inQ=false;} else cur+=ch; }
    else{ if(ch==='"') inQ=true; else if(ch===',') push();
      else if(ch==='\n'||ch==='\r'){ if(ch==='\r'&&nx==='\n') i++; push(); rows.push(row); row=[]; }
      else cur+=ch; }
  } push(); if(row.length) rows.push(row);
  const header = rows.shift().map(h=>h.trim());
  return rows.filter(r=>r.some(x=>x&&x.trim()!=='')).map(r=>{const o={}; header.forEach((h,i)=>o[h]=r[i]||''); return o;});
}
async function loadRoster(){
  rosterStatus.textContent='Loading /data/roster.csvâ€¦';
  try{
    const res = await fetch('/data/roster.csv',{cache:'no-store'});
    if(res.ok){ roster=parseCSV(await res.text()); rosterStatus.textContent='Loaded /data/roster.csv âœ“'; return; }
  }catch{}
  rosterStatus.textContent='Could not load /data/roster.csv (upload below).';
}
loadRoster();
rosterFile.addEventListener('change', ()=>{
  const f=rosterFile.files[0]; if(!f) return;
  const r=new FileReader();
  r.onload=()=>{ roster=parseCSV(r.result||''); rosterStatus.textContent='Loaded from file âœ“'; };
  r.readAsText(f);
});
function namesForBox(boxId){
  const out={};
  for(const r of roster){
    const sec=(r['Security Number']||r['SecurityNumber']||'').toUpperCase().replace(/\s+/g,'');
    const m=sec.match(/^(SM\d|\d{1,2}[A-F])[- ]?(\d{1,2})$/);
    if(!m) continue; const box=m[1], slot=+m[2];
    if(box===boxId) out[slot]=r['Full Name']||r['FullName']||'';
  }
  return out;
}

/* ===== Image / layout ===== */
photo.addEventListener('change', e=>{
  const f=e.target.files[0]; if(!f) return;
  const url=URL.createObjectURL(f); const im=new Image();
  im.onload=()=>{ current={image:im,W:im.naturalWidth,H:im.naturalHeight}; img.src=url; img.style.display='block'; sizeStage(); draw(); setStatus('Photo loaded. Tap Auto Align.'); };
  im.onerror=()=>setStatus('Could not load image.'); im.src=url;
});
window.addEventListener('resize', sizeStage);
function sizeStage(){ if(!current) return; const W=stage.clientWidth, H=Math.max(240,Math.round(W*(current.H/current.W))); stage.style.height=H+'px'; overlay.width=W; overlay.height=H; }

/* ===== Buttons ===== */
autoBtn.addEventListener('click', async ()=>{
  if(!current) return alert('Upload a photo first.');
  analyzeBtn.disabled=true;
  setStatus('Detecting blue stripsâ€¦');
  rowBottoms = await detectBlueStrips(current.image, edgeCrop(), blueSens());
  if(rowBottoms.length!==5){ setStatus('Could not find 5 strips. Use Quick Tap Rows and tap each strip.'); draw(); return; }
  await buildWallsAndROIs();
});
tapRowsBtn.addEventListener('click', ()=>{ if(!current) return alert('Upload a photo first.'); quickTap=true; quickYs=[]; setStatus('Tap each blue number strip once (5 taps)â€¦'); });
resetRowsBtn.addEventListener('click', ()=>{ rowBottoms=[]; boundsByRow=[]; rois=[]; occMask=[]; draw(); setStatus('Reset.'); });

stage.addEventListener('pointerdown', async (e)=>{
  if(!quickTap||!current) return;
  const {iy}=screenToImage(e.clientX,e.clientY);
  quickYs.push(iy); drawTapLine(iy);
  if(quickYs.length===5){ quickTap=false; rowBottoms=quickYs.slice().sort((a,b)=>a-b); await buildWallsAndROIs(); }
});

analyzeBtn.addEventListener('click', ()=>{
  if(!rois.length) return alert('Align rows first.');
  occMask = rois.map(r => slotOccupied(cropROI(r)));
  paintOverlay();
  const names = namesForBox(boxSel.value||'');
  resultsBody.innerHTML='';
  for(let i=0;i<60;i++){
    const slot=i+1, expected=names[slot]||'';
    const status = occMask[i] ? (expected?'present':'unexpected phone') : (expected?'missing':'empty');
    const tr=document.createElement('tr');
    tr.className = status==='missing'?'missing':(status==='present'?'ok':'');
    tr.innerHTML=`<td>${slot}</td><td>${expected}</td><td><span class="pill">${status}</span></td>`;
    resultsBody.appendChild(tr);
  }
  // mini grid
  [...boxGrid.children].forEach((d,i)=>{ d.classList.remove('present','empty'); d.classList.add(occMask[i]?'present':'empty'); });
  setStatus('Colorized: green=phone, red=empty.');
});

/* ===== Core: build 60 slot ROIs from blue strips ===== */
async function buildWallsAndROIs(){
  boundsByRow=[]; rois=[];
  // 1) Find xL..xR (largest continuous blue region) per row; split into 12 equal slots; optional tick refine.
  for(const yBottom of rowBottoms){
    const {xL,xR} = await bandInterior(current.image, yBottom, edgeCrop(), blueSens());
    const walls = wallsEqualSplitWithTickNudge(current.image, yBottom, xL, xR);
    boundsByRow.push(walls);
  }
  // Sanity: guarantee 13 per row
  for(let r=0;r<boundsByRow.length;r++){
    if(!boundsByRow[r] || boundsByRow[r].length!==13){
      const {xL,xR} = await bandInterior(current.image, rowBottoms[r], edgeCrop(), blueSens());
      boundsByRow[r] = forceEqualWalls(xL,xR);
    }
  }
  // 2) Build ROIs above strip with height = 70% of gap to next strip (or avg gap for last row)
  const gaps=[]; for(let i=1;i<rowBottoms.length;i++) gaps.push(rowBottoms[i]-rowBottoms[i-1]);
  const avgGap = gaps.length?gaps.reduce((a,b)=>a+b,0)/gaps.length: Math.round(current.H/6);
  rois=[];
  for(let r=0;r<5;r++){
    const yB=rowBottoms[r];
    const gap = (r<4 ? rowBottoms[r+1]-rowBottoms[r] : avgGap);
    const h = Math.max(12, Math.round(gap*rowFrac()));
    const yT = Math.max(0, yB - h);
    const W = boundsByRow[r];
    for(let i=0;i<12;i++){
      const x0=W[i], x1=W[i+1];
      rois.push({x:x0, y:yT, w:Math.max(1,x1-x0), h:yB-yT, row:r, col:i});
    }
  }
  // Final guarantee: 60 rects
  if(rois.length!==60){ rois = []; for(let r=0;r<5;r++){ const W=boundsByRow[r]; if(!W) continue; const yB=rowBottoms[r]; const h=Math.max(12,Math.round((gaps[r]||avgGap)*rowFrac())); const yT=Math.max(0,yB-h); for(let i=0;i<12;i++){ const x0=W[i],x1=W[i+1]; rois.push({x:x0,y:yT,w:Math.max(1,x1-x0),h:yB-yT,row:r,col:i}); } } }
  draw(); analyzeBtn.disabled=false; setStatus('Aligned to numbers (12 equal slots per row). Tap â€œColorize + Compareâ€.');
}

/* ===== Vision: detect blue strips (row bottoms) ===== */
async function detectBlueStrips(imgEl, edge, sens){
  const W=imgEl.naturalWidth, H=imgEl.naturalHeight;
  const c=document.createElement('canvas'); c.width=W; c.height=H; const g=c.getContext('2d');
  g.drawImage(imgEl,0,0,W,H); const {data}=g.getImageData(0,0,W,H);

  const x0=Math.round(W*edge), x1=Math.round(W*(1-edge));
  const score=new Float32Array(H);
  for(let y=0;y<H;y++){
    let b=0,cnt=0;
    for(let x=x0;x<=x1;x+=2){
      const i=(y*W+x)*4, rr=data[i],gg=data[i+1],bb=data[i+2];
      const {h,s,v}=rgb2hsv(rr,gg,bb);
      if(h>190&&h<265&&s>(0.18+0.40*sens)&&v>(0.22+0.30*sens)) b++;
      cnt++;
    }
    score[y]=cnt?b/cnt:0;
  }
  const s2=smooth(score,8);
  const peaks = pickSpread(peaksAbove(s2,0.35),5,Math.round(H/7)).slice(0,5).sort((a,b)=>a-b);
  return peaks;
}

/* ===== Vision: find [xL,xR] (largest continuous blue) inside the numbers band ===== */
async function bandInterior(imgEl, yBottom, edge, sens){
  const W=imgEl.naturalWidth, H=imgEl.naturalHeight;
  const c=document.createElement('canvas'); c.width=W; c.height=H; const g=c.getContext('2d');
  g.drawImage(imgEl,0,0,W,H); const {data}=g.getImageData(0,0,W,H);

  const L=Math.round(W*edge), R=Math.round(W*(1-edge));
  const bandH=Math.max(8,Math.round(H*0.02));
  const y0=Math.min(H-2, yBottom+2), y1=Math.min(H-1, y0+bandH);

  const blue=new Float32Array(W).fill(0);
  for(let x=L;x<=R;x++){
    let cnt=0,b=0;
    for(let y=y0;y<=y1;y++){
      const i=(y*W+x)*4, rr=data[i],gg=data[i+1],bb=data[i+2];
      const {h,s,v}=rgb2hsv(rr,gg,bb);
      if(h>190&&h<265&&s>(0.18+0.30*sens)&&v>(0.22+0.20*sens)) b++;
      cnt++;
    }
    blue[x]=cnt?b/cnt:0;
  }
  const sb=smooth(blue,4);
  // Find longest contiguous region above threshold
  const thr = 0.33*Math.max(...sb);
  let bestLen=0,bxL=L,bxR=R, curL=null;
  for(let x=L;x<=R;x++){
    if(sb[x]>thr){ if(curL===null) curL=x; }
    else if(curL!==null){ const len=x-1-curL; if(len>bestLen){bestLen=len; bxL=curL; bxR=x-1;} curL=null; }
  }
  if(curL!==null){ const len=R-curL; if(len>bestLen){bestLen=len; bxL=curL; bxR=R;} }
  // small inward pad to avoid frame bleed
  const pad=Math.round((bxR-bxL)*0.01); bxL+=pad; bxR-=pad;
  if(bxR-bxL<60){ bxL=L; bxR=R; } // fallback
  return {xL:bxL, xR:bxR};
}

/* ===== Build 13 walls by equal split + small tick nudge ===== */
function forceEqualWalls(xL,xR){
  const per=(xR-xL)/12; const walls=[...Array(13)].map((_,k)=>Math.round(xL+k*per)); return walls;
}
function wallsEqualSplitWithTickNudge(imgEl, yBottom, xL, xR){
  const base = forceEqualWalls(xL,xR);
  // try nudging start within Â±20% of period to land on white tick lines inside the blue band
  const per=(xR-xL)/12;
  const bestStart = scoreTickStarts(imgEl, yBottom, xL, per);
  if(bestStart==null) return base;
  const walls=[...Array(13)].map((_,k)=>Math.round(bestStart+k*per));
  // strict check
  if(walls.length!==13 || walls[0]>=walls[12]) return base;
  for(let i=1;i<walls.length;i++){ if(walls[i]<=walls[i-1]) return base; }
  return walls;
}
function scoreTickStarts(imgEl, yBottom, xL, per){
  const W=imgEl.naturalWidth,H=imgEl.naturalHeight;
  const c=document.createElement('canvas'); c.width=W; c.height=H; const g=c.getContext('2d');
  g.drawImage(imgEl,0,0,W,H); const {data}=g.getImageData(0,0,W,H);
  const band=Math.max(8,Math.round(H*0.02));
  const y0=Math.min(H-2,yBottom+2), y1=Math.min(H-1,y0+band);
  const delta=per*0.20;
  let best=null, bestScore=-1;
  for(let s=xL-delta; s<=xL+delta; s+=Math.max(1, per/40)){
    let sum=0;
    for(let k=0;k<=12;k++){
      const x=Math.round(s+k*per); if(x<0||x>=W) continue;
      // whiteness (low S, high V) at this column within the blue band
      let sc=0,cnt=0;
      for(let y=y0;y<=y1;y++){
        const i=(y*W+x)*4, rr=data[i],gg=data[i+1],bb=data[i+2];
        const {s:sat,v}=rgb2hsv(rr,gg,bb);
        if(v>0.72 && sat<0.35) sc++;
        cnt++;
      }
      sum += cnt?sc/cnt:0;
    }
    if(sum>bestScore){ bestScore=sum; best=s; }
  }
  return best;
}

/* ===== Occupancy (simple, robust) ===== */
function cropROI(r){ const c=document.createElement('canvas'); c.width=r.w; c.height=r.h; c.getContext('2d').drawImage(current.image,r.x,r.y,r.w,r.h,0,0,r.w,r.h); return c; }
function slotOccupied(c){
  const k=c.getContext('2d');
  const cx=Math.round(c.width*0.18), cw=Math.round(c.width*0.64);
  const cy=Math.round(c.height*0.15), ch=Math.round(c.height*0.60);
  const {data}=k.getImageData(cx,cy,cw,ch);
  const cols=new Float32Array(cw).fill(0); const dark=130;
  for(let y=0;y<ch;y++){ for(let x=0;x<cw;x++){ const i=(y*cw+x)*4; const L=0.299*data[i]+0.587*data[i+1]+0.114*data[i+2]; if(L<dark) cols[x]++; } }
  for(let x=0;x<cw;x++) cols[x]/=ch;
  let best=0,run=0; for(let x=0;x<cw;x++){ if(cols[x]>0.45){ run++; best=Math.max(best,run);} else run=0; }
  return best>=Math.round(cw*0.22);
}

/* ===== Draw ===== */
function draw(){
  ctx.clearRect(0,0,overlay.width,overlay.height); if(!current) return;
  const sx=overlay.width/current.W, sy=overlay.height/current.H, a=guideAlpha();

  if(showGuidesEl.checked){
    // row bottoms
    ctx.strokeStyle=`rgba(50,208,255,${a})`; ctx.lineWidth=2;
    for(const y of rowBottoms){ ctx.beginPath(); ctx.moveTo(0,y*sy); ctx.lineTo(overlay.width,y*sy); ctx.stroke(); }
    // vertical walls
    ctx.strokeStyle=`rgba(255,255,255,${a})`; ctx.lineWidth=1.6;
    for(const walls of boundsByRow){ (walls||[]).forEach(x=>{ const xx=x*sx; ctx.beginPath(); ctx.moveTo(xx,0); ctx.lineTo(xx,overlay.height); ctx.stroke(); }); }
  }
  // slot rects
  if(rois.length){ ctx.strokeStyle='rgba(255,255,255,.95)'; ctx.lineWidth=2; for(const r of rois){ ctx.strokeRect(r.x*sx, r.y*sy, r.w*sx, r.h*sy); } }
}
function paintOverlay(){
  if(!rois.length) return;
  const sx=overlay.width/current.W, sy=overlay.height/current.H;
  ctx.clearRect(0,0,overlay.width,overlay.height);
  for(let i=0;i<rois.length;i++){
    const r=rois[i]; ctx.fillStyle = occMask[i] ? 'rgba(0,200,0,.35)' : 'rgba(255,0,0,.35)';
    ctx.fillRect(r.x*sx, r.y*sy, r.w*sx, r.h*sy);
  }
  if(showGuidesEl.checked){
    ctx.strokeStyle='rgba(255,255,255,.9)'; ctx.lineWidth=1.5;
    for(const r of rois){ ctx.strokeRect(r.x*sx, r.y*sy, r.w*sx, r.h*sy); }
  }
}

/* ===== Helpers ===== */
function rgb2hsv(r,g,b){ r/=255; g/=255; b/=255; const max=Math.max(r,g,b),min=Math.min(r,g,b),d=max-min; let h=0; if(d!==0){ if(max===r) h=((g-b)/d)%6; else if(max===g) h=(b-r)/d+2; else h=(r-g)/d+4; h*=60; if(h<0)h+=360; } const s=max===0?0:d/max, v=max; return {h,s,v}; }
function smooth(a,w){const o=new Float32Array(a.length); for(let i=0;i<a.length;i++){let s=0,c=0; for(let k=-w;k<=w;k++){const j=i+k; if(j<0||j>=a.length) continue; s+=a[j]; c++;} o[i]=s/c;} return o;}
function peaksAbove(series, frac){ const m=Math.max(...series); const out=[]; if(!m) return out; for(let y=1;y<series.length-1;y++){ if(series[y]>=frac*m && series[y]>=series[y-1] && series[y]>=series[y+1]) out.push(y);} return out; }
function pickSpread(peaks, need, minDist){ const out=[]; for(const p of peaks){ if(out.every(q=>Math.abs(q-p)>minDist)) out.push(p); if(out.length>=need) break; } return out.sort((a,b)=>a-b); }
function screenToImage(cx,cy){ const r=overlay.getBoundingClientRect(); const x=(cx-r.left)/r.width*current.W; const y=(cy-r.top)/r.height*current.H; return {ix:x, iy:y}; }
function drawTapLine(yImg){ const sy=overlay.height/current.H, y=yImg*sy; ctx.save(); ctx.strokeStyle='rgba(50,208,255,.9)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(overlay.width,y); ctx.stroke(); ctx.restore(); }

/* ===== Boot ===== */
(function initGrid(){ boxGrid.innerHTML=''; for(let r=0;r<5;r++){ for(let c=0;c<12;c++){ const d=document.createElement('div'); d.className='slot'; const s=document.createElement('span'); s.textContent=`#${r*12+c+1}`; d.appendChild(s); boxGrid.appendChild(d);} }})();
</script>
</body>
</html>
