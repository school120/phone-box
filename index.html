<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Phone Box Slot Overlay (Auto from Numbers)</title>
<script defer src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.3/dist/tesseract.min.js"></script>
<style>
  :root{--bg:#0b1020;--card:#11183a;--muted:#8ea0d0;--accent:#3ad0ff}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:#fff;font-family:system-ui,-apple-system,Segoe UI,Inter,Roboto,Ubuntu}
  header{padding:12px 16px;border-bottom:1px solid #ffffff1a;font-weight:800}
  main{max-width:1100px;margin:0 auto;padding:12px;display:grid;grid-template-columns:1fr 320px;gap:16px}
  #stage{position:relative;border:1px dashed #ffffff33;border-radius:12px;overflow:hidden;background:#0d1330}
  #img{width:100%;display:none}
  #overlay{position:absolute;inset:0;pointer-events:none}
  .card{background:var(--card);border:1px solid #ffffff14;border-radius:12px;padding:12px}
  label{display:block;margin:8px 0 4px;color:var(--muted);font-size:14px}
  input[type="file"],button,select{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #ffffff22;background:#0f1738;color:#fff}
  button.primary{background:linear-gradient(180deg,#39bdf2,#1aa1d9);border:none;font-weight:700}
  small{color:var(--muted)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  @media (max-width:900px){main{grid-template-columns:1fr}}
</style>
</head>
<body>
<header>ðŸ“± Phone Box Overlay (auto: find numbers â†’ draw 12Ã—5 slots)</header>

<main>
  <section class="card" id="left">
    <div id="stage">
      <img id="img" alt="preview">
      <canvas id="overlay"></canvas>
    </div>
  </section>

  <section class="card">
    <label>Upload a box photo</label>
    <input id="photo" type="file" accept="image/*" capture="environment">

    <div class="row" style="margin-top:10px">
      <div>
        <label>Row height % (above the blue number bar)</label>
        <input id="rowPct" type="range" min="40" max="100" step="5" value="70">
      </div>
      <div>
        <label>Edge crop % (ignore sides)</label>
        <input id="edgePct" type="range" min="0" max="12" step="1" value="4">
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="scan" class="primary">Scan & Overlay</button>
      <button id="clear">Clear</button>
    </div>

    <div style="margin-top:10px">
      <label><input type="checkbox" id="showGuides" checked> Show guides</label>
      <small id="status"></small>
    </div>

    <details style="margin-top:10px">
      <summary>What it does</summary>
      <small>
        1) Finds the 5 blue number bars.<br>
        2) OCR reads the printed numbers (1..60).<br>
        3) For each row, uses those number boxes to build 12 slots (13 vertical boundaries).<br>
        4) Draws rectangles just above each number.
      </small>
    </details>
  </section>
</main>

<script>
const img = document.getElementById('img');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');
const statusEl = document.getElementById('status');
const showGuides = document.getElementById('showGuides');
const rowPctEl = document.getElementById('rowPct');
const edgePctEl = document.getElementById('edgePct');
let worker = null;

let current = null;     // {image: HTMLImageElement, W, H}
let rowTops = [];       // [y] 5 items (bottom edge of each slot area = top of blue bar)
let boundsByRow = [];   // per row: [x0..x12] 13 entries
let rois = [];          // 60 rects to draw

function setStatus(t){ statusEl.textContent = t; }
function fitCanvas(){
  if(!current) return;
  const stage = document.getElementById('stage').getBoundingClientRect();
  overlay.width = stage.width;
  overlay.height = stage.width * (current.H / current.W);
  document.getElementById('left').style.aspectRatio = `${current.W}/${current.H}`;
  draw();
}
window.addEventListener('resize', fitCanvas);

document.getElementById('photo').addEventListener('change', (e)=>{
  const f = e.target.files[0]; if(!f) return;
  const url = URL.createObjectURL(f);
  const im = new Image();
  im.onload = () => {
    current = { image: im, W: im.naturalWidth, H: im.naturalHeight };
    img.src = url; img.style.display='block';
    fitCanvas();
    setStatus('Photo loaded. Tap â€œScan & Overlayâ€.');
  };
  im.src = url;
});

document.getElementById('clear').addEventListener('click', ()=>{
  rowTops=[]; boundsByRow=[]; rois=[]; ctx.clearRect(0,0,overlay.width,overlay.height); setStatus('');
});

document.getElementById('scan').addEventListener('click', async ()=>{
  if(!current){ alert('Upload a photo first.'); return; }
  setStatus('Scanningâ€¦');
  if(!worker){
    worker = await Tesseract.createWorker('eng', 1, {
      corePath: 'https://cdn.jsdelivr.net/npm/tesseract.js-core@5.0.3/tesseract-core.wasm.js',
      workerPath: 'https://cdn.jsdelivr.net/npm/tesseract.js@5.0.3/dist/worker.min.js'
    });
  }
  // 1) detect 5 blue bars
  rowTops = await findBlueBars(current.image, parseInt(edgePctEl.value,10)/100);
  if(rowTops.length!==5){ setStatus('Could not find 5 blue bars. Try a straighter photo or tweak edge crop %'); draw(); return; }

  // 2) per row: OCR numbers on the blue bar to place 12 slots
  boundsByRow = [];
  const gaps = []; for(let i=1;i<rowTops.length;i++) gaps.push(rowTops[i]-rowTops[i-1]);
  const avgGap = gaps.reduce((a,b)=>a+b,0)/gaps.length;
  const bandH = Math.max(20, Math.round(avgGap*0.30)); // tall enough to include the digits

  for(let r=0;r<5;r++){
    const y0 = Math.max(0, rowTops[r]-3);
    const y1 = Math.min(current.H-1, rowTops[r] + bandH);
    const crop = cropRectCanvas(current.image, 0, y0, current.W, y1-y0+1);
    const data = await worker.recognize(crop, {
      tessedit_char_whitelist:'0123456789',
      tessedit_pageseg_mode: '7'
    });
    const words = data.data.words || [];
    // numbers in this row (global 1..60)
    const rowStart = r*12 + 1, rowEnd = rowStart + 11;
    let nums = words
      .map(w => ({ txt: (w.text||'').replace(/\D/g,''), bbox: w.bbox }))
      .filter(w => w.txt.length>0)
      .map(w => ({ n: parseInt(w.txt,10), x: (w.bbox.x0 + w.bbox.x1)/2, L:w.bbox.x0, R:w.bbox.x1 }))
      .filter(o => o.n>=rowStart && o.n<=rowEnd)
      .sort((a,b)=>a.x-b.x);

    // if OCR missed some, try to coalesce/repair
    nums = dedupeByX(nums, 12); // remove near-duplicates
    // convert to 12 slot centers using known sequence
    const centers = new Array(12).fill(null);
    nums.forEach(o => { const idx = o.n - rowStart; if(idx>=0 && idx<12) centers[idx]=o.x; });
    // fill missing by interpolation
    let left=null,right=null;
    for(let i=0;i<12;i++){
      if(centers[i]==null){
        // find nearest known on left/right
        left = i-1; while(left>=0 && centers[left]==null) left--;
        right = i+1; while(right<12 && centers[right]==null) right++;
        if(left>=0 && right<12){
          const step = (centers[right]-centers[left])/(right-left);
          centers[i] = centers[left] + step*(i-left);
        }else if(left>=0){
          centers[i] = centers[left] + (centers[left]-centers[Math.max(0,left-1)]);
        }else if(right<12){
          centers[i] = centers[right] - (centers[Math.min(11,right+1)]-centers[right]);
        }else{
          // totally empty: fall back to equal spacing across image width (excluding edges a bit)
          centers[i] = (current.W*0.08) + (current.W*0.84) * (i/11);
        }
      }
    }
    // make 13 boundaries
    const bounds = [];
    const stepAvg = (centers[11]-centers[0])/11;
    bounds.push(Math.round(centers[0]-stepAvg/2));
    for(let i=0;i<11;i++) bounds.push(Math.round((centers[i]+centers[i+1])/2));
    bounds.push(Math.round(centers[11]+stepAvg/2));
    // clamp
    bounds[0]=Math.max(0,bounds[0]); bounds[12]=Math.min(current.W-1,bounds[12]);
    boundsByRow.push(bounds);
  }

  // 3) build rectangles above each blue bar using the bounds
  rois = [];
  const pct = parseInt(rowPctEl.value,10)/100;
  for(let r=0;r<5;r++){
    const yBottom = rowTops[r];
    const yTop = Math.max(0, Math.round(yBottom - avgGap*pct));
    const b = boundsByRow[r];
    for(let i=0;i<12;i++){
      const x0=b[i], x1=b[i+1];
      const inset = Math.round((x1-x0)*0.10);
      rois.push({ x:x0+inset, y:yTop, w:Math.max(1,(x1-x0-2*inset)), h:yBottom-yTop });
    }
  }

  setStatus('Overlay ready.');
  draw();
});

function draw(){
  ctx.clearRect(0,0,overlay.width,overlay.height);
  if(!current) return;
  const sx = overlay.width/current.W, sy = overlay.height/current.H;

  // guides
  if(showGuides.checked && rowTops.length){
    // cyan lines = blue bar tops
    ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--accent')||'#3ad0ff';
    ctx.lineWidth=2;
    for(const y of rowTops){
      ctx.beginPath(); ctx.moveTo(0, y*sy); ctx.lineTo(overlay.width, y*sy); ctx.stroke();
    }
    // white vertical bounds (13 per row)
    if(boundsByRow.length){
      ctx.strokeStyle='#fff'; ctx.lineWidth=1.5;
      boundsByRow.forEach((bounds,ri)=>{
        const y=rowTops[ri]*sy;
        bounds.forEach(x=>{
          const xx=x*sx; ctx.beginPath(); ctx.moveTo(xx, y-40); ctx.lineTo(xx, y+40); ctx.stroke();
        });
      });
    }
  }

  // rectangles
  if(rois.length){
    ctx.strokeStyle='rgba(255,255,255,.95)'; ctx.lineWidth=2;
    for(const r of rois){
      ctx.strokeRect(r.x*sx, r.y*sy, r.w*sx, r.h*sy);
    }
  }
}

/* --- helpers --- */

function cropRectCanvas(imgEl, x,y,w,h){
  const c=document.createElement('canvas'); c.width=w; c.height=h;
  c.getContext('2d').drawImage(imgEl, x,y,w,h, 0,0,w,h);
  return c;
}

function rgb2hsv(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b), d=max-min;
  let h=0; if(d!==0){ if(max===r) h=((g-b)/d)%6; else if(max===g) h=(b-r)/d+2; else h=(r-g)/d+4; h*=60; if(h<0) h+=360; }
  const s=max===0?0:d/max, v=max; return {h,s,v};
}

async function findBlueBars(imgEl, edgeCrop){
  // downscale for speed
  const maxW=1200;
  const r=Math.min(1, maxW/imgEl.naturalWidth);
  const W=Math.round(imgEl.naturalWidth*r), H=Math.round(imgEl.naturalHeight*r);
  const c=document.createElement('canvas'); c.width=W; c.height=H;
  const g=c.getContext('2d'); g.drawImage(imgEl,0,0,W,H);
  const {data}=g.getImageData(0,0,W,H);

  const hueMin=190, hueMax=265, sMin=0.30, vMin=0.22;
  const x0=Math.round(W*edgeCrop), x1=Math.round(W*(1-edgeCrop));
  const frac=new Float32Array(H);

  for(let y=0;y<H;y++){
    let cnt=0, blue=0;
    for(let x=x0;x<=x1;x+=2){
      const i=(y*W+x)*4; const {h,s,v}=rgb2hsv(data[i],data[i+1],data[i+2]);
      if((h>hueMin&&h<hueMax)&&s>=sMin&&v>=vMin) blue++; cnt++;
    }
    frac[y]=cnt?blue/cnt:0;
  }

  const smooth = (arr,w=6)=>{ const out=new Float32Array(arr.length); for(let i=0;i<arr.length;i++){ let s=0,cnt=0; for(let k=-w;k<=w;k++){ const j=i+k; if(j<0||j>=arr.length) continue; s+=arr[j]; cnt++; } out[i]=s/cnt; } return out; }
  const s = smooth(frac,6);

  // pick 5 best-separated peaks
  const peaks = pickPeaks(s,5,Math.round(H/8));
  const tops=[];
  const win=Math.round(H*0.035);
  for(const p of peaks){
    let maxv=0; for(let y=Math.max(0,p-win); y<=Math.min(H-1,p+win); y++) maxv=Math.max(maxv, s[y]);
    const T=maxv*0.5;
    let top=p; for(let y=p;y>=0;y--){ if(s[y]>=T) top=y; else break; }
    tops.push(top);
  }
  // scale back to full size
  return tops.sort((a,b)=>a-b).map(y=>Math.round(y/r));
}
function pickPeaks(series, need, minDist){
  const idx=[...series].map((v,i)=>[v,i]).sort((a,b)=>b[0]-a[0]); const out=[];
  for(const [,i] of idx){ if(out.every(j=>Math.abs(j-i)>minDist)) out.push(i); if(out.length>=need) break; }
  return out.sort((a,b)=>a-b);
}
function dedupeByX(arr, minGap=12){
  if(!arr.length) return arr;
  const out=[arr[0]];
  for(let i=1;i<arr.length;i++){
    if(Math.abs(arr[i].x-out[out.length-1].x) >= minGap) out.push(arr[i]);
  }
  return out;
}
</script>
</body>
</html>
