<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Phone Box Overlay + Roster Check (12×5)</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.3/dist/tesseract.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  :root{--bg:#0b1020;--card:#11183a;--muted:#8ea0d0;--accent:#3ad0ff}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:#fff;font-family:system-ui,-apple-system,Inter,Segoe UI,Roboto,Ubuntu}
  header{padding:12px 16px;border-bottom:1px solid #ffffff1a;font-weight:800}
  main{max-width:1100px;margin:0 auto;padding:12px;display:grid;grid-template-columns:1fr 360px;gap:16px}
  #stage{position:relative;border:1px dashed #ffffff33;border-radius:12px;overflow:hidden;background:#0d1330}
  #img{width:100%;display:none}
  #overlay{position:absolute;inset:0;pointer-events:none}
  .card{background:var(--card);border:1px solid #ffffff14;border-radius:12px;padding:12px}
  label{display:block;margin:8px 0 4px;color:var(--muted);font-size:14px}
  input[type="file"],button,select{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #ffffff22;background:#0f1738;color:#fff}
  button.primary{background:linear-gradient(180deg,#39bdf2,#1aa1d9);border:none;font-weight:700}
  small{color:var(--muted)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:6px;margin:10px 0}
  .slot{background:#0f1738;border:1px solid #ffffff26;aspect-ratio:3/5;border-radius:8px;position:relative}
  .slot span{position:absolute;inset:auto 6px 6px 6px;font-size:10px;color:#9bb0ff}
  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid #ffffff22;padding:8px 6px;text-align:left}
  tr.missing{background:#ff50501e}
  tr.ok{opacity:.8}
  .pill{display:inline-block;padding:.15rem .45rem;border-radius:999px;background:#ffffff22;font-size:12px}
  @media (max-width:900px){main{grid-template-columns:1fr}}
</style>
</head>
<body>
<header>📱 Phone Box Overlay + Roster (auto numbers → 12×5 slots)</header>

<main>
  <section class="card" id="left">
    <div id="stage">
      <img id="img" alt="preview">
      <canvas id="overlay"></canvas>
    </div>
    <div class="grid" id="boxGrid"></div>
    <table>
      <thead><tr><th>Slot</th><th>Expected</th><th>Status</th></tr></thead>
      <tbody id="results"></tbody>
    </table>
  </section>

  <section class="card">
    <label>Box</label>
    <select id="box"></select>

    <label style="margin-top:10px">Roster source</label>
    <select id="rosterSource">
      <option value="repo">Use ./data/roster.csv (repo)</option>
      <option value="upload">Upload CSV…</option>
    </select>
    <input id="rosterFile" type="file" accept=".csv" style="display:none;margin-top:6px"/>

    <label style="margin-top:10px">Upload a box photo</label>
    <input id="photo" type="file" accept="image/*" capture="environment">

    <div class="row" style="margin-top:10px">
      <div>
        <label>Row height % (above blue numbers)</label>
        <input id="rowPct" type="range" min="40" max="100" step="5" value="70">
      </div>
      <div>
        <label>Edge crop % (ignore sides)</label>
        <input id="edgePct" type="range" min="0" max="12" step="1" value="4">
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="scan" class="primary">Scan & Overlay</button>
      <button id="analyze" disabled>Analyze & Compare</button>
    </div>

    <div style="margin-top:10px">
      <label><input type="checkbox" id="showGuides" checked> Show guides</label>
      <small id="status"></small>
    </div>

    <details style="margin-top:10px">
      <summary>How it works</summary>
      <small>
        1) Finds the 5 blue number bars.<br>
        2) OCR reads the printed numbers (keeps 10/11/12 intact).<br>
        3) For each row, builds 12 slots → 60 total, rectangles drawn above numbers.<br>
        4) Compares to roster by Security Number (e.g., 9B11 → box 9B, slot 11).<br>
      </small>
    </details>
  </section>
</main>

<script>
/* ---------- UI refs ---------- */
const img = document.getElementById('img');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');
const statusEl = document.getElementById('status');
const showGuides = document.getElementById('showGuides');
const rowPctEl = document.getElementById('rowPct');
const edgePctEl = document.getElementById('edgePct');
const analyzeBtn = document.getElementById('analyze');
const scanBtn = document.getElementById('scan');
const rosterSource = document.getElementById('rosterSource');
const rosterFile = document.getElementById('rosterFile');
const boxSel = document.getElementById('box');
const resultsBody = document.getElementById('results');
const boxGrid = document.getElementById('boxGrid');

let worker = null;
let current = null;     // {image, W, H}
let rowTops = [];       // [y]×5 (blue bar top edges)
let boundsByRow = [];   // 5 rows × 13 vertical bounds
let rois = [];          // 60 rects
let roster = [];        // parsed CSV rows

/* ---------- Box list ---------- */
(function fillBoxes(){
  const ids=[], grades=['9','10','11','12'], letters=['A','B','C','D','E','F'];
  grades.forEach(g=>letters.forEach(l=>ids.push(g+l)));
  ids.push('SM1','SM2');
  boxSel.innerHTML = ids.map(x=>`<option>${x}</option>`).join('');
})();

/* ---------- Roster load ---------- */
rosterSource.addEventListener('change', ()=>{
  rosterFile.style.display = rosterSource.value==='upload' ? 'block' : 'none';
  if(rosterSource.value==='repo') loadRosterFromRepo();
});
rosterFile.addEventListener('change', ()=>{
  if(rosterFile.files[0]) loadRosterFromFile(rosterFile.files[0]);
});
async function loadRosterFromRepo(){
  Papa.parse('./data/roster.csv', {download:true, header:true, complete:(r)=>{ roster=r.data||[]; status('Roster loaded from repo.'); }});
}
function loadRosterFromFile(f){
  Papa.parse(f, {header:true, complete:(r)=>{ roster=r.data||[]; status('Roster loaded from file.'); }});
}
// try to auto-load repo roster on start
loadRosterFromRepo();

/* ---------- Photo ---------- */
document.getElementById('photo').addEventListener('change', (e)=>{
  const f = e.target.files[0]; if(!f) return;
  const url = URL.createObjectURL(f);
  const im = new Image();
  im.onload = () => {
    current = { image: im, W: im.naturalWidth, H: im.naturalHeight };
    img.src = url; img.style.display='block';
    fitCanvas();
    status('Photo loaded. Tap “Scan & Overlay”.');
  };
  im.src = url;
});

/* ---------- Canvas fit/draw ---------- */
function status(t){ statusEl.textContent = t; }
function fitCanvas(){
  if(!current) return;
  const stage = document.getElementById('stage').getBoundingClientRect();
  const W = stage.width;
  const H = W * (current.H / current.W);
  overlay.width = W; overlay.height = H;
  document.getElementById('left').style.aspectRatio = `${current.W}/${current.H}`;
  draw();
}
window.addEventListener('resize', fitCanvas);

function draw(){
  ctx.clearRect(0,0,overlay.width,overlay.height);
  if(!current) return;
  const sx = overlay.width/current.W, sy = overlay.height/current.H;

  // guides: cyan row tops + white vertical bounds
  if(showGuides.checked && rowTops.length){
    ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--accent')||'#3ad0ff';
    ctx.lineWidth=2;
    for(const y of rowTops){
      ctx.beginPath(); ctx.moveTo(0, y*sy); ctx.lineTo(overlay.width, y*sy); ctx.stroke();
    }
    if(boundsByRow.length){
      ctx.strokeStyle='#fff'; ctx.lineWidth=1.5;
      boundsByRow.forEach((bounds,ri)=>{
        const y=rowTops[ri]*sy;
        bounds.forEach(x=>{
          const xx=x*sx; ctx.beginPath(); ctx.moveTo(xx, y-40); ctx.lineTo(xx, y+40); ctx.stroke();
        });
      });
    }
  }
  // slot rectangles
  if(rois.length){
    ctx.strokeStyle='rgba(255,255,255,.95)'; ctx.lineWidth=2;
    for(const r of rois){ ctx.strokeRect(r.x*sx, r.y*sy, r.w*sx, r.h*sy); }
  }
}

/* ---------- Scan & Overlay ---------- */
scanBtn.addEventListener('click', async ()=>{
  if(!current){ alert('Upload a photo first.'); return; }
  status('Scanning...');
  if(!worker){
    worker = await Tesseract.createWorker('eng', 1, {
      corePath: 'https://cdn.jsdelivr.net/npm/tesseract.js-core@5.0.3/tesseract-core.wasm.js',
      workerPath: 'https://cdn.jsdelivr.net/npm/tesseract.js@5.0.3/dist/worker.min.js'
    });
  }
  // 1) detect the five blue number bars
  rowTops = await findBlueBars(current.image, parseInt(edgePctEl.value,10)/100);
  if(rowTops.length!==5){ status('Could not find 5 blue bars. Tweak edge crop or retake photo.'); draw(); return; }

  // 2) OCR digits along each bar to place 12 numbers → 13 bounds
  boundsByRow = [];
  const gaps = []; for(let i=1;i<rowTops.length;i++) gaps.push(rowTops[i]-rowTops[i-1]);
  const avgGap = gaps.reduce((a,b)=>a+b,0)/gaps.length;
  const bandH = Math.max(20, Math.round(avgGap*0.30));

  for(let r=0;r<5;r++){
    const y0 = Math.max(0, rowTops[r]-3);
    const y1 = Math.min(current.H-1, rowTops[r] + bandH);
    const crop = cropRectCanvas(current.image, 0, y0, current.W, y1-y0+1);
    const data = await worker.recognize(crop, {
      tessedit_char_whitelist:'0123456789',
      tessedit_pageseg_mode: '7' // line of text
    });
    const words = data.data.words || [];
    let nums = words
      .map(w => ({ txt:(w.text||'').replace(/\D/g,''), L:w.bbox.x0, R:w.bbox.x1 }))
      .filter(w => w.txt.length>0) // keep multi-digit intact (10/11/12)
      .map(w => ({ x:(w.L + w.R)/2, L:w.L, R:w.R }))
      .sort((a,b)=>a.x-b.x);

    // Remove near-duplicates & enforce ~12 centers
    nums = dedupeByX(nums, 14);
    let centers = nums.map(o=>o.x);
    if(centers.length<8 || centers.length>16){
      // fallback: split whole width into 12 if OCR is weak
      centers = Array.from({length:12}, (_,i)=> current.W*0.08 + (current.W*0.84)*(i/11));
    }else{
      centers = normalizeToTwelve(centers);
    }

    // Make 13 bounds from 12 centers
    const bounds = [];
    const stepAvg = (centers[11]-centers[0])/11;
    bounds.push(Math.round(centers[0]-stepAvg/2));
    for(let i=0;i<11;i++) bounds.push(Math.round((centers[i]+centers[i+1])/2));
    bounds.push(Math.round(centers[11]+stepAvg/2));
    bounds[0]=Math.max(0,bounds[0]); bounds[12]=Math.min(current.W-1,bounds[12]);
    boundsByRow.push(bounds);
  }

  // 3) Build rectangles above each row
  rois = [];
  const pct = parseInt(rowPctEl.value,10)/100;
  for(let r=0;r<5;r++){
    const yBottom = rowTops[r];
    const yTop = Math.max(0, Math.round(yBottom - avgGap*pct));
    const b = boundsByRow[r];
    for(let i=0;i<12;i++){
      const x0=b[i], x1=b[i+1];
      const inset = Math.round((x1-x0)*0.10);
      rois.push({ x:x0+inset, y:yTop, w:Math.max(1,(x1-x0-2*inset)), h:yBottom-yTop, row:r, col:i });
    }
  }

  analyzeBtn.disabled = false;
  draw();
  status('Overlay ready. Choose the box and click “Analyze & Compare”.');
});

/* ---------- Analyze & Compare to roster ---------- */
analyzeBtn.addEventListener('click', ()=>{
  if(!rois.length) return alert('Scan & Overlay first.');
  if(!boxSel.value) return alert('Choose a Box (e.g., 9B, 10C, SM1).');
  if(!roster || roster.length===0) return alert('Load the roster (repo CSV or upload).');

  const names = namesForBox(boxSel.value); // slot -> full name
  drawNamesGrid(names);

  // presence detection per ROI
  const rows=[];
  for(let i=0;i<rois.length;i++){
    const slot = i+1;
    const expected = names[slot] || '';
    const occ = slotOccupied(cropROI(rois[i]));
    const status = occ ? (expected?'present':'unexpected phone') : (expected?'missing':'empty');
    rows.push({slot, expected, status});
  }

  // render table
  resultsBody.innerHTML='';
  rows.forEach(r=>{
    const tr=document.createElement('tr');
    tr.className = r.status==='missing' ? 'missing' : (r.status==='present' ? 'ok' : '');
    tr.innerHTML=`<td>${r.slot}</td><td>${r.expected||''}</td><td><span class="pill">${r.status}</span></td>`;
    resultsBody.appendChild(tr);
  });

  status('Compared to roster: present/missing/unexpected listed below.');
});

/* ---------- Roster helpers ---------- */
function namesForBox(boxId){
  const out={};
  for(const row of roster){
    const sec = (row['Security Number']||row['SecurityNumber']||'').toString().toUpperCase().replace(/\s+/g,'');
    const m = sec.match(/^(SM\d|\d{1,2}[A-F])[- ]?(\d{1,2})$/);
    if(!m) continue;
    const box=m[1], slot=parseInt(m[2],10);
    if(box===boxId) out[slot] = row['Full Name']||row['FullName']||'';
  }
  return out;
}
function drawNamesGrid(namesBySlot={}){
  boxGrid.innerHTML='';
  for(let r=0;r<5;r++){
    for(let c=0;c<12;c++){
      const idx=r*12+c+1;
      const d=document.createElement('div'); d.className='slot';
      const s=document.createElement('span'); s.textContent=namesBySlot[idx]||`#${idx}`;
      d.appendChild(s); boxGrid.appendChild(d);
    }
  }
}

/* ---------- Image / color helpers ---------- */
function cropRectCanvas(imgEl, x,y,w,h){
  const c=document.createElement('canvas'); c.width=w; c.height=h;
  c.getContext('2d').drawImage(imgEl, x,y,w,h, 0,0,w,h);
  return c;
}
function rgb2hsv(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b), d=max-min;
  let h=0; if(d!==0){ if(max===r) h=((g-b)/d)%6; else if(max===g) h=(b-r)/d+2; else h=(r-g)/d+4; h*=60; if(h<0) h+=360; }
  const s=max===0?0:d/max, v=max; return {h,s,v};
}

/* Find 5 blue bars (top edges) */
async function findBlueBars(imgEl, edgeCrop){
  const maxW=1200;
  const r=Math.min(1, maxW/imgEl.naturalWidth);
  const W=Math.round(imgEl.naturalWidth*r), H=Math.round(imgEl.naturalHeight*r);
  const c=document.createElement('canvas'); c.width=W; c.height=H;
  const g=c.getContext('2d'); g.drawImage(imgEl,0,0,W,H);
  const {data}=g.getImageData(0,0,W,H);

  const hueMin=190, hueMax=265, sMin=0.30, vMin=0.22;
  const x0=Math.round(W*edgeCrop), x1=Math.round(W*(1-edgeCrop));
  const frac=new Float32Array(H);

  for(let y=0;y<H;y++){
    let cnt=0, blue=0;
    for(let x=x0;x<=x1;x+=2){
      const i=(y*W+x)*4; const {h,s,v}=rgb2hsv(data[i],data[i+1],data[i+2]);
      if((h>hueMin&&h<hueMax)&&s>=sMin&&v>=vMin) blue++; cnt++;
    }
    frac[y]=cnt?blue/cnt:0;
  }

  const smooth = (arr,w=6)=>{ const out=new Float32Array(arr.length); for(let i=0;i<arr.length;i++){ let s=0,cnt=0; for(let k=-w;k<=w;k++){ const j=i+k; if(j<0||j>=arr.length) continue; s+=arr[j]; cnt++; } out[i]=s/cnt; } return out; }
  const s = smooth(frac,6);

  // pick 5 well-separated peaks, then derive top edge
  const peaks = pickPeaks(s,5,Math.round(H/8));
  const tops=[];
  const win=Math.round(H*0.035);
  for(const p of peaks){
    let maxv=0; for(let y=Math.max(0,p-win); y<=Math.min(H-1,p+win); y++) maxv=Math.max(maxv, s[y]);
    const T=maxv*0.5;
    let top=p; for(let y=p;y>=0;y--){ if(s[y]>=T) top=y; else break; }
    tops.push(top);
  }
  // scale back to full size
  return tops.sort((a,b)=>a-b).map(y=>Math.round(y/r));
}
function pickPeaks(series, need, minDist){
  const idx=[...series].map((v,i)=>[v,i]).sort((a,b)=>b[0]-a[0]); const out=[];
  for(const [,i] of idx){ if(out.every(j=>Math.abs(j-i)>minDist)) out.push(i); if(out.length>=need) break; }
  return out.sort((a,b)=>a-b);
}

/* Keep clusters wide enough so 10/11/12 stay together; normalize to exactly 12 centers */
function dedupeByX(arr, minGap=14){
  if(!arr.length) return arr;
  const out=[arr[0]];
  for(let i=1;i<arr.length;i++){
    if(Math.abs(arr[i].x-out[out.length-1].x) >= minGap) out.push(arr[i]);
  }
  return out;
}
function normalizeToTwelve(centers){
  centers = centers.slice().sort((a,b)=>a-b);
  // Too many → merge closest pairs; too few → insert midpoints of widest gaps
  while(centers.length>12){
    let bi=0, best=1e9;
    for(let i=0;i<centers.length-1;i++){
      const gap=centers[i+1]-centers[i];
      if(gap<best){best=gap;bi=i;}
    }
    centers.splice(bi,2,(centers[bi]+centers[bi+1])/2);
  }
  while(centers.length<12){
    let bi=0, best=-1;
    for(let i=0;i<centers.length-1;i++){
      const gap=centers[i+1]-centers[i];
      if(gap>best){best=gap;bi=i;}
    }
    centers.splice(bi+1,0,(centers[bi]+centers[bi+1])/2);
  }
  return centers;
}

/* Build ROI canvas & detect presence (dark vertical band heuristic) */
function cropROI(r){
  const c=document.createElement('canvas'); c.width=r.w; c.height=r.h;
  c.getContext('2d').drawImage(current.image, r.x,r.y,r.w,r.h, 0,0,r.w,r.h);
  return c;
}
function slotOccupied(c){
  const ctx=c.getContext('2d');
  const cx=Math.round(c.width*0.20), cw=Math.round(c.width*0.60);
  const cy=Math.round(c.height*0.15), ch=Math.round(c.height*0.60);
  const {data}=ctx.getImageData(cx,cy,cw,ch);
  const cols=new Float32Array(cw).fill(0), dark=130;
  for(let y=0;y<ch;y++){
    for(let x=0;x<cw;x++){
      const i=(y*cw+x)*4;
      const L=0.299*data[i]+0.587*data[i+1]+0.114*data[i+2];
      if(L<dark) cols[x]++;
    }
  }
  for(let x=0;x<cw;x++) cols[x]/=ch;
  let best=0,run=0;
  for(let x=0;x<cw;x++){ if(cols[x]>0.5){ run++; best=Math.max(best,run);} else run=0; }
  return best>=Math.round(cw*0.25);
}
</script>
</body>
</html>
