<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Phone Box â€” Auto Rows + Foam Walls + Roster (12Ã—5)</title>
<style>
  :root{--bg:#0b1020;--card:#11183a;--muted:#9ab0e0;--accent:#32d0ff}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:#fff;font-family:system-ui,-apple-system,Inter,Roboto,Segoe UI}
  header{padding:14px 16px;border-bottom:1px solid #ffffff1a;font-weight:800}
  main{max-width:1200px;margin:0 auto;padding:12px;display:grid;grid-template-columns:1.1fr 0.9fr;gap:16px}
  .card{background:var(--card);border:1px solid #ffffff1a;border-radius:16px;padding:14px;box-shadow:0 10px 30px #0008}
  label{display:block;margin:10px 0 6px;color:var(--muted);font-size:14px}
  input[type="file"],select,button{width:100%;padding:14px 16px;border-radius:12px;border:1px solid #ffffff2b;background:#0f1738;color:#fff;font-size:16px}
  button.primary{background:linear-gradient(180deg,#3bc2f2,#1aa1d9);border:none;font-weight:800}
  small{color:var(--muted)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}

  /* Preview */
  #stage{position:relative;border:1px dashed #ffffff33;border-radius:12px;overflow:hidden;background:#0c1333;min-height:220px;touch-action:none}
  #img{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:none;z-index:0}
  #overlay{position:absolute;inset:0;pointer-events:none;z-index:1}

  .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:12px}
  .pill{display:inline-block;padding:.2rem .6rem;border-radius:999px;background:#ffffff24;font-size:12px}
  .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:6px;margin:10px 0}
  .slot{background:#0f1738;border:1px solid #ffffff24;aspect-ratio:3/5;border-radius:8px;position:relative}
  .slot span{position:absolute;inset:auto 6px 6px 6px;font-size:12px;color:#9ab0ff}
  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid #ffffff1f;padding:10px 6px;text-align:left}
  tr.missing{background:#ff50501a}
  tr.ok{opacity:.9}
  @media (max-width: 900px){
    main{grid-template-columns:1fr}
    header{font-size:18px}
    .row{grid-template-columns:1fr}
  }
</style>
</head>
<body>
<header>ðŸ“± Phone Box â€” Auto Rows + Foam Walls + Roster (12Ã—5)</header>

<main>
  <section class="card" id="left">
    <div id="stage">
      <img id="img" alt="preview">
      <canvas id="overlay"></canvas>
    </div>

    <div class="grid" id="boxGrid"></div>
    <table>
      <thead><tr><th>Slot</th><th>Expected</th><th>Status</th></tr></thead>
      <tbody id="results"></tbody>
    </table>
  </section>

  <section class="card">
    <label>Box</label>
    <select id="box"></select>

    <label style="margin-top:10px">Roster CSV (auto-loads /data/roster.csv)</label>
    <div class="row" style="align-items:end">
      <small id="rosterStatus">Loadingâ€¦</small>
      <input id="rosterFile" type="file" accept=".csv">
    </div>

    <label style="margin-top:10px">Upload a box photo</label>
    <input id="photo" type="file" accept="image/*" capture="environment">

    <div class="row" style="margin-top:10px">
      <div>
        <label>Row height % (above numbers)</label>
        <input id="rowPct" type="range" min="45" max="95" step="5" value="70">
      </div>
      <div>
        <label>Edge crop % (ignore sides)</label>
        <input id="edgePct" type="range" min="0" max="15" step="1" value="5">
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <div>
        <label>Foam scan height %</label>
        <input id="foamPct" type="range" min="12" max="35" step="1" value="22">
      </div>
      <div>
        <label>Blue sensitivity</label>
        <input id="blueSens" type="range" min="10" max="90" step="5" value="35">
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <div>
        <label>Side gap (slot widths)</label>
        <input id="sideGap" type="range" min="0.8" max="1.6" step="0.05" value="1.1">
      </div>
      <div>
        <label>Guide opacity</label>
        <input id="guideAlpha" type="range" min="20" max="100" step="5" value="90">
      </div>
    </div>

    <div class="toolbar">
      <button id="auto" class="primary">Auto Align</button>
      <button id="analyze" disabled>Analyze & Compare</button>
      <label><input id="showGuides" type="checkbox" checked> Show guides</label>
      <span id="status" class="pill"></span>
    </div>
  </section>
</main>

<script>
/* ===== Elements & State ===== */
const img = document.getElementById('img');
const stage = document.getElementById('stage');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');

const boxSel = document.getElementById('box');
const rosterFile = document.getElementById('rosterFile');
const rosterStatus = document.getElementById('rosterStatus');
const resultsBody = document.getElementById('results');
const boxGrid = document.getElementById('boxGrid');
const statusEl = document.getElementById('status');

const photo = document.getElementById('photo');
const autoBtn = document.getElementById('auto');
const analyzeBtn = document.getElementById('analyze');
const showGuidesEl = document.getElementById('showGuides');

const rowPctEl = document.getElementById('rowPct');
const edgePctEl = document.getElementById('edgePct');
const foamPctEl = document.getElementById('foamPct');
const blueSensEl = document.getElementById('blueSens');
const sideGapEl = document.getElementById('sideGap');
const guideAlphaEl = document.getElementById('guideAlpha');

function rowHeight(){ return +rowPctEl.value/100; }
function edgeCrop(){ return +edgePctEl.value/100; }
function foamHeight(){ return +foamPctEl.value/100; }
function blueSens(){ return +blueSensEl.value/100; }
function sideGapSlots(){ return +sideGapEl.value; }
function guideAlpha(){ return +guideAlphaEl.value/100; }
function setStatus(t){ statusEl.textContent=t||''; }

let current=null;         // {image, W, H}
let roster=[];            // [{...}]
let rowTops=[];           // 5 y positions (top edge of blue number strip)
let boundsByRow=[];       // per row: 13 x-positions (foam walls)
let rois=[];              // 60 rects

/* ===== Boxes ===== */
(function fillBoxes(){
  const ids=[], grades=['9','10','11','12'], letters=['A','B','C','D','E','F'];
  grades.forEach(g=>letters.forEach(l=>ids.push(g+l)));
  ids.push('SM1','SM2');
  boxSel.innerHTML = ids.map(x=>`<option>${x}</option>`).join('');
})();

/* ===== CSV (tiny parser) ===== */
function parseCSV(text){
  const rows=[]; let row=[], cur='', inQ=false; const push=()=>{row.push(cur);cur='';};
  for(let i=0;i<text.length;i++){
    const ch=text[i], nx=text[i+1];
    if(inQ){ if(ch==='"'&&nx==='"'){cur+='"';i++;} else if(ch==='"'){inQ=false;} else cur+=ch; }
    else{ if(ch==='"') inQ=true; else if(ch===',') push();
      else if(ch==='\n'||ch==='\r'){ if(ch==='\r'&&nx==='\n') i++; push(); rows.push(row); row=[]; }
      else cur+=ch; }
  } push(); if(row.length) rows.push(row);
  const header = rows.shift().map(h=>h.trim());
  return rows.filter(r=>r.some(x=>x&&x.trim()!=='')).map(r=>{const o={}; header.forEach((h,i)=>o[h]=r[i]||''); return o;});
}
function loadRosterFromRepo(){
  rosterStatus.textContent='Loading /data/roster.csvâ€¦';
  // try relative first, then absolute root
  const tryPaths = ['./data/roster.csv','/data/roster.csv'];
  (async ()=>{
    for(const p of tryPaths){
      try{
        const res = await fetch(p, {cache:'no-store'});
        if(res.ok){
          const txt = await res.text();
          roster = parseCSV(txt);
          rosterStatus.textContent='Loaded /data/roster.csv âœ“';
          return;
        }
      }catch(_){}
    }
    rosterStatus.textContent='Could not load /data/roster.csv (you can upload below).';
  })();
}
loadRosterFromRepo();
rosterFile.addEventListener('change', ()=>{
  const f=rosterFile.files[0]; if(!f) return;
  const r=new FileReader();
  r.onload=()=>{ roster=parseCSV(r.result||''); rosterStatus.textContent='Loaded from file âœ“'; };
  r.readAsText(f);
});

function namesForBox(boxId){
  const out={};
  for(const row of roster){
    const sec=(row['Security Number']||row['SecurityNumber']||'').toString().toUpperCase().replace(/\s+/g,'');
    const m=sec.match(/^(SM\d|\d{1,2}[A-F])[- ]?(\d{1,2})$/); if(!m) continue;
    const box=m[1], slot=parseInt(m[2],10); if(box===boxId) out[slot]=row['Full Name']||row['FullName']||'';
  } return out;
}
function drawNamesGrid(namesBySlot={}){
  boxGrid.innerHTML=''; for(let r=0;r<5;r++){ for(let c=0;c<12;c++){ const idx=r*12+c+1;
    const d=document.createElement('div'); d.className='slot';
    const s=document.createElement('span'); s.textContent=namesBySlot[idx]||`#${idx}`; d.appendChild(s); boxGrid.appendChild(d);
  }}
}

/* ===== Photo preview ===== */
photo.addEventListener('change', e=>{
  const f=e.target.files[0]; if(!f) return;
  const url=URL.createObjectURL(f); const im=new Image();
  im.onload=()=>{ current={image:im,W:im.naturalWidth,H:im.naturalHeight}; img.src=url; img.style.display='block'; sizeStage(); draw(); setStatus('Photo loaded. Tap â€œAuto Alignâ€.'); };
  im.onerror=()=>setStatus('Could not load image.'); im.src=url;
});
window.addEventListener('resize', sizeStage);
function sizeStage(){ if(!current) return; const W=stage.clientWidth; const H=Math.max(220,Math.round(W*(current.H/current.W))); stage.style.height=H+'px'; overlay.width=W; overlay.height=H; }

/* ===== Auto align ===== */
autoBtn.addEventListener('click', async ()=>{
  if(!current){ alert('Upload a photo first.'); return; }
  setStatus('Detecting number stripsâ€¦');

  rowTops = await findNumberRowsRobust(current.image, edgeCrop(), blueSens());
  if(rowTops.length!==5){
    setStatus('Could not find 5 number strips. Try raising Blue sensitivity and/or Edge crop %.');
    draw(); return;
  }

  setStatus('Locking to foam wallsâ€¦');
  boundsByRow=[]; const gaps=[]; for(let i=1;i<rowTops.length;i++) gaps.push(rowTops[i]-rowTops[i-1]);
  const avgGap=gaps.reduce((a,b)=>a+b,0)/gaps.length;

  for(const yBottom of rowTops){
    const bounds = await wallsFromFoam(current.image, yBottom, avgGap, edgeCrop(), foamHeight(), sideGapSlots());
    boundsByRow.push(bounds);
  }

  // Build ROIs (above each blue strip)
  rois=[];
  for(let r=0;r<5;r++){
    const yBottom=rowTops[r];
    const yTop=Math.max(0, Math.round(yBottom-avgGap*rowHeight()));
    const b=boundsByRow[r];
    for(let i=0;i<12;i++){ const x0=b[i], x1=b[i+1]; rois.push({x:x0,y:yTop,w:Math.max(1,(x1-x0)),h:yBottom-yTop,row:r,col:i}); }
  }
  draw(); analyzeBtn.disabled=false; setStatus('Aligned. Tap â€œAnalyze & Compareâ€.');
});

/* ===== Analyze ===== */
analyzeBtn.addEventListener('click', ()=>{
  if(!rois.length) return alert('Auto Align first.');
  if(!boxSel.value) return alert('Choose a Box (e.g., 9B, 10C, SM1).');
  if(!roster || roster.length===0) return alert('Load the roster CSV.');

  const names=namesForBox(boxSel.value); drawNamesGrid(names);
  const rows=[];
  for(let i=0;i<rois.length;i++){
    const slot=i+1, expected=names[slot]||''; const occ = slotOccupied(cropROI(rois[i]));
    const status = occ ? (expected?'present':'unexpected phone') : (expected?'missing':'empty');
    rows.push({slot,expected,status});
  }
  resultsBody.innerHTML=''; rows.forEach(r=>{ const tr=document.createElement('tr'); tr.className = r.status==='missing'?'missing':(r.status==='present'?'ok':''); tr.innerHTML=`<td>${r.slot}</td><td>${r.expected||''}</td><td><span class="pill">${r.status}</span></td>`; resultsBody.appendChild(tr); });
  setStatus('Compared to roster.');
});

/* ===== Draw ===== */
function draw(){
  ctx.clearRect(0,0,overlay.width,overlay.height); if(!current) return;
  const sx=overlay.width/current.W, sy=overlay.height/current.H, a=guideAlpha();

  if(showGuidesEl.checked){
    // cyan rows
    ctx.strokeStyle=`rgba(50,208,255,${a})`; ctx.lineWidth=2;
    for(const y of rowTops){ ctx.beginPath(); ctx.moveTo(0,y*sy); ctx.lineTo(overlay.width,y*sy); ctx.stroke(); }
    // white foam walls
    ctx.strokeStyle=`rgba(255,255,255,${a})`; ctx.lineWidth=1.6;
    for(let r=0;r<boundsByRow.length;r++){ const y=rowTops[r]*sy; (boundsByRow[r]||[]).forEach(x=>{ const xx=x*sx; ctx.beginPath(); ctx.moveTo(xx,y-40); ctx.lineTo(xx,y+40); ctx.stroke(); }); }
  }
  // slot rectangles
  if(rois.length){ ctx.strokeStyle='rgba(255,255,255,.95)'; ctx.lineWidth=2; for(const r of rois){ ctx.strokeRect(r.x*sx, r.y*sy, r.w*sx, r.h*sy);} }
}

/* ===== Vision core ===== */
/* Robust: find 5 rows that are blue AND contain white digits; adapt thresholds */
async function findNumberRowsRobust(imgEl, edge, sens){
  const maxW=1400, r=Math.min(1,maxW/imgEl.naturalWidth);
  const W=Math.round(imgEl.naturalWidth*r), H=Math.round(imgEl.naturalHeight*r);
  const c=document.createElement('canvas'); c.width=W; c.height=H; const g=c.getContext('2d'); g.drawImage(imgEl,0,0,W,H);
  const im=g.getImageData(0,0,W,H), data=im.data;

  const x0=Math.round(W*edge), x1=Math.round(W*(1-edge));
  // iterate with relaxed thresholds if needed
  const passes=[
    {sMin:0.30, vMin:0.28 + sens*0.30, whiteV:0.80, whiteS:0.28},
    {sMin:0.25, vMin:0.22 + sens*0.20, whiteV:0.75, whiteS:0.32},
    {sMin:0.20, vMin:0.18 + sens*0.10, whiteV:0.70, whiteS:0.35}
  ];
  for(const P of passes){
    const hueMin=190, hueMax=265;
    const blueFrac=new Float32Array(H), whiteOnBlue=new Float32Array(H);
    const top= Math.round(H*0.04), bottom=Math.round(H*0.96); // ignore outer 4%

    for(let y=top;y<bottom;y++){
      let cnt=0, blue=0, white=0;
      for(let x=x0;x<=x1;x+=2){
        const i=(y*W+x)*4; const rr=data[i], gg=data[i+1], bb=data[i+2];
        const {h,s,v}=rgb2hsv(rr,gg,bb);
        const isBlue=(h>hueMin&&h<hueMax)&&s>=P.sMin&&v>=P.vMin;
        if(isBlue){
          blue++;
          if(s<=P.whiteS && v>=P.whiteV) white++; // bright, low-sat digits ON blue
        }
        cnt++;
      }
      blueFrac[y]=cnt?blue/cnt:0;
      whiteOnBlue[y]=cnt?white/cnt:0;
    }
    const sb = smooth(blueFrac,7);
    const sw = smooth(whiteOnBlue,7);

    // combined score: blue * (normalized white)
    const maxWht = Math.max(...sw); const score=new Float32Array(H);
    for(let y=0;y<H;y++){ score[y] = sb[y] * (maxWht? (sw[y]/maxWht) : 0); }

    // auto threshold + non-max suppression
    const m = Math.max(...score);
    if(!m || m<1e-6) continue;
    const rawPeaks = [];
    for(let y=top+2;y<bottom-2;y++){
      if(score[y]>0.35*m && score[y]>score[y-1] && score[y]>=score[y+1]) rawPeaks.push(y);
    }
    // prefer 5 roughly spaced
    const rows = pickSpread(rawPeaks, 5, Math.round(H/7));
    if(rows.length>=5){
      // refine each to the top edge of the blue band
      const refined = rows.slice(0,5).sort((a,b)=>a-b).map(p=>{
        // follow upward until score drops to 50% of local max
        const win=8; let M=0; for(let y=Math.max(0,p-win); y<=Math.min(H-1,p+win); y++) M=Math.max(M, sb[y]);
        const T=M*0.5; let topy=p; for(let y=p;y>=0;y--){ if(sb[y]>=T) topy=y; else break; }
        return Math.round(topy/r);
      });
      return refined;
    }
  }
  return [];
}
function pickSpread(peaks, need, minDist){
  const out=[];
  for(const p of peaks){
    if(out.every(q=>Math.abs(q-p)>minDist)) out.push(p);
    if(out.length>=need) break;
  }
  // If still short, greedily add remaining farthest
  while(out.length<need && peaks.length){
    let best=null, bestd=-1;
    for(const p of peaks){
      const d = out.length? Math.min(...out.map(q=>Math.abs(q-p))) : 1e9;
      if(d>bestd){bestd=d; best=p;}
    }
    if(best!=null){ out.push(best); peaks.splice(peaks.indexOf(best),1); }
    else break;
  }
  return out.sort((a,b)=>a-b).slice(0,need);
}

/* Foam walls with period + side-gap control */
async function wallsFromFoam(imgEl, yBottom, avgGap, edge, foamFrac, sideGapW){
  const maxW=1400, r=Math.min(1,maxW/imgEl.naturalWidth);
  const W=Math.round(imgEl.naturalWidth*r), H=Math.round(imgEl.naturalHeight*r);
  const c=document.createElement('canvas'); c.width=W; c.height=H; const g=c.getContext('2d'); g.drawImage(imgEl,0,0,W,H);
  const im=g.getImageData(0,0,W,H);

  const bandH=Math.max(8,Math.round((avgGap*r)*foamFrac));
  const y0=Math.max(0, Math.round((yBottom*r)-bandH-4)), y1=Math.min(H-1, Math.round((yBottom*r)-2));
  const L=Math.round(W*edge), R=Math.round(W*(1-edge));

  // brightness & gradient per column inside foam band
  const bright=new Float32Array(W).fill(0), grad=new Float32Array(W).fill(0);
  for(let x=L;x<=R;x++){
    let s=0; for(let y=y0;y<=y1;y++){ const i=(y*W+x)*4; s += 0.299*im.data[i]+0.587*im.data[i+1]+0.114*im.data[i+2]; }
    bright[x]=s/(y1-y0+1);
  }
  for(let x=L+1;x<=R-1;x++){ grad[x]=Math.abs(bright[x+1]-bright[x-1]); }
  const signal=smooth(grad,8);

  const width=R-L, guess=width/13;
  const period = findPeriod(signal, L, R, Math.round(guess*0.8), Math.round(guess*1.3));

  // first wall offset using side gap in slot widths
  const start0 = L + sideGapW*period;

  // refine start by maximizing energy at k*period
  let bestS=start0, bestScore=-1;
  const search=Math.round(period*0.4);
  for(let s=Math.max(L,start0-search); s<=Math.min(R,start0+search); s++){
    let sc=0;
    for(let k=0;k<13;k++){
      const x=Math.round(s + k*period);
      if(x<L||x>R) continue;
      let loc=signal[x]; if(x-2>=L) loc=Math.max(loc,signal[x-1],signal[x-2]);
      if(x+2<=R) loc=Math.max(loc,signal[x+1],signal[x+2]);
      sc+=loc;
    }
    if(sc>bestScore){ bestScore=sc; bestS=s; }
  }

  // build 13 walls and clamp
  let walls=[]; for(let k=0;k<13;k++){ walls.push(clamp(Math.round(bestS + k*period), L, R)); }
  for(let i=1;i<walls.length;i++){ if(walls[i]<=walls[i-1]) walls[i]=walls[i-1]+1; }

  const scaleX = imgEl.naturalWidth/W;
  return walls.map(x=>Math.round(x*scaleX));
}

/* Presence detection */
function cropROI(r){
  const c=document.createElement('canvas'); c.width=r.w; c.height=r.h;
  c.getContext('2d').drawImage(current.image, r.x,r.y,r.w,r.h, 0,0,r.w,r.h);
  return c;
}
function slotOccupied(c){
  const k=c.getContext('2d');
  const cx=Math.round(c.width*0.18), cw=Math.round(c.width*0.64);
  const cy=Math.round(c.height*0.15), ch=Math.round(c.height*0.60);
  const {data}=k.getImageData(cx,cy,cw,ch);
  const cols=new Float32Array(cw).fill(0); const dark=130;
  for(let y=0;y<ch;y++){ for(let x=0;x<cw;x++){ const i=(y*cw+x)*4; const L=0.299*data[i]+0.587*data[i+1]+0.114*data[i+2]; if(L<dark) cols[x]++; } }
  for(let x=0;x<cw;x++) cols[x]/=ch;
  let best=0,run=0; for(let x=0;x<cw;x++){ if(cols[x]>0.45){ run++; best=Math.max(best,run);} else run=0; }
  return best>=Math.round(cw*0.22);
}

/* ===== Helpers ===== */
function rgb2hsv(r,g,b){ r/=255; g/=255; b/=255; const max=Math.max(r,g,b),min=Math.min(r,g,b),d=max-min; let h=0; if(d!==0){ if(max===r) h=((g-b)/d)%6; else if(max===g) h=(b-r)/d+2; else h=(r-g)/d+4; h*=60; if(h<0)h+=360; } const s=max===0?0:d/max, v=max; return {h,s,v}; }
function smooth(a,w){const o=new Float32Array(a.length); for(let i=0;i<a.length;i++){let s=0,c=0; for(let k=-w;k<=w;k++){const j=i+k; if(j<0||j>=a.length) continue; s+=a[j]; c++;} o[i]=s/c;} return o;}
function clamp(v,min,max){ return Math.max(min,Math.min(max,v)); }
function avg(a,s,e){ let sum=0,c=0; for(let i=s;i<=e;i++){sum+=a[i];c++;} return c?sum/c:0; }
function findPeriod(sig,L,R,lagMin,lagMax){
  let bestLag=lagMin, best=-1;
  for(let lag=lagMin; lag<=lagMax; lag++){
    let sum=0; for(let x=L; x+lag<=R; x++) sum += sig[x]*sig[x+lag];
    if(sum>best){ best=sum; bestLag=lag; }
  }
  return Math.max(10,bestLag);
}

/* ===== Boot ===== */
(function drawNamesGridEmpty(){ boxGrid.innerHTML=''; for(let r=0;r<5;r++){ for(let c=0;c<12;c++){ const d=document.createElement('div'); d.className='slot'; const s=document.createElement('span'); s.textContent=`#${r*12+c+1}`; d.appendChild(s); boxGrid.appendChild(d);} }})();
</script>
</body>
</html>
