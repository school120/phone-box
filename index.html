<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Phone Box Attendance</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <script defer src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.3/dist/tesseract.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.1"></script>
  <style>
    :root { --bg:#0b1020; --card:#121833; --muted:#8ea0d0; --accent:#6cc; }
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu;background:var(--bg);color:#fff}
    header{padding:20px 16px;border-bottom:1px solid rgba(255,255,255,.1);display:flex;align-items:center;gap:12px}
    .badge{background:rgba(255,255,255,.1);padding:4px 8px;border-radius:999px;font-size:12px}
    main{max-width:1100px;margin:0 auto;padding:16px;}
    .wrap{display:grid;grid-template-columns:1.1fr .9fr;gap:16px}
    .card{background:var(--card);border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    h2{margin:0 0 12px;font-weight:800}
    label{display:block;margin:.5rem 0 .35rem;color:var(--muted);font-size:14px}
    select,input[type="file"],button{width:100%;padding:10px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:#0e1533;color:#fff}
    button.primary{background:linear-gradient(180deg,#39bdf2,#1aa1d9);border:none;font-weight:700}
    small{color:var(--muted)}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    #preview{width:100%;aspect-ratio:3/4;background:#0d1330;border-radius:12px;display:flex;align-items:center;justify-content:center;border:1px dashed rgba(255,255,255,.18);overflow:hidden}
    #preview>video,#preview>img{width:100%;height:100%;object-fit:cover}
    table{width:100%;border-collapse:collapse}
    th,td{border-bottom:1px solid rgba(255,255,255,.08);padding:8px 6px;text-align:left}
    tr.mismatch{background:rgba(255,80,80,.12)}
    tr.ok{opacity:.6}
    .pill{display:inline-block;padding:.15rem .45rem;border-radius:999px;background:rgba(255,255,255,.12);font-size:12px}
    .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:6px}
    .slot{background:#0f1738;border:1px solid rgba(255,255,255,.08);aspect-ratio:3/5;border-radius:8px;position:relative}
    .slot span{position:absolute;inset:auto 6px 6px 6px;font-size:10px;color:var(--muted)}
  </style>
</head>
<body>
  <header>
    <div style="font-weight:800">ðŸ“± Phone Box Attendance</div>
    <div class="badge">MVP â€“ clientâ€‘only</div>
  </header>
  <main>
    <div class="wrap">
      <section class="card">
        <h2>Scan a Box</h2>
        <div class="row">
          <div>
            <label>Choose box</label>
            <select id="boxSelect">
              <option value="">Autoâ€‘detect from labels (OCR)</option>
              <optgroup label="Grade Boxes">
                <!-- 9â€“12, Aâ€“F -->
              </optgroup>
              <optgroup label="Special">
                <option>SM1</option>
                <option>SM2</option>
              </optgroup>
            </select>
          </div>
          <div>
            <label>Roster CSV</label>
            <select id="rosterChoice">
              <option value="./data/roster.csv">Use repo roster (./data/roster.csv)</option>
              <option value="upload">Upload a different CSVâ€¦</option>
            </select>
            <input id="rosterUpload" type="file" accept=".csv" style="display:none;margin-top:6px" />
          </div>
        </div>
        <div class="row" style="margin-top:10px">
          <div>
            <label>Take/Upload a photo</label>
            <input id="photo" type="file" accept="image/*" capture="environment" />
          </div>
          <div>
            <label>Calibration</label>
            <div style="display:flex; gap:8px; flex-wrap:wrap">
              <button id="calibrateBtn">Manual 12Ã—5 grid (fallback)</button>
              <button id="autoBlueBtn" class="primary">Autoâ€‘calibrate (align to blue labels)</button>
            </div>
            <small>Autoâ€‘calibration anchors the grid to the blue number strip and detects vertical channels.</small>
          </div>
        </div>
        <div id="preview" style="margin-top:12px"><small>Photo preview appears here</small></div>
        <div style="display:flex;gap:10px;margin-top:12px">
          <button class="primary" id="analyzeBtn">Analyze Attendance</button>
          <button id="saveEmbeddingBtn">Save Current Embeddings â†’ Roster</button>
        </div>
        <small id="status"></small>
      </section>
      <section class="card">
        <h2>Results</h2>
        <div id="boxGrid" class="grid" style="margin-bottom:10px"></div>
        <table>
          <thead>
            <tr><th>Slot</th><th>Expected</th><th>Detected</th><th>Status</th></tr>
          </thead>
          <tbody id="resultsBody"></tbody>
        </table>
      </section>
    </div>
  </main>
<script>
// --- Utility: box ids and positions ---
const BOX_IDS = [];
['9','10','11','12'].forEach(grade=>{
  ['A','B','C','D','E','F'].forEach(letter=>BOX_IDS.push(`${grade}${letter}`));
});
const boxOptGroup = document.querySelector('optgroup[label="Grade Boxes"]');
BOX_IDS.forEach(id=>{ const o=document.createElement('option'); o.value=id; o.textContent=id; boxOptGroup.appendChild(o); });

// UI refs
const photoInput = document.getElementById('photo');
const preview = document.getElementById('preview');
const statusEl = document.getElementById('status');
const resultsBody = document.getElementById('resultsBody');
const rosterChoice = document.getElementById('rosterChoice');
const rosterUpload = document.getElementById('rosterUpload');
const boxGrid = document.getElementById('boxGrid');

let roster = []; // {Person ID, Full Name, Security Number, Current Grade, Email 1}
let boxConfig = {}; // { boxId: { rois: [{x,y,w,h} * 60] } }
let mobilenetModel = null;
let currentImage = null;

// Build visual 12x5 grid once
function drawGrid(namesBySlot={}){
  boxGrid.innerHTML='';
  for(let r=0;r<5;r++){
    for(let c=0;c<12;c++){
      const idx = r*12+c+1;
      const div=document.createElement('div');
      div.className='slot';
      const label=document.createElement('span');
      label.textContent = namesBySlot[idx] || `#${idx}`;
      div.appendChild(label);
      boxGrid.appendChild(div);
    }
  }
}

// Load roster (from repo or upload)
async function loadRoster() {
  return new Promise((resolve)=>{
    if (rosterChoice.value === 'upload') {
      if (!rosterUpload.files[0]) return resolve([]);
      Papa.parse(rosterUpload.files[0], { header: true, complete: r=>resolve(r.data) });
    } else {
      Papa.parse(rosterChoice.value, { download: true, header: true, complete: r=>resolve(r.data) });
    }
  });
}

function securityToBoxSlot(sec){
  // Examples: 9A11 â†’ box 9A, slot 11; SM1-22 â†’ box SM1, slot 22
  if(!sec) return null;
  const s = sec.replace(/\s+/g,'').toUpperCase();
  const m = s.match(/^(SM\d|\d{1,2}[A-F])[- ]?(\d{1,2})$/);
  if(!m) return null;
  return { box:m[1], slot: parseInt(m[2],10) };
}

function rosterByBox(boxId){
  const map={};
  for(const row of roster){
    const info = securityToBoxSlot(row['Security Number']||row['SecurityNumber']);
    if (info && info.box===boxId) map[info.slot] = row['Full Name'];
  }
  return map;
}

// Photo preview
photoInput.addEventListener('change',()=>{
  const f = photoInput.files[0]; if(!f) return;
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = ()=>{ preview.innerHTML=''; preview.appendChild(img); currentImage = img; };
  img.src = url;
});

// Roster change UI
rosterChoice.addEventListener('change',()=>{
  rosterUpload.style.display = rosterChoice.value==='upload' ? 'block':'none';
});

// Manual fallback: centered normalized 12Ã—5 grid
const calibrateBtn = document.getElementById('calibrateBtn');
calibrateBtn.addEventListener('click',()=>{
  const box = document.getElementById('boxSelect').value || 'AUTO';
  if(!currentImage) return alert('Take or upload a photo first.');
  const rois=[]; const W=currentImage.naturalWidth, H=currentImage.naturalHeight;
  const padX=0.08*W, padY=0.10*H; const gridW = W-2*padX, gridH = H-2*padY;
  const cellW = gridW/12, cellH = gridH/5;
  for(let r=0;r<5;r++){
    for(let c=0;c<12;c++){
      rois.push({x:(padX+c*cellW)/W, y:(padY+r*cellH)/H, w:cellW/W, h:cellH/H});
    }
  }
  boxConfig[box] = { rois };
  localStorage.setItem('phonebox_config', JSON.stringify(boxConfig));
  alert('Calibrated with a simple 12Ã—5 grid. For best results use â€œAutoâ€‘calibrate (align to blue labels)â€.');
});

// Autoâ€‘calibration: anchor to blue number strip + detect vertical channels
const autoBlueBtn = document.getElementById('autoBlueBtn');
autoBlueBtn.addEventListener('click', async ()=>{
  if(!currentImage) return alert('Take or upload a photo first.');
  const box = document.getElementById('boxSelect').value || 'AUTO';
  statusEl.textContent='Autoâ€‘calibrating to blue labelsâ€¦';

  // Downscale for speed
  const maxW=1000; const r=Math.min(1, maxW/currentImage.naturalWidth);
  const c=document.createElement('canvas'); c.width=Math.round(currentImage.naturalWidth*r); c.height=Math.round(currentImage.naturalHeight*r);
  const ctx=c.getContext('2d'); ctx.drawImage(currentImage,0,0,c.width,c.height);
  const imgData = ctx.getImageData(0,0,c.width,c.height).data;

  // 1) Find y of the blue label strip by counting blueâ€‘dominant pixels per row (focus on bottom half)
  let bestY= Math.floor(c.height*0.65), bestCount=-1;
  for(let y=Math.floor(c.height*0.50); y<c.height; y++){
    let cnt=0; const o=y*c.width*4;
    for(let x=0; x<c.width; x++){
      const i=o+x*4; const r=imgData[i], g=imgData[i+1], b=imgData[i+2];
      if(b>120 && b>r+40 && b>g+30) cnt++; // strong blue
    }
    if(cnt>bestCount){ bestCount=cnt; bestY=y; }
  }
  // Slightly above the strip for the bottom boundary of row 5
  const yBlue = bestY;

  // 2) Detect vertical channels using column edge projection (Sobelâ€‘lite via intensity diff)
  const colEnergy=new Float32Array(c.width);
  for(let x=1; x<c.width-1; x++){
    let s=0; for(let y=0; y<c.height; y++){
      const i=(y*c.width+x)*4, il=(y*c.width+x-1)*4, ir=(y*c.width+x+1)*4;
      const yl=0.299*imgData[il]+0.587*imgData[il+1]+0.114*imgData[il+2];
      const yr=0.299*imgData[ir]+0.587*imgData[ir+1]+0.114*imgData[ir+2];
      s+=Math.abs(yr-yl);
    }
    colEnergy[x]=s;
  }
  // Pick 13 boundaries with nonâ€‘max suppression
  const idx=[...colEnergy].map((v,i)=>[v,i]).sort((a,b)=>b[0]-a[0]);
  const verts=[]; const minDist=Math.round(c.width/18);
  for(const [,i] of idx){ if(verts.every(v=>Math.abs(v-i)>minDist)) verts.push(i); if(verts.length>=13) break; }
  verts.sort((a,b)=>a-b);
  if(verts[0]>5) verts.unshift(0); if(verts[verts.length-1]<c.width-5) verts.push(c.width-1);

  // 3) Build horizontal boundaries: from a top margin down to yBlue (5 rows)
  const topY = Math.round(c.height*0.10); // safe top
  const yBounds=[]; for(let k=0;k<=5;k++){ yBounds.push(Math.round(topY + (yBlue-topY)*k/5)); }

  // 4) Build ROIs (normalized to original image)
  const rois=[]; for(let rIdx=0;rIdx<5;rIdx++){
    const y0=yBounds[rIdx], y1=yBounds[rIdx+1];
    for(let cIdx=0;cIdx<12;cIdx++){
      const x0=verts[cIdx], x1=verts[cIdx+1];
      rois.push({ x:x0/c.width, y:y0/c.height, w:(x1-x0)/c.width, h:(y1-y0)/c.height });
    }
  }

  boxConfig[box] = { rois };
  localStorage.setItem('phonebox_config', JSON.stringify(boxConfig));
  statusEl.textContent='Autoâ€‘calibration complete (aligned to blue numbers).';
});
});

async function ensureModel(){
  if(!mobilenetModel){ mobilenetModel = await mobilenet.load(); }
}

function cropToCanvas(img, roi){
  const c = document.createElement('canvas');
  const W = img.naturalWidth, H = img.naturalHeight;
  c.width = Math.round(roi.w*W); c.height = Math.round(roi.h*H);
  const ctx=c.getContext('2d');
  ctx.drawImage(img, roi.x*W, roi.y*H, roi.w*W, roi.h*H, 0,0,c.width,c.height);
  return c;
}

async function embedCanvas(canvas){
  await ensureModel();
  const logits = mobilenetModel.infer(canvas, true);
  const emb = await logits.data();
  logits.dispose();
  return Array.from(emb);
}

function slotOccupied(canvas){
  // Sample only the central band to avoid number labels; return true if likely occupied
  const ctx = canvas.getContext('2d');
  const sx=Math.round(canvas.width*0.15), sy=Math.round(canvas.height*0.15);
  const sw=Math.round(canvas.width*0.70), sh=Math.round(canvas.height*0.60);
  const {data} = ctx.getImageData(sx,sy,sw,sh);
  let sum=0; for(let j=0;j<data.length;j+=4){ sum += data[j]+data[j+1]+data[j+2]; }
  const avg = sum/(data.length/4)/255; // 0..1
  return avg < 0.75; // darker â†’ phone present
}

function cosSim(a,b){
  let dot=0, na=0, nb=0; for(let i=0;i<a.length;i++){ dot+=a[i]*b[i]; na+=a[i]*a[i]; nb+=b[i]*b[i]; }
  return dot/(Math.sqrt(na)*Math.sqrt(nb)+1e-8);
}

// Storage for per-student reference embeddings
const DB_KEY='phonebox_embeddings_v1';
function loadDB(){ return JSON.parse(localStorage.getItem(DB_KEY)||'{}'); }
function saveDB(db){ localStorage.setItem(DB_KEY, JSON.stringify(db)); }

async function analyze(){
  statusEl.textContent='Loading rosterâ€¦';
  roster = await loadRoster();
  const boxSel = document.getElementById('boxSelect').value;
  let boxId = boxSel || 'AUTO';
  const namesBySlot = boxSel ? rosterByBox(boxSel) : {};
  drawGrid(namesBySlot);

  if(!currentImage) return alert('Please take or upload a photo.');
  const cfg = boxConfig[boxId] || boxConfig['AUTO'];
  if(!cfg){ return alert('Please calibrate once (per box).'); }

  // Compute embeddings for each ROI and compare vs saved DB
  statusEl.textContent='Computing embeddingsâ€¦';
  const db = loadDB();
  const records=[]; // [{slot, expectedName, detectedId, status}]

  for(let i=0;i<cfg.rois.length;i++){
    const roi = cfg.rois[i];
    const canvas = cropToCanvas(currentImage, roi);
    const emb = await embedCanvas(canvas);

    // Determine if slot is empty by measuring image variance/brightness
    const ctx = canvas.getContext('2d');
    const {data} = ctx.getImageData(0,0,canvas.width,canvas.height);
    let sum=0; for(let j=0;j<data.length;j+=4){ sum += data[j]+data[j+1]+data[j+2]; }
    const avg = sum/(data.length/4)/255; // 0..3 â†’ normalize to 0..1
    const occupied = slotOccupied(canvas); // heuristic: darker means phone present

    const slot = i+1;
    const expectedName = namesBySlot[slot] || '';

    let detectedId = null, similarity = 0;
    if(occupied){
      // Search best matching saved embedding for this expected student (if we have one) else global
      if(expectedName && db[expectedName]){
        const best = db[expectedName];
        similarity = cosSim(emb, best);
        detectedId = expectedName;
      } else {
        let bestName=null, bestSim=-1;
        for(const [name, ref] of Object.entries(db)){
          const sim = cosSim(emb, ref);
          if(sim>bestSim){bestSim=sim; bestName=name;}
        }
        detectedId = bestName; similarity = bestSim;
      }
    }

    let status='empty';
    if(occupied && expectedName){
      if(!db[expectedName]) status = 'unknown (no reference yet)';
      else if(similarity>0.80) status='ok';
      else status='mismatch (possible fake)';
    } else if(occupied && !expectedName) {
      status = 'unexpected phone';
    } else if(!occupied && expectedName) {
      status = 'missing';
    }

    records.push({slot, expectedName, detectedId: occupied? (detectedId||'â€”'): 'â€”', status});
  }

  // Render table
  resultsBody.innerHTML='';
  for(const r of records){
    const tr=document.createElement('tr');
    tr.className = r.status==='ok'?'ok':(r.status.includes('mismatch')?'mismatch':'');
    tr.innerHTML = `<td>${r.slot}</td><td>${r.expectedName||''}</td><td>${r.detectedId||''}</td><td><span class="pill">${r.status}</span></td>`;
    resultsBody.appendChild(tr);
  }
  statusEl.textContent='Done.';
}

async function saveEmbeddings(){
  if(!currentImage) return alert('Take/upload a photo first.');
  roster = await loadRoster();
  const boxSel = document.getElementById('boxSelect').value;
  const boxId = boxSel || 'AUTO';
  const cfg = boxConfig[boxId] || boxConfig['AUTO'];
  if(!cfg){ return alert('Calibrate first.'); }

  const namesBySlot = rosterByBox(boxSel);
  const db = loadDB();

  for(let i=0;i<cfg.rois.length;i++){
    const slot=i+1; const name = namesBySlot[slot]; if(!name) continue;
    const canvas = cropToCanvas(currentImage, cfg.rois[i]);
    const emb = await embedCanvas(canvas);
    db[name] = emb; // overwrite
  }
  saveDB(db);
  alert('Saved embeddings for the visible phones in this photo to your browser storage. Repeat a few days to improve robustness.');
}

// OCR auto-detect box (reads printed security numbers/labels near slots)
async function autoDetectBox(){
  if(!currentImage) return;
  statusEl.textContent='Reading labels (OCR)â€¦';
  const worker = await Tesseract.createWorker('eng');
  const { data: { text } } = await worker.recognize(currentImage);
  await worker.terminate();
  const m = text.toUpperCase().match(/(SM\d|\d{1,2}[A-F])\s*-?\s*\d{1,2}/);
  if(m){
    document.getElementById('boxSelect').value = m[1];
    statusEl.textContent = `Detected box: ${m[1]}`;
    drawGrid(rosterByBox(m[1]));
  } else {
    statusEl.textContent = 'Could not auto-detect a box; please choose from the menu.';
  }
}

// Wire buttons
 document.getElementById('analyzeBtn').addEventListener('click', analyze);
 document.getElementById('saveEmbeddingBtn').addEventListener('click', saveEmbeddings);
 document.getElementById('boxSelect').addEventListener('change', async ()=>{
  roster = await loadRoster();
  const id = document.getElementById('boxSelect').value; drawGrid(rosterByBox(id));
 });
 document.getElementById('photo').addEventListener('change', ()=>{
  // try OCR to pick box
  setTimeout(autoDetectBox, 400);
 });

// Load cached config if any
(function init(){
  const saved = localStorage.getItem('phonebox_config');
  if(saved) boxConfig = JSON.parse(saved);
  drawGrid();
})();
</script>
</body>
</html>
