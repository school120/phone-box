<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Phone Box ‚Äî Auto Overlay + Roster (12√ó5)</title>
<style>
  :root{--bg:#0b1020;--card:#11183a;--muted:#9ab0e0;--accent:#32d0ff}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:#fff;font-family:system-ui,-apple-system,Inter,Roboto,Segoe UI}
  header{padding:14px 16px;border-bottom:1px solid #ffffff1a;font-weight:800}
  main{max-width:1200px;margin:0 auto;padding:12px;display:grid;grid-template-columns:1.1fr 0.9fr;gap:16px}
  .card{background:var(--card);border:1px solid #ffffff1a;border-radius:16px;padding:14px;box-shadow:0 10px 30px #0008}
  label{display:block;margin:10px 0 6px;color:var(--muted);font-size:14px}
  input[type="file"],select,button{width:100%;padding:14px 16px;border-radius:12px;border:1px solid #ffffff2b;background:#0f1738;color:#fff;font-size:16px}
  button.primary{background:linear-gradient(180deg,#3bc2f2,#1aa1d9);border:none;font-weight:800}
  small{color:var(--muted)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}

  /* Preview area */
  #stage{position:relative;border:1px dashed #ffffff33;border-radius:12px;overflow:hidden;background:#0c1333;min-height:220px;touch-action:none}
  #img{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:none;z-index:0}
  #overlay{position:absolute;inset:0;pointer-events:none;z-index:1}

  .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:12px}
  .pill{display:inline-block;padding:.2rem .6rem;border-radius:999px;background:#ffffff24;font-size:12px}
  .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:6px;margin:10px 0}
  .slot{background:#0f1738;border:1px solid #ffffff24;aspect-ratio:3/5;border-radius:8px;position:relative}
  .slot span{position:absolute;inset:auto 6px 6px 6px;font-size:12px;color:#9ab0ff}
  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid #ffffff1f;padding:10px 6px;text-align:left}
  tr.missing{background:#ff50501a}
  tr.ok{opacity:.9}
  .hint{font-size:13px;color:#9ab0ff}
  @media (max-width: 900px){
    main{grid-template-columns:1fr}
    header{font-size:18px}
    .row{grid-template-columns:1fr}
  }
</style>
</head>
<body>
<header>üì± Phone Box ‚Äî Auto Overlay + Roster (12√ó5)</header>

<main>
  <section class="card" id="left">
    <div id="stage">
      <img id="img" alt="preview">
      <canvas id="overlay"></canvas>
    </div>

    <div class="grid" id="boxGrid"></div>
    <table>
      <thead><tr><th>Slot</th><th>Expected</th><th>Status</th></tr></thead>
      <tbody id="results"></tbody>
    </table>
  </section>

  <section class="card">
    <label>Box</label>
    <select id="box"></select>

    <label style="margin-top:10px">Roster CSV</label>
    <input id="rosterFile" type="file" accept=".csv">

    <label style="margin-top:10px">Upload a box photo</label>
    <input id="photo" type="file" accept="image/*" capture="environment">

    <div class="row" style="margin-top:10px">
      <div>
        <label>Row height % (above numbers)</label>
        <input id="rowPct" type="range" min="45" max="95" step="5" value="70">
      </div>
      <div>
        <label>Edge crop % (ignore sides)</label>
        <input id="edgePct" type="range" min="0" max="15" step="1" value="5">
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <div>
        <label>Slot inset % (avoid foam walls)</label>
        <input id="insetPct" type="range" min="0" max="25" step="1" value="10">
      </div>
      <div>
        <label>Blue sensitivity</label>
        <input id="blueSens" type="range" min="20" max="80" step="5" value="30">
      </div>
    </div>

    <div class="toolbar">
      <button id="auto" class="primary">Auto Align</button>
      <button id="analyze" disabled>Analyze & Compare</button>
      <label class="hint"><input id="fine" type="checkbox" style="vertical-align:middle"> Fine-tune (drag rows & edges)</label>
    </div>

    <div class="toolbar">
      <label class="hint"><input id="showGuides" type="checkbox" checked style="vertical-align:middle"> Show guides</label>
      <span id="status" class="pill"></span>
    </div>
  </section>
</main>

<script>
/* ========= Elements & State ========= */
const img = document.getElementById('img');
const stage = document.getElementById('stage');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');

const boxSel = document.getElementById('box');
const rosterFile = document.getElementById('rosterFile');
const photo = document.getElementById('photo');
const autoBtn = document.getElementById('auto');
const analyzeBtn = document.getElementById('analyze');
const showGuidesEl = document.getElementById('showGuides');
const fineEl = document.getElementById('fine');
const statusEl = document.getElementById('status');
const boxGrid = document.getElementById('boxGrid');
const resultsBody = document.getElementById('results');

function setStatus(t){ statusEl.textContent=t||''; }

const rowPctEl = document.getElementById('rowPct');
const edgePctEl = document.getElementById('edgePct');
const insetPctEl = document.getElementById('insetPct');
const blueSensEl = document.getElementById('blueSens');

function rowHeight(){ return parseInt(rowPctEl.value,10)/100; }
function edgeCrop(){ return parseInt(edgePctEl.value,10)/100; }
function insetFrac(){ return parseInt(insetPctEl.value,10)/100; }
function blueSens(){ return parseInt(blueSensEl.value,10)/100; }

let current=null;         // {image, W, H}
let roster=[];            // [{...}]
let rowTops=[];           // 5 y positions
let LR=[];                // 5√ó[L,R]
let boundsByRow=[];       // 5√ó13
let rois=[];              // 60 rects
let dragging=null;        // {type:'row'|'L'|'R', row:i, dy/dx}

/* ========= Boxes ========= */
(function fillBoxes(){
  const ids=[], grades=['9','10','11','12'], letters=['A','B','C','D','E','F'];
  grades.forEach(g=>letters.forEach(l=>ids.push(g+l)));
  ids.push('SM1','SM2');
  boxSel.innerHTML = ids.map(x=>`<option>${x}</option>`).join('');
})();

/* ========= CSV Parser (no deps) ========= */
function parseCSV(text){
  const rows=[]; let row=[], cur='', inQ=false; const push=()=>{row.push(cur); cur='';};
  for(let i=0;i<text.length;i++){
    const ch=text[i], nx=text[i+1];
    if(inQ){
      if(ch==='"' && nx==='"'){ cur+='"'; i++; }
      else if(ch==='"'){ inQ=false; }
      else cur+=ch;
    }else{
      if(ch==='"'){ inQ=true; }
      else if(ch===','){ push(); }
      else if(ch==='\n' || ch==='\r'){
        if(ch==='\r' && nx==='\n') i++;
        push(); rows.push(row); row=[];
      }else cur+=ch;
    }
  }
  push(); if(row.length) rows.push(row);
  // header -> objects
  const header = rows.shift().map(h=>h.trim());
  return rows.filter(r=>r.length && r.some(x=>x.trim()!==''))
             .map(r=>{ const o={}; header.forEach((h,i)=>o[h]=r[i]||''); return o; });
}

/* ========= Photo Preview ========= */
photo.addEventListener('change', e=>{
  const f=e.target.files[0]; if(!f) return;
  const url=URL.createObjectURL(f);
  const im=new Image();
  im.onload=()=>{
    current={image:im, W:im.naturalWidth, H:im.naturalHeight};
    img.src=url; img.style.display='block';
    sizeToImageAspect();
    draw();
    setStatus('Photo loaded. Tap ‚ÄúAuto Align‚Äù.');
  };
  im.onerror=()=>setStatus('Could not load image.');
  im.src=url;
});
window.addEventListener('resize', sizeToImageAspect);
function sizeToImageAspect(){
  if(!current) return;
  const W = stage.clientWidth;
  const H = Math.max(220, Math.round(W * (current.H/current.W)));
  stage.style.height = H+'px';
  overlay.width=W; overlay.height=H;
}

/* ========= Roster ========= */
rosterFile.addEventListener('change', ()=>{
  const f=rosterFile.files[0]; if(!f) return;
  const r=new FileReader();
  r.onload=()=>{ roster=parseCSV(r.result||''); setStatus('Roster loaded.'); };
  r.readAsText(f);
});
function namesForBox(boxId){
  const out={};
  for(const row of roster){
    const sec = (row['Security Number']||row['SecurityNumber']||'').toString().toUpperCase().replace(/\s+/g,'');
    const m = sec.match(/^(SM\d|\d{1,2}[A-F])[- ]?(\d{1,2})$/);
    if(!m) continue;
    const box=m[1], slot=parseInt(m[2],10);
    if(box===boxId) out[slot] = row['Full Name']||row['FullName']||'';
  }
  return out;
}
function drawNamesGrid(namesBySlot={}){
  boxGrid.innerHTML='';
  for(let r=0;r<5;r++){
    for(let c=0;c<12;c++){
      const idx=r*12+c+1;
      const d=document.createElement('div'); d.className='slot';
      const s=document.createElement('span'); s.textContent=namesBySlot[idx]||`#${idx}`;
      d.appendChild(s); boxGrid.appendChild(d);
    }
  }
}

/* ========= Auto Align (no OCR) ========= */
autoBtn.addEventListener('click', async ()=>{
  if(!current){ alert('Upload a photo first.'); return; }
  analyzeBtn.disabled = true;
  setStatus('Finding blue bars‚Ä¶');

  rowTops = await findBlueBars(current.image, edgeCrop(), blueSens());
  if(rowTops.length!==5){ setStatus('Could not find 5 blue bars. Bump ‚ÄúBlue sensitivity‚Äù or ‚ÄúEdge crop %‚Äù.'); draw(); return; }

  setStatus('Measuring row edges‚Ä¶');
  LR = await findLRForRows(current.image, rowTops, edgeCrop());

  boundsByRow = [];
  for(let r=0;r<5;r++){ boundsByRow.push(equalBounds(LR[r][0], LR[r][1], 12)); }

  const gaps=[]; for(let i=1;i<rowTops.length;i++) gaps.push(rowTops[i]-rowTops[i-1]);
  const avgGap = gaps.reduce((a,b)=>a+b,0)/gaps.length;

  rois=[];
  for(let r=0;r<5;r++){
    const yBottom=rowTops[r];
    const yTop=Math.max(0, Math.round(yBottom-avgGap*rowHeight()));
    const b=boundsByRow[r];
    for(let i=0;i<12;i++){
      const x0=b[i], x1=b[i+1];
      const inset=Math.round((x1-x0)*insetFrac());
      rois.push({x:x0+inset, y:yTop, w:Math.max(1,(x1-x0-2*inset)), h:yBottom-yTop, row:r, col:i});
    }
  }
  draw();
  analyzeBtn.disabled=false;
  setStatus('Aligned. (Tip: enable ‚ÄúFine-tune‚Äù to drag rows/edges if needed.)');
});

/* ========= Analyze ========= */
analyzeBtn.addEventListener('click', ()=>{
  if(!rois.length) return alert('Auto Align first.');
  if(!boxSel.value) return alert('Choose a Box (e.g., 9B, 10C, SM1).');
  if(!roster || roster.length===0) return alert('Load the roster CSV.');

  const names = namesForBox(boxSel.value);
  drawNamesGrid(names);

  const rows=[];
  for(let i=0;i<rois.length;i++){
    const slot=i+1;
    const expected=names[slot]||'';
    const occ = slotOccupied(cropROI(rois[i]));
    const status = occ ? (expected?'present':'unexpected phone') : (expected?'missing':'empty');
    rows.push({slot, expected, status});
  }

  resultsBody.innerHTML='';
  rows.forEach(r=>{
    const tr=document.createElement('tr');
    tr.className = r.status==='missing' ? 'missing' : (r.status==='present' ? 'ok' : '');
    tr.innerHTML=`<td>${r.slot}</td><td>${r.expected||''}</td><td><span class="pill">${r.status}</span></td>`;
    resultsBody.appendChild(tr);
  });
  setStatus('Compared to roster.');
});

/* ========= Drawing ========= */
function draw(){
  ctx.clearRect(0,0,overlay.width,overlay.height);
  if(!current) return;
  const sx=overlay.width/current.W, sy=overlay.height/current.H;

  if(showGuidesEl.checked){
    // cyan row lines
    if(rowTops.length){
      ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--accent')||'#32d0ff';
      ctx.lineWidth=2;
      for(const y of rowTops){ ctx.beginPath(); ctx.moveTo(0,y*sy); ctx.lineTo(overlay.width,y*sy); ctx.stroke(); }
    }
    // yellow L/R & white bounds
    if(boundsByRow.length){
      for(let r=0;r<5;r++){
        const y=rowTops[r]*sy;
        if(LR[r]){
          ctx.strokeStyle='#ffd84a'; ctx.lineWidth=1.8;
          const [L,R]=LR[r]; const h=40;
          ctx.beginPath(); ctx.moveTo(L*sx,y-h); ctx.lineTo(L*sx,y+h); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(R*sx,y-h); ctx.lineTo(R*sx,y+h); ctx.stroke();
        }
        ctx.strokeStyle='#fff'; ctx.lineWidth=1.6;
        boundsByRow[r].forEach(x=>{ const xx=x*sx; ctx.beginPath(); ctx.moveTo(xx,y-40); ctx.lineTo(xx,y+40); ctx.stroke(); });
      }
    }
  }
  // slot rectangles
  if(rois.length){
    ctx.strokeStyle='rgba(255,255,255,.95)'; ctx.lineWidth=2;
    for(const r of rois){ ctx.strokeRect(r.x*sx, r.y*sy, r.w*sx, r.h*sy); }
  }
}

/* ========= Fine-tune (drag) ========= */
stage.addEventListener('pointerdown', e=>{
  if(!fineEl.checked || !current) return;
  const {ix,iy}=screenToImage(e.clientX,e.clientY);
  // pick closest row line first
  let ri=-1, best=12e9;
  for(let i=0;i<rowTops.length;i++){
    const d=Math.abs(rowTops[i]-iy);
    if(d<best){best=d; ri=i;}
  }
  const nearRow = best<30;
  if(nearRow){
    // check L/R proximity too
    const [L,R]=LR[ri]||[0,current.W];
    const dL=Math.abs(L-ix), dR=Math.abs(R-ix);
    if(dL<20){ dragging={type:'L', row:ri, dx:L-ix}; }
    else if(dR<20){ dragging={type:'R', row:ri, dx:R-ix}; }
    else { dragging={type:'row', row:ri, dy:rowTops[ri]-iy}; }
    stage.setPointerCapture(e.pointerId);
  }
});
stage.addEventListener('pointermove', e=>{
  if(!dragging||!current) return;
  const {ix,iy}=screenToImage(e.clientX,e.clientY);
  const r=dragging.row;
  if(dragging.type==='row'){
    // keep order (no crossing rows)
    const min = r?rowTops[r-1]+20:0;
    const max = r<4?rowTops[r+1]-20:current.H-2;
    rowTops[r]=clamp(iy+dragging.dy,min,max);
  }else if(dragging.type==='L'){
    const L=clamp(ix+dragging.dx, 0, (LR[r]?LR[r][1]-20:current.W-20));
    const old=LR[r]||[0,current.W]; LR[r]=[L,old[1]];
    boundsByRow[r]=remapBounds(boundsByRow[r], old, LR[r]);
  }else if(dragging.type==='R'){
    const R=clamp(ix+dragging.dx, (LR[r]?LR[r][0]+20:20), current.W);
    const old=LR[r]||[0,current.W]; LR[r]=[old[0],R];
    boundsByRow[r]=remapBounds(boundsByRow[r], old, LR[r]);
  }
  rebuildROIs(); draw();
});
stage.addEventListener('pointerup', ()=>dragging=null);

function clamp(v,min,max){ return Math.max(min,Math.min(max,v)); }
function remapBounds(b, oldLR, newLR){
  const [oL,oR]=oldLR, [nL,nR]=newLR;
  return b.map(x=> Math.round(nL + ( (x-oL)/Math.max(1,(oR-oL)) )*(nR-nL) ));
}
function rebuildROIs(){
  if(!rowTops.length||!boundsByRow.length) return;
  rois=[];
  const gaps=[]; for(let i=1;i<rowTops.length;i++) gaps.push(rowTops[i]-rowTops[i-1]);
  const avgGap=gaps.reduce((a,b)=>a+b,0)/gaps.length;
  for(let r=0;r<5;r++){
    const yBottom=rowTops[r];
    const yTop=Math.max(0, Math.round(yBottom-avgGap*rowHeight()));
    const b=boundsByRow[r];
    for(let i=0;i<12;i++){
      const x0=b[i], x1=b[i+1];
      const inset=Math.round((x1-x0)*insetFrac());
      rois.push({x:x0+inset, y:yTop, w:Math.max(1,(x1-x0-2*inset)), h:yBottom-yTop, row:r, col:i});
    }
  }
}

/* ========= Image/Color helpers ========= */
function screenToImage(cx,cy){
  const r=overlay.getBoundingClientRect();
  const x=(cx-r.left)/r.width*current.W;
  const y=(cy-r.top)/r.height*current.H;
  return {ix:x, iy:y};
}
function cropROI(r){
  const c=document.createElement('canvas'); c.width=r.w; c.height=r.h;
  c.getContext('2d').drawImage(current.image, r.x,r.y,r.w,r.h, 0,0,r.w,r.h);
  return c;
}
function slotOccupied(c){
  const k=c.getContext('2d');
  const cx=Math.round(c.width*0.20), cw=Math.round(c.width*0.60);
  const cy=Math.round(c.height*0.15), ch=Math.round(c.height*0.60);
  const {data}=k.getImageData(cx,cy,cw,ch);
  const cols=new Float32Array(cw).fill(0), dark=130;
  for(let y=0;y<ch;y++){ for(let x=0;x<cw;x++){ const i=(y*cw+x)*4; const L=0.299*data[i]+0.587*data[i+1]+0.114*data[i+2]; if(L<dark) cols[x]++; } }
  for(let x=0;x<cw;x++) cols[x]/=ch;
  let best=0,run=0; for(let x=0;x<cw;x++){ if(cols[x]>0.5){ run++; best=Math.max(best,run);} else run=0; }
  return best>=Math.round(cw*0.25);
}
function rgb2hsv(r,g,b){ r/=255; g/=255; b/=255; const max=Math.max(r,g,b),min=Math.min(r,g,b),d=max-min; let h=0; if(d!==0){ if(max===r) h=((g-b)/d)%6; else if(max===g) h=(b-r)/d+2; else h=(r-g)/d+4; h*=60; if(h<0)h+=360; } const s=max===0?0:d/max, v=max; return {h,s,v}; }

/* ========= Blue bar detection ========= */
async function findBlueBars(imgEl, edgeCrop, sens){
  const maxW=1400, r=Math.min(1, maxW/imgEl.naturalWidth);
  const W=Math.round(imgEl.naturalWidth*r), H=Math.round(imgEl.naturalHeight*r);
  const c=document.createElement('canvas'); c.width=W; c.height=H;
  const g=c.getContext('2d'); g.drawImage(imgEl,0,0,W,H);
  const {data}=g.getImageData(0,0,W,H);

  const hueMin=190, hueMax=265, sMin=0.28, vMin=0.18 + sens*0.35; // sensitivity raises vMin
  const x0=Math.round(W*edgeCrop), x1=Math.round(W*(1-edgeCrop));
  const frac=new Float32Array(H);

  for(let y=0;y<H;y++){
    let cnt=0, blue=0;
    for(let x=x0;x<=x1;x+=2){
      const i=(y*W+x)*4; const {h,s,v}=rgb2hsv(data[i],data[i+1],data[i+2]);
      if((h>hueMin&&h<hueMax)&&s>=sMin&&v>=vMin) blue++; cnt++;
    }
    frac[y]=cnt?blue/cnt:0;
  }
  const s = smooth(frac,7);
  const peaks = topPeaks(s,5,Math.round(H/8));
  const win=Math.round(H*0.035), tops=[];
  for(const p of peaks){
    let M=0; for(let y=Math.max(0,p-win); y<=Math.min(H-1,p+win); y++) M=Math.max(M,s[y]);
    const T=M*0.5; let top=p;
    for(let y=p;y>=0;y--){ if(s[y]>=T) top=y; else break; }
    tops.push(top);
  }
  return tops.sort((a,b)=>a-b).map(y=>Math.round(y/r));
}
function smooth(a,w){const o=new Float32Array(a.length); for(let i=0;i<a.length;i++){let s=0,c=0; for(let k=-w;k<=w;k++){const j=i+k; if(j<0||j>=a.length) continue; s+=a[j]; c++;} o[i]=s/c;} return o;}
function topPeaks(s,count,minDist){const idx=[...s].map((v,i)=>[v,i]).sort((a,b)=>b[0]-a[0]); const out=[]; for(const [,i] of idx){ if(out.every(j=>Math.abs(j-i)>minDist)) out.push(i); if(out.length>=count) break; } return out.sort((a,b)=>a-b);}

/* ========= Row L/R detection ========= */
async function findLRForRows(imgEl, tops, edgeCrop){
  const maxW=1400; const r=Math.min(1, maxW/imgEl.naturalWidth);
  const W=Math.round(imgEl.naturalWidth*r), H=Math.round(imgEl.naturalHeight*r);
  const can=document.createElement('canvas'); can.width=W; can.height=H;
  const g=can.getContext('2d'); g.drawImage(imgEl,0,0,W,H);
  const im=g.getImageData(0,0,W,H);
  const scaleX = imgEl.naturalWidth/W;

  const gaps=[]; for(let i=1;i<tops.length;i++) gaps.push((tops[i]-tops[i-1])*r);
  const avgGap = gaps.reduce((a,b)=>a+b,0)/gaps.length || H/5;
  const bandH = Math.max(6, Math.round(avgGap*0.22));

  const out=[];
  for(const yBig of tops){
    const ySm = Math.max(0, Math.round(yBig*r));
    const col = blueAmountByColumn(im, ySm+1, Math.min(H-1, ySm+bandH));
    const [L,R]=largestRun(col, Math.round(W*edgeCrop));
    out.push([ Math.round(L*scaleX), Math.round(R*scaleX) ]);
  }
  return out;
}
function blueAmountByColumn(im, y0,y1){
  const {data,width:W}=im; const col=new Float32Array(W).fill(0);
  for(let x=0;x<W;x++){
    let s=0; for(let y=y0;y<=y1;y++){
      const i=(y*W+x)*4; const {h,s:S,v}=rgb2hsv(data[i],data[i+1],data[i+2]);
      if((h>190&&h<265)&&S>=0.28&&v>=0.22) s++;
    }
    col[x]=s;
  }
  return smooth(col,6);
}
function largestRun(col, pad){
  const W=col.length, L=pad, R=W-pad-1;
  const thr = quantile([...col].slice(L,R+1), 0.55);
  const mask=new Uint8Array(W);
  for(let x=L;x<=R;x++) mask[x]=col[x]>=thr?1:0;
  let best=[L,R], width=0, s=null;
  for(let x=L;x<=R;x++){
    if(mask[x] && s===null) s=x;
    if((!mask[x] || x===R) && s!==null){
      const e = (!mask[x] && x> L) ? x-1 : x;
      const w=e-s; if(w>width){width=w; best=[s,e];}
      s=null;
    }
  }
  return best;
}
function quantile(a,q){const b=[...a].sort((x,y)=>x-y); const i=Math.max(0,Math.min(b.length-1,Math.floor(q*(b.length-1)))); return b[i];}

/* ========= Bounds helper ========= */
function equalBounds(L,R,n){ const step=(R-L)/n; const b=[Math.round(L)]; for(let i=1;i<n;i++) b.push(Math.round(L+i*step)); b.push(Math.round(R)); return b; }
</script>
</body>
</html>
