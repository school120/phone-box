
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Phone Slot Trainer</title>
  <style>
    body { font-family: sans-serif; background: #f0f0f0; padding: 20px; }
    canvas { border: 1px solid #ccc; display: block; margin-bottom: 10px; }
    #controls { margin-bottom: 10px; }
    #slotGrid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 4px; margin-bottom: 10px; }
    .slotBtn { padding: 6px; font-size: 12px; border: 1px solid #999; background: #fff; cursor: pointer; }
    .phone { background: #aaffaa; }
    .empty { background: #ffaaaa; }
    #results { margin-top: 10px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
</head>
<body>
  <h1>Phone Slot Trainer</h1>
  <div id="controls">
    <input type="file" id="imageInput" accept="image/*"><br><br>
    <button onclick="trainModel()">Train Model</button>
    <button onclick="predictSlots()">Predict Slots</button>
    <button onclick="saveModel()">Save Model</button>
    <button onclick="loadModel()">Load Model</button>
  </div>
  <canvas id="canvas" width="600" height="800"></canvas>
  <div id="slotGrid"></div>
  <div id="results"></div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const slotGrid = document.getElementById('slotGrid');
    const slotLabels = Array(60).fill(null); // null, 'phone', 'empty'
    let image = null;
    let model = null;

    // Draw image and overlay slots
    function drawImage(img) {
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      drawSlots();
    }

    function drawSlots() {
      const w = canvas.width;
      const h = canvas.height;
      const slotW = w / 12;
      const slotH = h / 5;
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      for (let r = 0; r < 5; r++) {
        for (let c = 0; c < 12; c++) {
          const x = c * slotW;
          const y = r * slotH;
          ctx.strokeRect(x, y, slotW, slotH);
          const idx = r * 12 + c;
          ctx.fillStyle = 'yellow';
          ctx.font = '12px sans-serif';
          ctx.fillText(idx + 1, x + 4, y + 14);
        }
      }
    }

    // Create buttons for labeling
    function createSlotButtons() {
      slotGrid.innerHTML = '';
      for (let i = 0; i < 60; i++) {
        const btn = document.createElement('button');
        btn.textContent = i + 1;
        btn.className = 'slotBtn';
        btn.onclick = () => {
          if (slotLabels[i] === 'phone') {
            slotLabels[i] = 'empty';
          } else {
            slotLabels[i] = 'phone';
          }
          updateButtonStyle(btn, slotLabels[i]);
        };
        slotGrid.appendChild(btn);
      }
    }

    function updateButtonStyle(btn, label) {
      btn.classList.remove('phone', 'empty');
      if (label === 'phone') btn.classList.add('phone');
      if (label === 'empty') btn.classList.add('empty');
    }

    // Load image
    document.getElementById('imageInput').addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = () => {
        image = img;
        drawImage(img);
        createSlotButtons();
      };
      img.src = URL.createObjectURL(file);
    });

    // Extract slot image data
    function getSlotImageData(idx) {
      const w = canvas.width;
      const h = canvas.height;
      const slotW = w / 12;
      const slotH = h / 5;
      const r = Math.floor(idx / 12);
      const c = idx % 12;
      const x = c * slotW;
      const y = r * slotH;
      const imageData = ctx.getImageData(x, y, slotW, slotH);
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = slotW;
      tempCanvas.height = slotH;
      tempCanvas.getContext('2d').putImageData(imageData, 0, 0);
      return tf.browser.fromPixels(tempCanvas).resizeNearestNeighbor([64, 64]).toFloat().div(255).expandDims(0);
    }

    // Train model
    async function trainModel() {
      const xs = [];
      const ys = [];
      for (let i = 0; i < 60; i++) {
        if (slotLabels[i]) {
          xs.push(getSlotImageData(i));
          ys.push(slotLabels[i] === 'phone' ? 1 : 0);
        }
      }
      if (xs.length === 0) {
        alert('Please label some slots first.');
        return;
      }
      const xTensor = tf.concat(xs);
      const yTensor = tf.tensor(ys, [ys.length, 1]);

      model = tf.sequential();
      model.add(tf.layers.conv2d({inputShape: [64, 64, 3], filters: 8, kernelSize: 3, activation: 'relu'}));
      model.add(tf.layers.maxPooling2d({poolSize: 2}));
      model.add(tf.layers.flatten());
      model.add(tf.layers.dense({units: 16, activation: 'relu'}));
      model.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));
      model.compile({optimizer: 'adam', loss: 'binaryCrossentropy', metrics: ['accuracy']});

      await model.fit(xTensor, yTensor, {epochs: 10});
      alert('Model trained.');
    }

    // Predict slots
    async function predictSlots() {
      if (!model) {
        alert('Train or load a model first.');
        return;
      }
      const results = document.getElementById('results');
      results.innerHTML = '<h3>Predictions:</h3><ul>';
      for (let i = 0; i < 60; i++) {
        const input = getSlotImageData(i);
        const pred = await model.predict(input).data();
        const label = pred[0] > 0.5 ? 'Phone' : 'Empty';
        results.innerHTML += `<li>Slot ${i + 1}: ${label}</li>`;
      }
      results.innerHTML += '</ul>';
    }

    // Save model
    async function saveModel() {
      if (!model) {
        alert('Train a model first.');
        return;
      }
      await model.save('localstorage://phone-slot-model');
      alert('Model saved to browser.');
    }

    // Load model
    async function loadModel() {
      try {
        model = await tf.loadLayersModel('localstorage://phone-slot-model');
        alert('Model loaded from browser.');
      } catch {
        alert('No saved model found.');
      }
    }
  </script>
</body>
</html>
