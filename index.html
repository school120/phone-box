<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Phone Box Overlay + Roster (Blue-Bar Auto â€¢ 12Ã—5)</title>
<!-- Only one dependency for CSV parsing -->
<script defer src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  :root{--bg:#0b1020;--card:#11183a;--muted:#9ab0e0;--accent:#32d0ff}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:#fff;font-family:system-ui,-apple-system,Inter,Roboto,Segoe UI}
  header{padding:14px 16px;border-bottom:1px solid #ffffff1a;font-weight:800}
  main{max-width:1200px;margin:0 auto;padding:12px;display:grid;grid-template-columns:1.1fr 0.9fr;gap:16px}
  .card{background:var(--card);border:1px solid #ffffff1a;border-radius:16px;padding:14px;box-shadow:0 10px 30px #0008}
  label{display:block;margin:10px 0 6px;color:var(--muted);font-size:14px}
  input[type="file"],select,button{width:100%;padding:14px 16px;border-radius:12px;border:1px solid #ffffff2b;background:#0f1738;color:#fff;font-size:16px}
  button.primary{background:linear-gradient(180deg,#3bc2f2,#1aa1d9);border:none;font-weight:800}
  small{color:var(--muted)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}

  /* Preview area */
  #stage{position:relative;border:1px dashed #ffffff33;border-radius:12px;overflow:hidden;background:#0c1333;min-height:220px}
  #img{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:none;z-index:0}
  #overlay{position:absolute;inset:0;pointer-events:none;z-index:1}

  .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:12px}
  .pill{display:inline-block;padding:.2rem .6rem;border-radius:999px;background:#ffffff24;font-size:12px}
  .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:6px;margin:10px 0}
  .slot{background:#0f1738;border:1px solid #ffffff24;aspect-ratio:3/5;border-radius:8px;position:relative}
  .slot span{position:absolute;inset:auto 6px 6px 6px;font-size:12px;color:#9ab0ff}
  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid #ffffff1f;padding:10px 6px;text-align:left}
  tr.missing{background:#ff50501a}
  tr.ok{opacity:.9}
  .hint{font-size:13px;color:#9ab0ff}
  @media (max-width: 900px){
    main{grid-template-columns:1fr}
    header{font-size:18px}
    .row{grid-template-columns:1fr}
  }
</style>
</head>
<body>
<header>ðŸ“± Phone Box Overlay + Roster (Blue-Bar Auto â€¢ 12Ã—5)</header>

<main>
  <section class="card" id="left">
    <div id="stage">
      <img id="img" alt="preview">
      <canvas id="overlay"></canvas>
    </div>

    <div class="grid" id="boxGrid"></div>
    <table>
      <thead><tr><th>Slot</th><th>Expected</th><th>Status</th></tr></thead>
      <tbody id="results"></tbody>
    </table>
  </section>

  <section class="card">
    <label>Box</label>
    <select id="box"></select>

    <label style="margin-top:10px">Roster source</label>
    <select id="rosterSource">
      <option value="repo">Use ./data/roster.csv (repo)</option>
      <option value="upload">Upload CSVâ€¦</option>
    </select>
    <input id="rosterFile" type="file" accept=".csv" style="display:none;margin-top:6px"/>

    <label style="margin-top:10px">Upload a box photo</label>
    <input id="photo" type="file" accept="image/*" capture="environment">

    <div class="row" style="margin-top:10px">
      <div>
        <label>Row height % (above numbers)</label>
        <input id="rowPct" type="range" min="45" max="95" step="5" value="70">
      </div>
      <div>
        <label>Edge crop % (ignore sides)</label>
        <input id="edgePct" type="range" min="0" max="15" step="1" value="5">
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <div>
        <label>Slot inset % (avoid foam walls)</label>
        <input id="insetPct" type="range" min="0" max="25" step="1" value="10">
      </div>
      <div>
        <label>Blue sensitivity</label>
        <input id="blueSens" type="range" min="20" max="80" step="5" value="30">
      </div>
    </div>

    <div class="toolbar">
      <button id="scan" class="primary">Scan & Overlay</button>
      <button id="analyze" disabled>Analyze & Compare</button>
      <button id="reset">Reset</button>
    </div>

    <div class="toolbar">
      <label class="hint"><input id="showGuides" type="checkbox" checked style="vertical-align:middle"> Show guides</label>
      <span id="progress" class="pill"></span>
    </div>

    <small id="status"></small>
  </section>
</main>

<script>
/* ===== Elements & State ===== */
const img = document.getElementById('img');
const stage = document.getElementById('stage');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');

const statusEl = document.getElementById('status');
const progressEl = document.getElementById('progress');

const rowPctEl = document.getElementById('rowPct');
const edgePctEl = document.getElementById('edgePct');
const insetPctEl = document.getElementById('insetPct');
const blueSensEl = document.getElementById('blueSens');
const showGuidesEl = document.getElementById('showGuides');

const analyzeBtn = document.getElementById('analyze');
const scanBtn = document.getElementById('scan');
const resetBtn = document.getElementById('reset');

const rosterSource = document.getElementById('rosterSource');
const rosterFile = document.getElementById('rosterFile');
const boxSel = document.getElementById('box');
const resultsBody = document.getElementById('results');
const boxGrid = document.getElementById('boxGrid');

let current=null;         // {image, W, H}
let rowTops=[];           // 5 y-positions (top edge of blue bars)
let boundsByRow=[];       // 5Ã—13 ints (12 slots â†’ 13 vertical boundaries)
let LR=[];                // 5Ã—[L,R] limits per row
let rois=[];              // 60 rects
let roster=[];            // CSV rows

/* ===== Boxes ===== */
(function fillBoxes(){
  const ids=[], grades=['9','10','11','12'], letters=['A','B','C','D','E','F'];
  grades.forEach(g=>letters.forEach(l=>ids.push(g+l)));
  ids.push('SM1','SM2');
  boxSel.innerHTML = ids.map(x=>`<option>${x}</option>`).join('');
})();

/* ===== Roster ===== */
rosterSource.addEventListener('change', ()=>{
  rosterFile.style.display = rosterSource.value==='upload' ? 'block' : 'none';
  if(rosterSource.value==='repo') loadRosterFromRepo();
});
rosterFile.addEventListener('change', ()=>{
  if(rosterFile.files[0]) loadRosterFromFile(rosterFile.files[0]);
});
function loadRosterFromRepo(){
  Papa.parse('./data/roster.csv', {download:true, header:true, complete:(r)=>{ roster=r.data||[]; setStatus('Roster loaded from repo.'); }});
}
function loadRosterFromFile(f){
  Papa.parse(f, {header:true, complete:(r)=>{ roster=r.data||[]; setStatus('Roster loaded from file.'); }});
}
// try to auto-load repo roster
loadRosterFromRepo();

/* ===== Photo ===== */
document.getElementById('photo').addEventListener('change', (e)=>{
  const f = e.target.files[0]; if(!f) return;
  const url = URL.createObjectURL(f);
  const im = new Image();
  im.onload = () => {
    current = { image: im, W: im.naturalWidth, H: im.naturalHeight };
    img.src = url; img.style.display='block';
    sizeToImageAspect(); // ensure preview
    draw();
    setStatus('Photo loaded. Tap â€œScan & Overlayâ€.');
  };
  im.onerror = () => setStatus('Could not load image. Try another photo.');
  im.src = url;
});
window.addEventListener('resize', sizeToImageAspect);
function sizeToImageAspect(){
  if(!current) return;
  const W = stage.clientWidth;
  const H = Math.max(220, Math.round(W * (current.H / current.W)));
  stage.style.height = H + 'px';
  overlay.width = W;
  overlay.height = H;
}

/* ===== UI helpers ===== */
function setStatus(t){ statusEl.textContent = t||''; }
function setProgress(t){ progressEl.textContent = t||''; }
function edgeCrop(){ return parseInt(edgePctEl.value,10)/100; }
function rowHeight(){ return parseInt(rowPctEl.value,10)/100; }
function insetFrac(){ return parseInt(insetPctEl.value,10)/100; }
function blueSens(){ return parseInt(blueSensEl.value,10)/100; }

/* ===== Scan & Overlay (no OCR) ===== */
scanBtn.addEventListener('click', async ()=>{
  if(!current){ alert('Upload a photo first.'); return; }
  analyzeBtn.disabled = true;
  setStatus('Scanningâ€¦'); setProgress('detecting rows');

  // 1) Detect five blue number bars (top edge)
  rowTops = await findBlueBars(current.image, edgeCrop(), blueSens());
  if(rowTops.length!==5){ setStatus('Could not find 5 blue bars. Increase Blue sensitivity or adjust Edge crop %.'); draw(); return; }

  setProgress('finding left/right');
  // 2) For each row, estimate L/R limits by blue content
  LR = await findLRForRows(current.image, rowTops, edgeCrop());

  // 3) Build 13 vertical bounds per row by splitting L..R into 12 equal slots
  boundsByRow = [];
  for(let r=0;r<5;r++){ boundsByRow.push(equalBounds(LR[r][0], LR[r][1], 12)); }

  // 4) Build ROIs above each row
  rois = [];
  const gaps=[]; for(let i=1;i<rowTops.length;i++) gaps.push(rowTops[i]-rowTops[i-1]);
  const avgGap = gaps.reduce((a,b)=>a+b,0)/gaps.length;
  const pct = rowHeight();
  for(let r=0;r<5;r++){
    const yBottom = rowTops[r];
    const yTop = Math.max(0, Math.round(yBottom - avgGap*pct));
    const b = boundsByRow[r];
    for(let i=0;i<12;i++){
      const x0=b[i], x1=b[i+1];
      const inset = Math.round((x1-x0)*insetFrac());
      rois.push({ x:x0+inset, y:yTop, w:Math.max(1,(x1-x0-2*inset)), h:yBottom-yTop, row:r, col:i });
    }
  }

  draw();
  analyzeBtn.disabled = false;
  setProgress('ready'); setStatus('Overlay ready. Tap â€œAnalyze & Compareâ€.');
});

resetBtn.addEventListener('click', ()=>{
  rowTops=[]; boundsByRow=[]; LR=[]; rois=[]; resultsBody.innerHTML=''; boxGrid.innerHTML=''; draw(); setStatus('');
});

/* ===== Analyze & Compare ===== */
analyzeBtn.addEventListener('click', ()=>{
  if(!rois.length) return alert('Scan & Overlay first.');
  if(!boxSel.value) return alert('Choose a Box (e.g., 9B, 10C, SM1).');
  if(!roster || roster.length===0) return alert('Load the roster (repo CSV or upload).');

  const names = namesForBox(boxSel.value);
  drawNamesGrid(names);

  const rows=[];
  for(let i=0;i<rois.length;i++){
    const slot = i+1;
    const expected = names[slot] || '';
    const occ = slotOccupied(cropROI(rois[i]));
    const status = occ ? (expected?'present':'unexpected phone') : (expected?'missing':'empty');
    rows.push({slot, expected, status});
  }

  resultsBody.innerHTML='';
  rows.forEach(r=>{
    const tr=document.createElement('tr');
    tr.className = r.status==='missing' ? 'missing' : (r.status==='present' ? 'ok' : '');
    tr.innerHTML=`<td>${r.slot}</td><td>${r.expected||''}</td><td><span class="pill">${r.status}</span></td>`;
    resultsBody.appendChild(tr);
  });
  setStatus('Compared to roster.');
});

/* ===== Drawing ===== */
function draw(){
  ctx.clearRect(0,0,overlay.width,overlay.height);
  if(!current) return;
  const sx = overlay.width/current.W, sy = overlay.height/current.H;

  if(showGuidesEl.checked){
    // cyan row lines
    if(rowTops.length){
      ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--accent')||'#32d0ff';
      ctx.lineWidth=2;
      for(const y of rowTops){ ctx.beginPath(); ctx.moveTo(0, y*sy); ctx.lineTo(overlay.width, y*sy); ctx.stroke(); }
    }
    // yellow L/R & white bounds
    if(boundsByRow.length){
      for(let r=0;r<5;r++){
        const y=rowTops[r]*sy;
        if(LR[r]){
          ctx.strokeStyle='#ffd84a'; ctx.lineWidth=1.6;
          const [L,R]=LR[r]; const h=40;
          ctx.beginPath(); ctx.moveTo(L*sx,y-h); ctx.lineTo(L*sx,y+h); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(R*sx,y-h); ctx.lineTo(R*sx,y+h); ctx.stroke();
        }
        ctx.strokeStyle='#fff'; ctx.lineWidth=1.5;
        boundsByRow[r].forEach(x=>{ const xx=x*sx; ctx.beginPath(); ctx.moveTo(xx,y-40); ctx.lineTo(xx,y+40); ctx.stroke(); });
      }
    }
  }
  // slot rectangles
  if(rois.length){
    ctx.strokeStyle='rgba(255,255,255,.95)'; ctx.lineWidth=2;
    for(const r of rois){ ctx.strokeRect(r.x*sx, r.y*sy, r.w*sx, r.h*sy); }
  }
}

/* ===== Roster helpers ===== */
function namesForBox(boxId){
  const out={};
  for(const row of roster){
    const sec = (row['Security Number']||row['SecurityNumber']||'').toString().toUpperCase().replace(/\s+/g,'');
    const m = sec.match(/^(SM\d|\d{1,2}[A-F])[- ]?(\d{1,2})$/);
    if(!m) continue;
    const box=m[1], slot=parseInt(m[2],10);
    if(box===boxId) out[slot] = row['Full Name']||row['FullName']||'';
  }
  return out;
}
function drawNamesGrid(namesBySlot={}){
  boxGrid.innerHTML='';
  for(let r=0;r<5;r++){
    for(let c=0;c<12;c++){
      const idx=r*12+c+1;
      const d=document.createElement('div'); d.className='slot';
      const s=document.createElement('span'); s.textContent=namesBySlot[idx]||`#${idx}`;
      d.appendChild(s); boxGrid.appendChild(d);
    }
  }
}

/* ===== Image/Color/Geometry ===== */
function cropROI(r){
  const c=document.createElement('canvas'); c.width=r.w; c.height=r.h;
  c.getContext('2d').drawImage(current.image, r.x,r.y,r.w,r.h, 0,0,r.w,r.h);
  return c;
}
function slotOccupied(c){
  const k=c.getContext('2d');
  const cx=Math.round(c.width*0.20), cw=Math.round(c.width*0.60);
  const cy=Math.round(c.height*0.15), ch=Math.round(c.height*0.60);
  const {data}=k.getImageData(cx,cy,cw,ch);
  const cols=new Float32Array(cw).fill(0), dark=130;
  for(let y=0;y<ch;y++){ for(let x=0;x<cw;x++){ const i=(y*cw+x)*4; const L=0.299*data[i]+0.587*data[i+1]+0.114*data[i+2]; if(L<dark) cols[x]++; } }
  for(let x=0;x<cw;x++) cols[x]/=ch;
  let best=0,run=0; for(let x=0;x<cw;x++){ if(cols[x]>0.5){ run++; best=Math.max(best,run);} else run=0; }
  return best>=Math.round(cw*0.25);
}

/* Detect 5 blue bars */
async function findBlueBars(imgEl, edgeCrop, sens){
  const maxW=1200, r=Math.min(1, maxW/imgEl.naturalWidth);
  const W=Math.round(imgEl.naturalWidth*r), H=Math.round(imgEl.naturalHeight*r);
  const c=document.createElement('canvas'); c.width=W; c.height=H;
  const g=c.getContext('2d'); g.drawImage(imgEl,0,0,W,H);
  const {data}=g.getImageData(0,0,W,H);

  const hueMin=190, hueMax=265, sMin=0.28, vMin=0.20 + sens*0.3; // raise vMin as sensitivity increases
  const x0=Math.round(W*edgeCrop), x1=Math.round(W*(1-edgeCrop));
  const frac=new Float32Array(H);
  for(let y=0;y<H;y++){
    let cnt=0, blue=0;
    for(let x=x0;x<=x1;x+=2){
      const i=(y*W+x)*4; const {h,s,v}=rgb2hsv(data[i],data[i+1],data[i+2]);
      if((h>hueMin&&h<hueMax)&&s>=sMin&&v>=vMin) blue++; cnt++;
    }
    frac[y]=cnt?blue/cnt:0;
  }
  const s = smooth(frac,6);
  const peaks = topPeaks(s,5,Math.round(H/8));
  const win=Math.round(H*0.035), tops=[];
  for(const p of peaks){
    let M=0; for(let y=Math.max(0,p-win); y<=Math.min(H-1,p+win); y++) M=Math.max(M,s[y]);
    const T=M*0.5; let top=p;
    for(let y=p;y>=0;y--){ if(s[y]>=T) top=y; else break; }
    tops.push(top);
  }
  return tops.sort((a,b)=>a-b).map(y=>Math.round(y/r));
}
function rgb2hsv(r,g,b){ r/=255; g/=255; b/=255; const max=Math.max(r,g,b),min=Math.min(r,g,b),d=max-min; let h=0; if(d!==0){ if(max===r) h=((g-b)/d)%6; else if(max===g) h=(b-r)/d+2; else h=(r-g)/d+4; h*=60; if(h<0)h+=360; } const s=max===0?0:d/max, v=max; return {h,s,v}; }
function smooth(a,w){const o=new Float32Array(a.length); for(let i=0;i<a.length;i++){let s=0,c=0; for(let k=-w;k<=w;k++){const j=i+k; if(j<0||j>=a.length) continue; s+=a[j]; c++;} o[i]=s/c;} return o;}
function topPeaks(s,count,minDist){const idx=[...s].map((v,i)=>[v,i]).sort((a,b)=>b[0]-a[0]); const out=[]; for(const [,i] of idx){ if(out.every(j=>Math.abs(j-i)>minDist)) out.push(i); if(out.length>=count) break; } return out.sort((a,b)=>a-b);}

/* Per-row L/R from blue content */
async function findLRForRows(imgEl, tops, edgeCrop){
  const maxW=1200; const r=Math.min(1, maxW/imgEl.naturalWidth);
  const W=Math.round(imgEl.naturalWidth*r), H=Math.round(imgEl.naturalHeight*r);
  const can=document.createElement('canvas'); can.width=W; can.height=H;
  const g=can.getContext('2d'); g.drawImage(imgEl,0,0,W,H);
  const im=g.getImageData(0,0,W,H);
  const scaleX = imgEl.naturalWidth/W;
  const gaps=[]; for(let i=1;i<tops.length;i++) gaps.push((tops[i]-tops[i-1])*r);
  const avgGap = gaps.reduce((a,b)=>a+b,0)/gaps.length || H/5;
  const bandH = Math.max(6, Math.round(avgGap*0.22));
  const out=[];
  for(const yBig of tops){
    const ySm = Math.max(0, Math.round(yBig*r));
    const col = blueAmountByColumn(im, ySm+1, Math.min(H-1, ySm+bandH));
    const [L,R]=largestRun(col, Math.round(W*edgeCrop));
    out.push([ Math.round(L*scaleX), Math.round(R*scaleX) ]);
  }
  return out;
}
function blueAmountByColumn(im, y0,y1){
  const {data,width:W}=im; const col=new Float32Array(W).fill(0);
  for(let x=0;x<W;x++){
    let s=0; for(let y=y0;y<=y1;y++){
      const i=(y*W+x)*4; const {h,s:S,v}=rgb2hsv(data[i],data[i+1],data[i+2]);
      if((h>190&&h<265)&&S>=0.28&&v>=0.22) s++;
    }
    col[x]=s;
  }
  return smooth(col,6);
}
function largestRun(col, pad){
  const W=col.length, L=pad, R=W-pad-1;
  const thr = quantile([...col].slice(L,R+1), 0.55);
  const mask=new Uint8Array(W);
  for(let x=L;x<=R;x++) mask[x]=col[x]>=thr?1:0;
  let best=[L,R], width=0, s=null;
  for(let x=L;x<=R;x++){
    if(mask[x] && s===null) s=x;
    if((!mask[x] || x===R) && s!==null){
      const e = (!mask[x] && x> L) ? x-1 : x;
      const w=e-s; if(w>width){width=w; best=[s,e];}
      s=null;
    }
  }
  return best;
}
function quantile(a,q){const b=[...a].sort((x,y)=>x-y); const i=Math.max(0,Math.min(b.length-1,Math.floor(q*(b.length-1)))); return b[i];}

/* Bounds helper (12 slots = 13 boundaries) */
function equalBounds(L,R,n){ const step=(R-L)/n; const b=[Math.round(L)]; for(let i=1;i<n;i++) b.push(Math.round(L+i*step)); b.push(Math.round(R)); return b; }
</script>
</body>
</html>
