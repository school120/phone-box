<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Phone Box â€” 12 slots aligned to blue numbers</title>
<style>
  :root{--bg:#0b1020;--card:#11183a;--muted:#9ab0e0}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:#fff;font-family:system-ui,-apple-system,Inter,Roboto,Segoe UI}
  header{padding:14px 16px;border-bottom:1px solid #ffffff1a;font-weight:800}
  main{max-width:1200px;margin:0 auto;padding:12px;display:grid;grid-template-columns:1.08fr 0.92fr;gap:16px}
  .card{background:#11183a;border:1px solid #ffffff1a;border-radius:16px;padding:14px}
  label{display:block;margin:10px 0 6px;color:var(--muted);font-size:14px}
  input[type="file"],select,button{width:100%;padding:14px 16px;border-radius:12px;border:1px solid #ffffff2b;background:#0f1738;color:#fff;font-size:16px}
  button.primary{background:linear-gradient(180deg,#3bc2f2,#1aa1d9);border:none;font-weight:800}
  small{color:var(--muted)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}

  /* Preview */
  #stage{position:relative;border:1px dashed #ffffff33;border-radius:12px;overflow:hidden;background:#0c1333;min-height:240px;touch-action:none}
  #img{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:none;z-index:0}
  #overlay{position:absolute;inset:0;pointer-events:none;z-index:1}

  .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:12px}
  .pill{display:inline-block;padding:.2rem .6rem;border-radius:999px;background:#ffffff24;font-size:12px}

  .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:6px;margin:10px 0}
  .slot{background:#0f1738;border:1px solid #ffffff24;aspect-ratio:3/5;border-radius:8px;position:relative}
  .slot span{position:absolute;inset:auto 6px 6px 6px;font-size:12px;color:#9ab0ff}
  .slot.present{outline:2px solid rgba(0,200,0,.85); background:linear-gradient(transparent, rgba(0,200,0,.18))}
  .slot.empty{outline:2px solid rgba(255,0,0,.85); background:linear-gradient(transparent, rgba(255,0,0,.18))}

  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid #ffffff1f;padding:10px 6px;text-align:left}
  tr.missing{background:#ff50501a}
  tr.ok{opacity:.95}

  @media (max-width: 900px){
    main{grid-template-columns:1fr}
    header{font-size:18px}
    .row{grid-template-columns:1fr}
  }
</style>
</head>
<body>
<header>ðŸ“± Phone Box â€” rectangles above each number (12Ã—5)</header>

<main>
  <section class="card" id="left">
    <div id="stage">
      <img id="img" alt="preview">
      <canvas id="overlay"></canvas>
    </div>

    <div class="toolbar">
      <span class="pill" id="status"></span>
    </div>

    <div class="grid" id="boxGrid"></div>

    <table>
      <thead><tr><th>Slot</th><th>Expected</th><th>Status</th></tr></thead>
      <tbody id="results"></tbody>
    </table>
  </section>

  <section class="card">
    <label>Box</label>
    <select id="box"></select>

    <label style="margin-top:10px">Roster CSV (auto-loads /data/roster.csv)</label>
    <div class="row" style="align-items:end">
      <small id="rosterStatus">Loadingâ€¦</small>
      <input id="rosterFile" type="file" accept=".csv">
    </div>

    <label style="margin-top:10px">Upload a box photo</label>
    <input id="photo" type="file" accept="image/*" capture="environment">

    <div class="row" style="margin-top:10px">
      <div>
        <label>Edge crop % (ignore left/right)</label>
        <input id="edgePct" type="range" min="0" max="15" step="1" value="5">
      </div>
      <div>
        <label>Blue sensitivity</label>
        <input id="blueSens" type="range" min="10" max="90" step="5" value="45">
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <div>
        <label>Row height % (area ABOVE blue strip)</label>
        <input id="rowPct" type="range" min="50" max="95" step="5" value="70">
      </div>
      <div>
        <label>Guide opacity</label>
        <input id="guideAlpha" type="range" min="20" max="100" step="5" value="90">
      </div>
    </div>

    <div class="toolbar">
      <button id="auto" class="primary">Auto Align</button>
      <button id="tapRows">Quick Tap Rows</button>
      <button id="resetRows">Reset</button>
      <button id="analyze" disabled>Colorize + Compare</button>
      <label><input id="showGuides" type="checkbox" checked> Show guides</label>
    </div>
  </section>
</main>

<script>
/* ---------- Elements & helpers ---------- */
const img = document.getElementById('img');
const stage = document.getElementById('stage');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');

const statusEl = document.getElementById('status');
const boxSel = document.getElementById('box');
const rosterFile = document.getElementById('rosterFile');
const rosterStatus = document.getElementById('rosterStatus');
const resultsBody = document.getElementById('results');
const boxGrid = document.getElementById('boxGrid');

const photo = document.getElementById('photo');
const autoBtn = document.getElementById('auto');
const tapRowsBtn = document.getElementById('tapRows');
const resetBtn = document.getElementById('resetRows');
const analyzeBtn = document.getElementById('analyze');
const showGuidesEl = document.getElementById('showGuides');

const edgePctEl = document.getElementById('edgePct');
const blueSensEl = document.getElementById('blueSens');
const rowPctEl = document.getElementById('rowPct');
const guideAlphaEl = document.getElementById('guideAlpha');

const guideAlpha = ()=> +guideAlphaEl.value/100;
const edgeCrop   = ()=> +edgePctEl.value/100;
const blueSens   = ()=> +blueSensEl.value/100;
const rowHeight  = ()=> +rowPctEl.value/100;

const setStatus = t => statusEl.textContent=t||'';

/* ---------- State ---------- */
let current=null;          // {image,W,H}
let roster=[];
let rowBottoms=[];         // y of top edge of blue bar (row bottom)
let boundsByRow=[];        // 13 x's per row
let rois=[];               // 60 rects
let occMask=[];            // booleans
let quickTap=false, quickYs=[];

/* ---------- Boxes ---------- */
(function fillBoxes(){
  const ids=[], grades=['9','10','11','12'], letters=['A','B','C','D','E','F'];
  grades.forEach(g=>letters.forEach(l=>ids.push(g+l))); ids.push('SM1','SM2');
  boxSel.innerHTML = ids.map(x=>`<option>${x}</option>`).join('');
})();

/* ---------- CSV ---------- */
function parseCSV(text){
  const rows=[]; let row=[], cur='', inQ=false; const push=()=>{row.push(cur);cur='';};
  for(let i=0;i<text.length;i++){
    const ch=text[i], nx=text[i+1];
    if(inQ){ if(ch==='"'&&nx==='"'){cur+='"';i++;} else if(ch==='"'){inQ=false;} else cur+=ch; }
    else{ if(ch==='"') inQ=true; else if(ch===',') push();
      else if(ch==='\n'||ch==='\r'){ if(ch==='\r'&&nx==='\n') i++; push(); rows.push(row); row=[]; }
      else cur+=ch; }
  } push(); if(row.length) rows.push(row);
  const header = rows.shift().map(h=>h.trim());
  return rows.filter(r=>r.some(x=>x&&x.trim()!=='')).map(r=>{const o={}; header.forEach((h,i)=>o[h]=r[i]||''); return o;});
}
async function loadRoster(){
  rosterStatus.textContent='Loading /data/roster.csvâ€¦';
  try{
    const res = await fetch('/data/roster.csv',{cache:'no-store'});
    if(res.ok){
      roster=parseCSV(await res.text());
      rosterStatus.textContent='Loaded /data/roster.csv âœ“';
      return;
    }
  }catch{}
  rosterStatus.textContent='Could not load /data/roster.csv (upload below).';
}
loadRoster();
rosterFile.addEventListener('change', ()=>{
  const f=rosterFile.files[0]; if(!f) return;
  const r=new FileReader();
  r.onload=()=>{ roster=parseCSV(r.result||''); rosterStatus.textContent='Loaded from file âœ“'; };
  r.readAsText(f);
});
function namesForBox(boxId){
  const out={};
  for(const r of roster){
    const sec=(r['Security Number']||r['SecurityNumber']||'').toUpperCase().replace(/\s+/g,'');
    const m=sec.match(/^(SM\d|\d{1,2}[A-F])[- ]?(\d{1,2})$/);
    if(!m) continue; const box=m[1], slot=+m[2];
    if(box===boxId) out[slot]=r['Full Name']||r['FullName']||'';
  }
  return out;
}

/* ---------- UI ---------- */
photo.addEventListener('change', e=>{
  const f=e.target.files[0]; if(!f) return;
  const url=URL.createObjectURL(f);
  const im=new Image();
  im.onload=()=>{ current={image:im,W:im.naturalWidth,H:im.naturalHeight}; img.src=url; img.style.display='block'; sizeStage(); draw(); setStatus('Photo loaded. Tap Auto Align.'); };
  im.onerror=()=>setStatus('Could not load image.');
  im.src=url;
});
window.addEventListener('resize', sizeStage);
function sizeStage(){
  if(!current) return;
  const W=stage.clientWidth;
  const H=Math.max(240,Math.round(W*(current.H/current.W)));
  stage.style.height=H+'px'; overlay.width=W; overlay.height=H;
}

/* ---------- Buttons ---------- */
autoBtn.addEventListener('click', async ()=>{
  if(!current) return alert('Upload a photo first.');
  analyzeBtn.disabled=true;
  setStatus('Detecting blue stripsâ€¦');
  rowBottoms = await findBlueStrips(current.image, edgeCrop(), blueSens());
  if(rowBottoms.length!==5){ setStatus('Could not auto-detect 5 strips. Use Quick Tap Rows (tap each strip once).'); draw(); return; }
  await buildWallsAndROIs();
});
tapRowsBtn.addEventListener('click', ()=>{ if(!current) return alert('Upload a photo first.'); quickTap=true; quickYs=[]; setStatus('Tap each blue strip once (5 taps)â€¦'); });
resetBtn.addEventListener('click', ()=>{ rowBottoms=[]; boundsByRow=[]; rois=[]; occMask=[]; draw(); setStatus('Reset.'); });

analyzeBtn.addEventListener('click', ()=>{
  if(!rois.length) return alert('Align rows first.');
  occMask = rois.map(r => slotOccupied(cropROI(r)));
  paintOverlay();
  const names = namesForBox(boxSel.value||'');
  resultsBody.innerHTML='';
  for(let i=0;i<60;i++){
    const slot=i+1, expected=names[slot]||'';
    const status = occMask[i] ? (expected?'present':'unexpected phone') : (expected?'missing':'empty');
    const tr=document.createElement('tr');
    tr.className = status==='missing'?'missing':(status==='present'?'ok':'');
    tr.innerHTML=`<td>${slot}</td><td>${expected}</td><td><span class="pill">${status}</span></td>`;
    resultsBody.appendChild(tr);
  }
  // tiny grid tint
  [...boxGrid.children].forEach((d,i)=>{ d.classList.remove('present','empty'); d.classList.add(occMask[i]?'present':'empty'); });
  setStatus('Colorized: green=phone, red=empty.');
});
stage.addEventListener('pointerdown', async (e)=>{
  if(!quickTap||!current) return;
  const {iy}=screenToImage(e.clientX,e.clientY);
  quickYs.push(iy); drawTapLine(iy);
  if(quickYs.length===5){ quickTap=false; rowBottoms=quickYs.slice().sort((a,b)=>a-b); await buildWallsAndROIs(); }
});

/* ---------- Core pipeline ---------- */
async function buildWallsAndROIs(){
  boundsByRow=[]; rois=[];
  for(const yBottom of rowBottoms){
    // 1) find blue band interior (xL..xR) for the row
    const {xL,xR} = await blueBandBounds(current.image, yBottom, edgeCrop(), blueSens());
    // 2) split into 12 equal columns â†’ 13 walls; then refine start  Â±period*0.25 to hit the white ticks
    let walls = split12WithRefine(current.image, yBottom, xL, xR);
    if(walls.length!==13){ // absolute fallback to equal split
      const per=(xR-xL)/12; walls=[...Array(13)].map((_,k)=>Math.round(xL+k*per));
    }
    boundsByRow.push(walls);
  }
  // 3) ROIs ABOVE the blue strip
  const gaps=[]; for(let i=1;i<rowBottoms.length;i++) gaps.push(rowBottoms[i]-rowBottoms[i-1]);
  const avgGap = gaps.length?gaps.reduce((a,b)=>a+b,0)/gaps.length: Math.round(current.H/6);
  rois=[];
  for(let r=0;r<5;r++){
    const yBottom=rowBottoms[r];
    const yTop = Math.max(0, yBottom - Math.max(12, Math.round(avgGap*rowHeight())));
    const w=boundsByRow[r];
    for(let i=0;i<12;i++){ rois.push({x:w[i], y:yTop, w:Math.max(1,w[i+1]-w[i]), h:Math.max(8,yBottom-yTop), row:r, col:i}); }
  }
  draw(); analyzeBtn.disabled=false; setStatus('Aligned to numbers (12 equal columns). Tap â€œColorize + Compareâ€.');
}

/* ---------- Row detection: blue bars (row bottoms) ---------- */
async function findBlueStrips(imgEl, edge, sens){
  const maxW=1600, r=Math.min(1,maxW/imgEl.naturalWidth);
  const W=Math.round(imgEl.naturalWidth*r), H=Math.round(imgEl.naturalHeight*r);
  const c=document.createElement('canvas'); c.width=W; c.height=H; const g=c.getContext('2d');
  g.drawImage(imgEl,0,0,W,H); const {data}=g.getImageData(0,0,W,H);
  const x0=Math.round(W*edge), x1=Math.round(W*(1-edge));
  const hueMin=190,hueMax=265;

  const score=new Float32Array(H);
  for(let y=0;y<H;y++){
    let b=0,cnt=0;
    for(let x=x0;x<=x1;x+=2){
      const i=(y*W+x)*4, r0=data[i],g0=data[i+1],b0=data[i+2];
      const {h,s,v}=rgb2hsv(r0,g0,b0);
      if(h>hueMin&&h<hueMax&&s>(0.18+0.5*sens)&&v>(0.22+0.3*sens)) b++;
      cnt++;
    }
    score[y]=cnt?b/cnt:0;
  }
  const s2=smooth(score,6);
  const peaks=pickSpread(peaksAbove(s2,0.35),5,Math.round(H/7));
  const rows = peaks.slice(0,5).sort((a,b)=>a-b).map(p=>Math.round(p/r));
  return rows;
}

/* ---------- Blue band bounds per row ---------- */
async function blueBandBounds(imgEl, yBottom, edge, sens){
  const maxW=1600, r=Math.min(1,maxW/imgEl.naturalWidth);
  const W=Math.round(imgEl.naturalWidth*r), H=Math.round(imgEl.naturalHeight*r);
  const c=document.createElement('canvas'); c.width=W; c.height=H; const g=c.getContext('2d');
  g.drawImage(imgEl,0,0,W,H); const {data}=g.getImageData(0,0,W,H);

  const L=Math.round(W*edge), R=Math.round(W*(1-edge));
  const bandH=Math.max(8,Math.round(H*0.018));
  const y0=Math.min(H-2, Math.round(yBottom*r)+2), y1=Math.min(H-1, y0+bandH);
  const hueMin=190,hueMax=265, sMin=0.18+0.3*sens, vMin=0.22+0.2*sens;

  const blue=new Float32Array(W).fill(0);
  for(let x=L;x<=R;x++){
    let cnt=0, b=0;
    for(let y=y0;y<=y1;y++){
      const i=(y*W+x)*4, rr=data[i],gg=data[i+1],bb=data[i+2];
      const {h,s,v}=rgb2hsv(rr,gg,bb);
      if(h>hueMin&&h<hueMax&&s>sMin&&v>vMin) b++;
      cnt++;
    }
    blue[x]=cnt?b/cnt:0;
  }
  const sb=smooth(blue,4);
  const thr = 0.35*Math.max(...sb);
  let xL=L, xR=R;
  for(let x=L;x<=R;x++){ if(sb[x]>thr){ xL=x; break; } }
  for(let x=R;x>=L;x--){ if(sb[x]>thr){ xR=x; break; } }
  // pad inwards a touch to skip frame bleed
  const pad=Math.round((xR-xL)*0.01);
  xL+=pad; xR-=pad;
  // fallbacks
  if(xR-xL<50){ xL=L; xR=R; }
  const scaleX=imgEl.naturalWidth/W;
  return {xL:Math.round(xL*scaleX), xR:Math.round(xR*scaleX)};
}

/* ---------- Split 12 + refine to white ticks ---------- */
function split12WithRefine(imgEl, yBottom, xL, xR){
  const per=(xR-xL)/12;
  const startCandidates=[];
  const delta=per*0.25; // Â±25% period
  for(let s=xL-delta; s<=xL+delta; s+=Math.max(1, per/40)){
    startCandidates.push(s);
  }
  const bestStart = scoreStartOnWhite(imgEl, yBottom, startCandidates, per);
  if(bestStart==null) return [];
  const walls=[...Array(13)].map((_,k)=>Math.round(bestStart+k*per));
  return walls;
}
function scoreStartOnWhite(imgEl, yBottom, starts, per){
  const maxW=1600, r=Math.min(1,maxW/imgEl.naturalWidth);
  const W=Math.round(imgEl.naturalWidth*r), H=Math.round(imgEl.naturalHeight*r);
  const c=document.createElement('canvas'); c.width=W; c.height=H; const g=c.getContext('2d');
  g.drawImage(imgEl,0,0,W,H); const im=g.getImageData(0,0,W,H), data=im.data;
  const band= Math.max(8,Math.round(H*0.018));
  const y0=Math.min(H-2, Math.round(yBottom*r)+2), y1=Math.min(H-1, y0+band);

  let best=null, bestScore=-1;
  for(const s0 of starts){
    const s = s0*r; const p = per*r;
    let sum=0;
    for(let k=0;k<=12;k++){
      const x=Math.round(s+k*p); if(x<0||x>=W) continue;
      // whiteness at this column within the blue band
      let sc=0, cnt=0;
      for(let y=y0;y<=y1;y++){
        const i=(y*W+x)*4, rr=data[i],gg=data[i+1],bb=data[i+2];
        const {s:sat,v}=rgb2hsv(rr,gg,bb);
        if(v>0.72 && sat<0.35) sc++; // light / white
        cnt++;
      }
      sum += cnt?sc/cnt:0;
    }
    if(sum>bestScore){ bestScore=sum; best=s0; }
  }
  return best;
}

/* ---------- Occupancy ---------- */
function cropROI(r){ const c=document.createElement('canvas'); c.width=r.w; c.height=r.h; c.getContext('2d').drawImage(current.image,r.x,r.y,r.w,r.h,0,0,r.w,r.h); return c; }
function slotOccupied(c){
  const k=c.getContext('2d');
  const cx=Math.round(c.width*0.18), cw=Math.round(c.width*0.64);
  const cy=Math.round(c.height*0.15), ch=Math.round(c.height*0.60);
  const {data}=k.getImageData(cx,cy,cw,ch);
  const cols=new Float32Array(cw).fill(0); const dark=130;
  for(let y=0;y<ch;y++){ for(let x=0;x<cw;x++){ const i=(y*cw+x)*4; const L=0.299*data[i]+0.587*data[i+1]+0.114*data[i+2]; if(L<dark) cols[x]++; } }
  for(let x=0;x<cw;x++) cols[x]/=ch;
  let best=0,run=0; for(let x=0;x<cw;x++){ if(cols[x]>0.45){ run++; best=Math.max(best,run);} else run=0; }
  return best>=Math.round(cw*0.22);
}

/* ---------- Drawing ---------- */
function draw(){
  ctx.clearRect(0,0,overlay.width,overlay.height); if(!current) return;
  const sx=overlay.width/current.W, sy=overlay.height/current.H, a=guideAlpha();

  if(showGuidesEl.checked){
    // Cyan lines at blue-strip tops (row bottoms)
    ctx.strokeStyle=`rgba(50,208,255,${a})`; ctx.lineWidth=2;
    for(const y of rowBottoms){ ctx.beginPath(); ctx.moveTo(0,y*sy); ctx.lineTo(overlay.width,y*sy); ctx.stroke(); }
    // White vertical walls
    ctx.strokeStyle=`rgba(255,255,255,${a})`; ctx.lineWidth=1.6;
    for(const w of boundsByRow){ (w||[]).forEach(x=>{ const xx=x*sx; ctx.beginPath(); ctx.moveTo(xx,0); ctx.lineTo(xx,overlay.height); ctx.stroke(); }); }
  }
  if(rois.length){ ctx.strokeStyle='rgba(255,255,255,.95)'; ctx.lineWidth=2; for(const r of rois){ ctx.strokeRect(r.x*sx, r.y*sy, r.w*sx, r.h*sy); } }
}
function paintOverlay(){
  if(!rois.length) return;
  const sx=overlay.width/current.W, sy=overlay.height/current.H;
  ctx.clearRect(0,0,overlay.width,overlay.height);
  for(let i=0;i<rois.length;i++){
    const r=rois[i]; ctx.fillStyle = occMask[i] ? 'rgba(0,200,0,.35)' : 'rgba(255,0,0,.35)';
    ctx.fillRect(r.x*sx, r.y*sy, r.w*sx, r.h*sy);
  }
  if(showGuidesEl.checked){
    ctx.strokeStyle='rgba(255,255,255,.9)'; ctx.lineWidth=1.5;
    for(const r of rois){ ctx.strokeRect(r.x*sx, r.y*sy, r.w*sx, r.h*sy); }
  }
}

/* ---------- Utilities ---------- */
function rgb2hsv(r,g,b){ r/=255; g/=255; b/=255; const max=Math.max(r,g,b),min=Math.min(r,g,b),d=max-min; let h=0; if(d!==0){ if(max===r) h=((g-b)/d)%6; else if(max===g) h=(b-r)/d+2; else h=(r-g)/d+4; h*=60; if(h<0)h+=360; } const s=max===0?0:d/max, v=max; return {h,s,v}; }
function smooth(a,w){const o=new Float32Array(a.length); for(let i=0;i<a.length;i++){let s=0,c=0; for(let k=-w;k<=w;k++){const j=i+k; if(j<0||j>=a.length) continue; s+=a[j]; c++;} o[i]=s/c;} return o;}
function peaksAbove(series, frac){ const m=Math.max(...series); const out=[]; if(!m) return out; for(let y=1;y<series.length-1;y++){ if(series[y]>=frac*m && series[y]>=series[y-1] && series[y]>=series[y+1]) out.push(y);} return out; }
function pickSpread(peaks, need, minDist){ const out=[]; for(const p of peaks){ if(out.every(q=>Math.abs(q-p)>minDist)) out.push(p); if(out.length>=need) break; } return out.sort((a,b)=>a-b); }
function screenToImage(cx,cy){ const r=overlay.getBoundingClientRect(); const x=(cx-r.left)/r.width*current.W; const y=(cy-r.top)/r.height*current.H; return {ix:x, iy:y}; }
function drawTapLine(yImg){ const sy=overlay.height/current.H, y=yImg*sy; ctx.save(); ctx.strokeStyle='rgba(50,208,255,.9)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(overlay.width,y); ctx.stroke(); ctx.restore(); }

/* ---------- Stage taps to set rows ---------- */
stage.addEventListener('pointerdown', e=>{
  if(!quickTap||!current) return;
});

/* ---------- Boot ---------- */
(function initGrid(){ boxGrid.innerHTML=''; for(let r=0;r<5;r++){ for(let c=0;c<12;c++){ const d=document.createElement('div'); d.className='slot'; const s=document.createElement('span'); s.textContent=`#${r*12+c+1}`; d.appendChild(s); boxGrid.appendChild(d);} }})();
</script>
</body>
</html>
