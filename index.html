<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Phone Box Checker — Blue‑Bar Anchored + Roster Missing</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .card{ background:#fff; border-radius:1rem; box-shadow:0 4px 20px rgba(0,0,0,.08); padding:1rem; }
    .btn{ padding:.5rem .75rem; border:1px solid #ddd; border-radius:1rem; }
    .btn-primary{ background:#111827; color:#fff; border-color:#111827; }
    .overlay-wrap{ position:relative; }
    .overlay-canvas{ position:absolute; left:0; top:0; pointer-events:none; }
    .small{ font-size:.85rem; color:#6b7280; }
    .slider{ width:160px; }
  </style>
  <!-- Roster CSV -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <!-- React -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- OpenCV (stable CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@techstark/opencv-js@4.10.0/build/opencv.js"></script>
</head>
<body class="min-h-screen bg-gray-50 text-gray-900">
  <div id="root" class="p-4 sm:p-6"></div>

  <script>
  const { useEffect, useRef, useState, useMemo } = React;

  // ===== Roster helpers =====
  function parseSecurityNumber(sn=''){
    const s=String(sn).trim().toUpperCase(); if(!s) return null;
    let m=s.match(/^\s*(SM\d+)\s*[- ]?\s*(\d{1,2})\s*$/); if(m) return {box:m[1], slot:parseInt(m[2],10)};
    m=s.match(/^(.*?)(\d{1,2})$/); if(!m) return null; const box=m[1]; const slot=parseInt(m[2],10); if(!(slot>=1 && slot<=60)) return null; return {box,slot};
  }
  function uniqueBoxes(roster){ const set=new Set(); roster.forEach(r=>{ const p=parseSecurityNumber(r.securityNumber); if(p) set.add(p.box); }); return Array.from(set).sort((a,b)=> a.localeCompare(b,undefined,{numeric:true})); }

  // ===== Vision utils =====
  function robustThreshold(values){
    const a=[...values].sort((x,y)=>x-y); const n=a.length; if(!n) return 0.02;
    const med=n%2? a[(n-1)/2] : (a[n/2-1]+a[n/2])/2;
    const ad=a.map(v=>Math.abs(v-med)).sort((x,y)=>x-y);
    const mad=n%2? ad[(n-1)/2] : (ad[n/2-1]+ad[n/2])/2;
    let t=med+1.5*mad; if(!isFinite(t)||t<=0) t=med*1.25+0.003; return Math.min(Math.max(t, med*1.05), med+0.05);
  }

  // Detect blue number bars (HSV) and horizontal column centers; synthesize missing rows if needed.
  function detectBarsAndColumns(cv, src, W, H, hsvRange){
    const hsv=new cv.Mat(); cv.cvtColor(src,hsv,cv.COLOR_RGBA2HSV);
    const low=new cv.Mat(hsv.rows,hsv.cols,hsv.type(), [hsvRange.hMin, hsvRange.sMin, hsvRange.vMin, 0]);
    const high=new cv.Mat(hsv.rows,hsv.cols,hsv.type(), [hsvRange.hMax, 255, 255, 255]);
    const mask=new cv.Mat(); cv.inRange(hsv, low, high, mask);
    const k=cv.Mat.ones(3,3,cv.CV_8U); cv.morphologyEx(mask, mask, cv.MORPH_OPEN, k); cv.morphologyEx(mask, mask, cv.MORPH_CLOSE, k);

    const contours=new cv.MatVector(); const hier=new cv.Mat(); cv.findContours(mask, contours, hier, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
    let bars=[]; for(let i=0;i<contours.size();i++){ const r=cv.boundingRect(contours.get(i)); const ar=r.width/(r.height+1e-6); if(r.width>W*0.5 && r.height>H*0.01 && r.height<H*0.12 && ar>4){ bars.push(r); } }
    bars.sort((a,b)=> a.y-b.y);
    const merged=[]; const tol=H*0.02; for(const r of bars){ if(!merged.length || Math.abs(r.y-merged[merged.length-1].y)>tol){ merged.push(r); } }
    let barsY = merged.map(b=> b.y + b.height/2);

    // Synthesize missing rows so we always have 5
    if(barsY.length && barsY.length<5){ const diffs=[]; for(let i=1;i<barsY.length;i++) diffs.push(barsY[i]-barsY[i-1]); const step = diffs.length? diffs.sort((a,b)=>a-b)[Math.floor(diffs.length/2)] : (H/5); while(barsY.length<5){ barsY.push(Math.min(H-10, barsY[barsY.length-1]+step)); } }
    if(barsY.length===0){ // fallback to 5 equal rows
      barsY = Array.from({length:5}, (_,i)=> (i+1)*H/6);
    }

    // Column centers from the strongest bar (most blue patches)
    let refCenters=[]; let bestCount=0;
    for(const bar of merged){
      const roi=mask.roi(bar); const cts=new cv.MatVector(); const hh=new cv.Mat(); cv.findContours(roi, cts, hh, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
      let centers=[]; for(let i=0;i<cts.size();i++){ const br=cv.boundingRect(cts.get(i)); const ar=br.width/(br.height+1e-6); if(br.width>W*0.015 && br.width<W*0.2 && br.height>H*0.01 && ar>1){ centers.push(bar.x+br.x+br.width/2); } }
      centers.sort((a,b)=>a-b); const uniq=[]; const minDx=W*0.02; centers.forEach(x=>{ if(!uniq.length || Math.abs(x-uniq[uniq.length-1])>minDx) uniq.push(x); });
      if(uniq.length>bestCount){ refCenters=uniq; bestCount=uniq.length; }
      roi.delete(); cts.delete(); hh.delete();
    }
    if(refCenters.length<10){ const cols=12; const step=W/cols; refCenters = Array.from({length:cols}, (_,i)=> (i+0.5)*step); }

    hsv.delete(); low.delete(); high.delete(); mask.delete(); contours.delete(); hier.delete(); k.delete();
    return { barsY, colCenters: refCenters };
  }

  function buildSlotsFromBars(W, H, barsY, colCenters, bandPct=0.22, marginPct=0.06){
    const cols=12; const centers=colCenters.slice(0,cols);
    const bounds=[ centers[0] - (centers[1]-centers[0])/2 ];
    for(let i=0;i<centers.length-1;i++){ bounds.push( (centers[i]+centers[i+1])/2 ); }
    bounds.push( centers[centers.length-1] + (centers[centers.length-1]-centers[centers.length-2])/2 );

    const slots=[]; const bands=[];
    for(let r=0;r<5;r++){
      const barY = barsY[Math.min(r, barsY.length-1)];
      const rh = r<barsY.length-1? (barsY[r+1]-barsY[r]) : (barsY[r]- (barsY[r-1]|| (barsY[r]-H/5)) );
      const rowH = Math.max(H*0.12, Math.min(H*0.28, Math.abs(rh)));
      const bandH = Math.max(8, rowH*bandPct);
      const bodyH = Math.max(30, rowH*0.65);
      const bandY = Math.max(0, Math.min(H-10, barY - bandH - rowH*marginPct));
      const bodyYTop = Math.max(0, Math.min(H-10, barY - bodyH - rowH*0.10));
      for(let c=0;c<cols;c++){
        const x0=bounds[c], x1=bounds[c+1]; const w=Math.max(10, x1-x0);
        slots.push({ x: x0+Math.floor(w*0.08), y: bodyYTop, w: Math.floor(w*0.84), h: Math.floor(bodyH), present:false });
        bands.push({ x: x0+Math.floor(w*0.10), y: bandY, w: Math.floor(w*0.80), h: Math.floor(Math.min(bandH, rowH*0.35)) });
      }
    }
    return { slots, bands };
  }

  function drawOverlay(imgEl, overlayCanvas, W, H, slots, bands){
    const ov=overlayCanvas; const dispW=imgEl.clientWidth, dispH=imgEl.clientHeight; ov.width=dispW; ov.height=dispH;
    const sx=dispW/W, sy=dispH/H; const ctx=ov.getContext('2d'); ctx.clearRect(0,0,ov.width,ov.height);
    ctx.lineWidth=2; ctx.font='10px sans-serif'; ctx.textBaseline='top';
    slots.forEach((s,i)=>{ const px=s.x*sx, py=s.y*sy, pw=s.w*sx, ph=s.h*sy; ctx.strokeStyle = s.present? 'rgba(0,180,0,0.95)' : 'rgba(220,20,60,0.95)'; ctx.strokeRect(px,py,pw,ph); const pillW=20, pillH=12; ctx.fillStyle = s.present? 'rgba(0,180,0,0.95)' : 'rgba(220,20,60,0.95)'; ctx.fillRect(px+2,py+2,pillW,pillH); ctx.fillStyle='#fff'; ctx.fillText(String(i+1), px+6, py+3); });
    const yctx=ctx; yctx.strokeStyle='rgba(240,200,0,0.95)'; bands.forEach(b=>{ yctx.strokeRect(b.x*sx, b.y*sy, b.w*sx, b.h*sy); });
  }

  function App(){
    // Roster
    const [roster,setRoster]=useState([]);
    const [box,setBox]=useState('');

    // Vision params
    const [hsvRange,setHsvRange]=useState({ hMin:100, hMax:135, sMin:60, vMin:50 });
    const [bandPct,setBandPct]=useState(0.22);
    const [marginPct,setMarginPct]=useState(0.06);

    // UI state
    const [imageURL,setImageURL]=useState(null);
    const [busy,setBusy]=useState(false);
    const [stats,setStats]=useState(null);
    const [missing,setMissing]=useState([]);

    const imgRef=useRef(null); const workRef=useRef(null); const overlayRef=useRef(null);

    // Load roster.csv automatically if present
    useEffect(()=>{ (async()=>{ try{ const res=await fetch('roster.csv',{cache:'no-store'}); if(res.ok){ const text=await res.text(); const parsed=Papa.parse(text,{header:true,skipEmptyLines:true}); const rows=parsed.data.map(r=>({ personId:String(r['Person ID']||r.personId||'').trim(), fullName:String(r['Full Name']||r.fullName||'').trim(), securityNumber:String(r['Security Number']||r.securityNumber||'').trim(), grade:String(r['Current Grade']||r.grade||'').trim(), email:String(r['Email 1']||r.email||'').trim() })).filter(r=>r.personId && r.fullName); if(rows.length) setRoster(rows); } }catch(e){} })(); },[]);

    const boxes = useMemo(()=> uniqueBoxes(roster), [roster]);
    const onUploadCSV=(file)=>{ Papa.parse(file,{header:true,skipEmptyLines:true,complete:(res)=>{ const rows=res.data.map(r=>({ personId:String(r['Person ID']||'').trim(), fullName:String(r['Full Name']||'').trim(), securityNumber:String(r['Security Number']||'').trim(), grade:String(r['Current Grade']||'').trim(), email:String(r['Email 1']||'').trim() })).filter(r=>r.personId && r.fullName); setRoster(rows); }}); };
    const onPhoto=(file)=>{ setImageURL(URL.createObjectURL(file)); setMissing([]); setStats(null); };

    const analyze=()=>{
      if(!imageURL){ alert('Add a photo first.'); return; }
      if(!window.cv){ alert('OpenCV not ready yet.'); return; }
      if(!box){ alert('Pick a box from roster (e.g., 9B, 10A, SM1) so we can name missing students.'); }
      setBusy(true);
      setTimeout(()=>{ try{ runAnalysis(); } finally{ setBusy(false); } }, 10);
    };

    function runAnalysis(){
      const img=imgRef.current; const work=workRef.current; const W0=img.naturalWidth, H0=img.naturalHeight; work.width=W0; work.height=H0; const ctx=work.getContext('2d'); ctx.drawImage(img,0,0,W0,H0);
      const cv=window.cv; const src=cv.imread(work); const W=src.cols, H=src.rows;

      const { barsY, colCenters } = detectBarsAndColumns(cv, src, W, H, hsvRange);
      const { slots, bands } = buildSlotsFromBars(W, H, barsY, colCenters, bandPct, marginPct);

      // Presence
      const densities=[]; const densitiesBottom=[];
      for(let i=0;i<slots.length;i++){
        const s=slots[i]; const b=bands[i];
        const roi1=new cv.Rect(s.x, s.y, s.w, s.h); const mat1=src.roi(roi1); const g1=new cv.Mat(); cv.cvtColor(mat1,g1,cv.COLOR_RGBA2GRAY); const bl1=new cv.Mat(); cv.GaussianBlur(g1,bl1,new cv.Size(5,5),0,0,cv.BORDER_DEFAULT); const e1=new cv.Mat(); cv.Canny(bl1,e1,35,120); densities.push(cv.countNonZero(e1)/(s.w*s.h)); g1.delete(); bl1.delete(); e1.delete(); mat1.delete();
        const roi2=new cv.Rect(b.x, b.y, b.w, b.h); const mat2=src.roi(roi2); const g2=new cv.Mat(); cv.cvtColor(mat2,g2,cv.COLOR_RGBA2GRAY); const bl2=new cv.Mat(); cv.GaussianBlur(g2,bl2,new cv.Size(3,3),0,0,cv.BORDER_DEFAULT); const e2=new cv.Mat(); cv.Canny(bl2,e2,30,100); densitiesBottom.push(cv.countNonZero(e2)/(b.w*b.h)); g2.delete(); bl2.delete(); e2.delete(); mat2.delete();
      }
      const thrFull=robustThreshold(densities); const thrBottom=robustThreshold(densitiesBottom);
      for(let i=0;i<slots.length;i++){ slots[i].present = (densitiesBottom[i]>thrBottom) || (densities[i]>thrFull); }

      // Overlay
      drawOverlay(imgRef.current, overlayRef.current, W, H, slots, bands);

      // Map to missing names (if a box is chosen)
      let missingList=[]; if(box){
        const occupied=new Set(); for(let i=0;i<slots.length;i++) if(slots[i].present) occupied.add(i+1); // slot numbers 1..60
        const group = roster.filter(r=>{ const p=parseSecurityNumber(r.securityNumber); return p && p.box===box; });
        missingList = group.filter(stu=>{ const p=parseSecurityNumber(stu.securityNumber); return p && !occupied.has(p.slot); });
      }

      setMissing(missingList);
      setStats({ rowsUsed:5, barsDetected:barsY.length, columns:colCenters.length, thrFull, thrBottom, present: slots.filter(s=>s.present).length });
      src.delete();
    }

    return React.createElement('div',{className:'max-w-6xl mx-auto space-y-4'},[
      React.createElement('div',{className:'card'},[
        React.createElement('h1',{className:'text-2xl font-bold'},'Phone Box Checker — Blue‑Bar Anchored + Roster Missing'),
        React.createElement('p',{className:'small'},'We anchor rows on the blue number bars and columns on blue patches; then we detect each slot and cross‑reference with your roster to list *who* is missing. No corner taps needed.')
      ]),

      React.createElement('div',{className:'card'},[
        React.createElement('div',{className:'flex flex-wrap items-center gap-3 text-sm'},[
          React.createElement('label',{className:'btn'},['Upload roster.csv', React.createElement('input',{type:'file',accept:'.csv',className:'hidden',onChange:e=>{ const f=e.target.files?.[0]; if(f) onUploadCSV(f); }})]),
          React.createElement('a',{className:'btn',href:'roster.csv',download:true},'Download current roster.csv'),
          React.createElement('div',{className:'small'},`Roster loaded: ${roster.length} rows`),
          React.createElement('label',{className:'flex items-center gap-2'},[
            React.createElement('span',{className:'small'},'Box'),
            React.createElement('select',{className:'border rounded px-2 py-1',value:box,onChange:e=>setBox(e.target.value)}, [ React.createElement('option',{key:'',value:''},'— Pick —'), ...boxes.map(b=> React.createElement('option',{key:b,value:b},b)) ])
          ])
        ])
      ]),

      React.createElement('div',{className:'card'},[
        React.createElement('div',{className:'flex flex-wrap items-center gap-3 text-sm'},[
          React.createElement('label',{className:'btn'},['Take/Upload Photo', React.createElement('input',{type:'file',accept:'image/*',capture:'environment',className:'hidden',onChange:e=>{ const f=e.target.files?.[0]; if(f) onPhoto(f); }})]),
          React.createElement('div',{className:'flex items-center gap-2'},[
            React.createElement('span',{className:'small'},'Hue'),
            React.createElement('input',{className:'slider',type:'range',min:80,max:150,step:1,value:hsvRange.hMin,onChange:e=>setHsvRange({...hsvRange,hMin:parseInt(e.target.value)})}),
            React.createElement('span',{className:'small'},`${hsvRange.hMin}`),
            React.createElement('span',{className:'small ml-2'},'→'),
            React.createElement('input',{className:'slider',type:'range',min:90,max:170,step:1,value:hsvRange.hMax,onChange:e=>setHsvRange({...hsvRange,hMax:parseInt(e.target.value)})}),
            React.createElement('span',{className:'small'},`${hsvRange.hMax}`)
          ]),
          React.createElement('div',{className:'flex items-center gap-2'},[
            React.createElement('span',{className:'small'},'Sat min'),
            React.createElement('input',{className:'slider',type:'range',min:0,max:255,step:1,value:hsvRange.sMin,onChange:e=>setHsvRange({...hsvRange,sMin:parseInt(e.target.value)})}),
            React.createElement('span',{className:'small'},`${hsvRange.sMin}`)
          ]),
          React.createElement('div',{className:'flex items-center gap-2'},[
            React.createElement('span',{className:'small'},'Val min'),
            React.createElement('input',{className:'slider',type:'range',min:0,max:255,step:1,value:hsvRange.vMin,onChange:e=>setHsvRange({...hsvRange,vMin:parseInt(e.target.value)})}),
            React.createElement('span',{className:'small'},`${hsvRange.vMin}`)
          ]),
          React.createElement('div',{className:'flex items-center gap-2'},[
            React.createElement('span',{className:'small'},'Band %'),
            React.createElement('input',{className:'slider',type:'range',min:10,max:40,step:1,value:Math.round(bandPct*100),onChange:e=>setBandPct(parseInt(e.target.value)/100)}),
            React.createElement('span',{className:'small'},`${Math.round(bandPct*100)}%`)
          ]),
          React.createElement('div',{className:'flex items-center gap-2'},[
            React.createElement('span',{className:'small'},'Above‑bar margin %'),
            React.createElement('input',{className:'slider',type:'range',min:0,max:20,step:1,value:Math.round(marginPct*100),onChange:e=>setMarginPct(parseInt(e.target.value)/100)}),
            React.createElement('span',{className:'small'},`${Math.round(marginPct*100)}%`)
          ]),
          React.createElement('button',{className:'btn btn-primary',onClick:analyze,disabled:busy || !imageURL}, busy? 'Analyzing…' : 'Analyze & Show Rectangles')
        ])
      ]),

      React.createElement('div',{className:'card'},[
        React.createElement('h3',{className:'font-semibold mb-2'},'Photo + Overlay'),
        React.createElement('div',{className:'overlay-wrap'},[
          imageURL ? React.createElement('img',{ref:imgRef,src:imageURL,alt:'box',className:'w-full h-auto rounded'}) : React.createElement('div',{className:'small p-8'},'Add a photo to see slot rectangles (green/red) and the yellow bottom bands anchored to the blue number bars.'),
          React.createElement('canvas',{ref:overlayRef,className:'overlay-canvas'})
        ]),
        React.createElement('canvas',{ref:workRef,className:'hidden'})
      ]),

      (box && missing) && React.createElement('div',{className:'card'},[
        React.createElement('h3',{className:'font-semibold mb-2'},`Missing — ${box}`),
        missing.length? React.createElement('ul',{className:'list-disc list-inside text-sm'}, missing.map(stu=> React.createElement('li',{key:stu.personId}, `${stu.fullName} — ${stu.securityNumber}`))) : React.createElement('div',{className:'small text-green-700'},'No one missing (based on detected occupied slots).')
      ]),

      stats && React.createElement('div',{className:'card small'},[
        React.createElement('div',{},`Detected bars: ${stats.barsDetected}; columns: ${stats.columns}`),
        React.createElement('div',{},`Thresholds — full: ${stats.thrFull.toFixed(4)}, bottom: ${stats.thrBottom.toFixed(4)}`),
        React.createElement('div',{},`Estimated present slots: ${stats.present}`)
      ])
    ]);
  }

  ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(App));
  </script>
</body>
</html>
