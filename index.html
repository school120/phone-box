<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Phone Box ‚Äì YOLO (browser) + Manual Fallback</title>
<style>
  :root{--bg:#0b1020;--card:#10183a;--mut:#9ab0e0}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:#fff;font-family:system-ui,-apple-system,Inter,Roboto}
  header{padding:12px 16px;border-bottom:1px solid #ffffff22;font-weight:800}
  main{max-width:1200px;margin:0 auto;padding:12px;display:grid;grid-template-columns:1.2fr .8fr;gap:16px}
  .card{background:#10183a;border:1px solid #ffffff22;border-radius:16px;padding:14px}
  label{display:block;margin:8px 0 6px;color:var(--mut);font-size:14px}
  input[type=file],select,button{width:100%;padding:12px 14px;border-radius:12px;border:1px solid #ffffff33;background:#0f1738;color:#fff;font-size:16px}
  button.primary{background:linear-gradient(180deg,#37c2f2,#1aa1d9);border:none;font-weight:800}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:10px}
  .pill{display:inline-block;padding:.25rem .6rem;border-radius:999px;background:#ffffff24;font-size:12px}
  #stage{position:relative;border:1px dashed #ffffff33;border-radius:12px;overflow:hidden;background:#0c1333;min-height:260px;touch-action:none}
  #preview{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:none;z-index:0}
  #overlay{position:absolute;inset:0;pointer-events:auto;z-index:1}
  .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:6px;margin:10px 0}
  .slot{background:#0f1738;border:1px solid #ffffff24;aspect-ratio:3/5;border-radius:8px;position:relative}
  .slot.present{outline:2px solid rgba(0,200,0,.9)}
  .slot.empty{outline:2px solid rgba(255,0,0,.9)}
  .slot span{position:absolute;inset:auto 6px 6px 6px;font-size:12px;color:#9ab0ff}
  table{width:100%;border-collapse:collapse;margin-top:10px}
  th,td{border-bottom:1px solid #ffffff19;padding:8px 6px;text-align:left}
  tr.missing{background:#ff50501a}
  @media (max-width:900px){ main{grid-template-columns:1fr} }
</style>
</head>
<body>
<header>üì± Phone Box ‚Äî YOLO detector (browser) + number-strip guided slotting + Manual fallback.</header>

<main>
  <section class="card">
    <div id="stage">
      <img id="preview" alt="preview">
      <canvas id="overlay"></canvas>
    </div>
    <div class="toolbar">
      <span class="pill" id="status">Load model‚Ä¶</span>
      <span class="pill" id="modePill">Mode: Auto</span>
    </div>
    <div class="grid" id="miniGrid"></div>
    <table>
      <thead><tr><th>Slot</th><th>Expected</th><th>Status</th></tr></thead>
      <tbody id="results"></tbody>
    </table>
  </section>

  <section class="card">
    <label>Box</label>
    <select id="box"></select>

    <label>Roster CSV (auto-loads <code>data/roster.csv</code>)</label>
    <div style="display:flex;gap:8px;align-items:center">
      <small id="rosterStatus">Loading‚Ä¶</small>
      <input id="rosterFile" type="file" accept=".csv">
    </div>

    <label>Upload photo</label>
    <input id="photo" type="file" accept="image/*" capture="environment">

    <div class="toolbar">
      <button id="run" class="primary" disabled>Run YOLO (Auto)</button>
      <button id="manual">Manual fallback</button>
      <button id="analyze">Analyze</button>
      <button id="reset">Reset</button>
      <label><input id="showGuides" type="checkbox" checked> Show guides</label>
    </div>
  </section>
</main>

<!-- onnxruntime-web (WebGL/WebGPU) -->
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.19.0/dist/ort.min.js"></script>
<!-- OpenCV.js for ticks projection -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script>
/* ======= UI refs/state ======= */
const ROWS=5, COLS=12, TOTAL=ROWS*COLS;
const SLOT_H_FRAC=0.42, SLOT_TOP_PAD=0.04;

const stage=document.getElementById('stage');
const overlay=document.getElementById('overlay'); const ctx=overlay.getContext('2d');
const preview=document.getElementById('preview');
const statusEl=document.getElementById('status');
const modePill=document.getElementById('modePill');
const runBtn=document.getElementById('run');
const manualBtn=document.getElementById('manual');
const analyzeBtn=document.getElementById('analyze');
const resetBtn=document.getElementById('reset');
const photo=document.getElementById('photo');
const showGuides=document.getElementById('showGuides');
const miniGrid=document.getElementById('miniGrid');
const resultsBody=document.getElementById('results');
const rosterFile=document.getElementById('rosterFile');
const rosterStatus=document.getElementById('rosterStatus');
const boxSel=document.getElementById('box');

let session=null, current=null;
let rois=[], rowY=[], wallsPerRow=[], occ=[];
let manual=false, cvReady=false, roster=[];

window.Module = { onRuntimeInitialized(){ cvReady=true; } };

function setStatus(t){ statusEl.textContent=t; }
function sizeOverlayToImage(w,h){
  const sw=stage.clientWidth, sh=Math.max(260, Math.round(sw*(h/w)));
  stage.style.height=sh+'px';
  const dpr=window.devicePixelRatio||1;
  overlay.width=Math.round(sw*dpr); overlay.height=Math.round(sh*dpr);
  overlay.style.width=sw+'px'; overlay.style.height=sh+'px';
  const s=sw/w; ctx.setTransform(dpr*s,0,0,dpr*s,0,0);
}
function clearOverlay(){ ctx.clearRect(0,0,overlay.width,overlay.height); }
function line(x1,y1,x2,y2,style='#32d0ff',lw=2){ ctx.strokeStyle=style; ctx.lineWidth=lw/(window.devicePixelRatio||1); ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }
function rect(r,style='#fff',lw=1.6){ ctx.strokeStyle=style; ctx.lineWidth=lw/(window.devicePixelRatio||1); ctx.strokeRect(r.x,r.y,r.w,r.h); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

/* ======= box options ======= */
(function boxes(){
  const ids=[], grades=['9','10','11','12'], letters=['A','B','C','D','E','F'];
  grades.forEach(g=>letters.forEach(l=>ids.push(g+l))); ids.push('SM1','SM2');
  boxSel.innerHTML=ids.map(x=>`<option>${x}</option>`).join('');
})();

/* ======= CSV parser & roster ======= */
function parseCSV(text){
  const rows=[]; let row=[],cur='',q=false; const push=()=>{row.push(cur);cur='';};
  for(let i=0;i<text.length;i++){
    const ch=text[i], nx=text[i+1];
    if(q){ if(ch==='"'&&nx==='"'){cur+='"';i++;} else if(ch==='"'){q=false;} else cur+=ch; }
    else{ if(ch==='"') q=true; else if(ch===',') push();
      else if(ch==='\n'||ch==='\r'){ if(ch==='\r'&&nx==='\n') i++; push(); rows.push(row); row=[]; }
      else cur+=ch; }
  } push(); if(row.length) rows.push(row);
  const header=rows.shift().map(h=>h.trim());
  return rows.filter(r=>r.some(x=>x&&x.trim()!=='')).map(r=>{const o={}; header.forEach((h,i)=>o[h]=r[i]||''); return o;});
}
async function loadRoster(){
  const status = (t)=> rosterStatus.textContent=t;
  // Project-page safe relative path candidates
  const base = (()=>{
    const p = window.location.pathname;
    return p.endsWith('/')? p : p.replace(/[^/]+$/,'');
  })();
  const candidates = [
    'data/roster.csv',
    './data/roster.csv',
    base + 'data/roster.csv',
    '/data/roster.csv'
  ];
  status('Loading roster‚Ä¶');
  for(const url of candidates){
    try{
      const res = await fetch(url, {cache:'no-store'});
      if(res.ok){
        roster = parseCSV(await res.text());
        status(`Loaded ‚úì (${url})`);
        return;
      }
    }catch(e){ console.warn('Roster fetch failed:', url, e); }
  }
  status('Could not load roster (upload below).');
}
loadRoster();
rosterFile.addEventListener('change',()=>{
  const f=rosterFile.files[0]; if(!f) return;
  const r=new FileReader();
  r.onload=()=>{ roster=parseCSV(r.result||''); rosterStatus.textContent='Loaded from file ‚úì'; };
  r.readAsText(f);
});
function namesForBox(id){
  const out={};
  for(const r of roster){
    const sec=(r['Security Number']||r['SecurityNumber']||'').toUpperCase().replace(/\s+/g,'');
    const m=sec.match(/^(SM\d|\d{1,2}[A-F])[- ]?(\d{1,2})$/);
    if(!m) continue; const box=m[1], slot=+m[2];
    if(box===id) out[slot]=r['Full Name']||r['FullName']||'';
  }
  return out;
}

/* ======= load ONNX model (project-page safe) ======= */
(async function initModel(){
  setStatus('Loading model‚Ä¶');
  const base = (()=>{
    const p = window.location.pathname;
    return p.endsWith('/')? p : p.replace(/[^/]+$/,'');
  })();
  const candidates = [
    'model/box_yolo.onnx',
    './model/box_yolo.onnx',
    base + 'model/box_yolo.onnx'
  ];
  for(const url of candidates){
    try{
      session = await ort.InferenceSession.create(url, {
        executionProviders: ['webgpu','wasm','webgl'],
        graphOptimizationLevel: 'all'
      });
      setStatus(`Model ready ‚úì (${url}). Upload a photo.`);
      runBtn.disabled=false;
      return;
    }catch(e){ console.warn('Model load failed:', url, e); }
  }
  setStatus('Could not load model (place it at model/box_yolo.onnx).');
})();

/* ======= image load ======= */
photo.addEventListener('change', async (e)=>{
  const f=e.target.files[0]; if(!f) return;
  const url=URL.createObjectURL(f);
  const im = new Image(); im.onload=async ()=>{
    preview.src=url; preview.style.display='block';
    sizeOverlayToImage(im.naturalWidth, im.naturalHeight);
    clearOverlay(); rois=[]; rowY=[]; wallsPerRow=[]; occ=[];
    setStatus('Photo loaded. Tap ‚ÄúRun YOLO (Auto)‚Äù.');
  }; im.src=url;
});

/* ======= YOLO helpers ======= */
function letterbox(img, newShape=[640,640]){
  const [w,h]=[img.naturalWidth||img.width, img.naturalHeight||img.height];
  const [nw,nh]=newShape;
  const r = Math.min(nw/w, nh/h);
  const newUnpad=[Math.round(w*r), Math.round(h*r)];
  const dw = (nw - newUnpad[0]) / 2;
  const dh = (nh - newUnpad[1]) / 2;
  const c=document.createElement('canvas'); c.width=nw; c.height=nh;
  const cx=c.getContext('2d'); cx.fillStyle='rgb(114,114,114)'; cx.fillRect(0,0,nw,nh);
  cx.drawImage(img, 0,0,w,h, Math.round(dw), Math.round(dh), newUnpad[0], newUnpad[1]);
  const data = cx.getImageData(0,0,nw,nh).data;
  const out = new Float32Array(1*3*nw*nh); let o=0;
  for(let y=0;y<nh;y++){
    for(let x=0;x<nw;x++){
      const i=(y*nw+x)*4;
      out[o + (0*nh + y)*nw + x] = data[i]/255;
      out[o + (1*nh + y)*nw + x] = data[i+1]/255;
      out[o + (2*nh + y)*nw + x] = data[i+2]/255;
    }
  }
  return {tensor:out, shape:[1,3,nh,nw], r, dw, dh, nw, nh, w0:w, h0:h};
}
function nms(boxes, scores, iouThresh=0.45, scoreThresh=0.25){
  const idx = scores.map((s,i)=>[s,i]).filter(v=>v[0]>=scoreThresh).sort((a,b)=>b[0]-a[0]).map(v=>v[1]);
  const picked=[];
  while(idx.length){
    const i = idx.shift(); picked.push(i);
    const a=boxes[i];
    const rest=[];
    for(const j of idx){
      const b=boxes[j];
      const xx1=Math.max(a[0],b[0]), yy1=Math.max(a[1],b[1]);
      const xx2=Math.min(a[2],b[2]), yy2=Math.min(a[3],b[3]);
      const w=Math.max(0,xx2-xx1), h=Math.max(0,yy2-yy1);
      const inter=w*h, iou=inter/(((a[2]-a[0])*(a[3]-a[1]))+((b[2]-b[0])*(b[3]-b[1]))-inter);
      if(iou<=iouThresh) rest.push(j);
    }
    idx.splice(0, idx.length, ...rest);
  }
  return picked;
}

/* ======= run YOLO (phones + number_strips) ======= */
runBtn.addEventListener('click', async ()=>{
  if(!session || !preview.src){ alert('Model and photo required.'); return; }
  manual=false; modePill.textContent='Mode: Auto';
  setStatus('Running YOLO‚Ä¶');

  const lb = letterbox(preview, [640,640]);
  const feeds={ 'images': new ort.Tensor('float32', lb.tensor, lb.shape) };
  const out = await session.run(feeds);
  const det = out[Object.keys(out)[0]].data; // Float32Array [1,N,85]
  const N = det.length / 85;
  const boxes=[], scores=[], classes=[];
  for(let i=0;i<N;i++){
    const base=i*85;
    const bx=det[base+0], by=det[base+1], bw=det[base+2], bh=det[base+3];
    const x1=(bx-bw/2 - lb.dw)/lb.r, y1=(by-bh/2 - lb.dh)/lb.r;
    const x2=(bx+bw/2 - lb.dw)/lb.r, y2=(by+bh/2 - lb.dh)/lb.r;
    const clsScores = det.slice(base+5, base+7); // 2 classes: phone(0), number_strip(1)
    let bestC=0, bestS=clsScores[0];
    if(clsScores[1]>bestS){ bestC=1; bestS=clsScores[1]; }
    boxes.push([clamp(x1,0,lb.w0), clamp(y1,0,lb.h0), clamp(x2,0,lb.w0), clamp(y2,0,lb.h0)]);
    scores.push(bestS); classes.push(bestC);
  }
  const keep = nms(boxes, scores, 0.45, 0.25);
  const phones=[]; const strips=[];
  for(const i of keep){
    const b=boxes[i], conf=scores[i], cls=classes[i];
    (cls===1 ? strips : phones).push({b,conf});
  }
  if(strips.length<3){ setStatus('Not enough number_strip detections. Use Manual fallback.'); return; }

  // Cluster strips into 5 rows
  strips.sort((a,b)=>((a.b[1]+a.b[3])/2)-((b.b[1]+b.b[3])/2));
  const centers=strips.map(s=>(s.b[1]+s.b[3])/2);
  const rows = kmeans1D(centers, ROWS).centers.sort((a,b)=>a-b);
  rowY = rows;

  // For each row, merge x-span of nearby strips; then get 13 tick walls
  wallsPerRow=[];
  for(const y of rowY){
    const near = strips.filter(s=>Math.abs(((s.b[1]+s.b[3])/2)-y) < 40);
    const span = near.length ? [
      Math.min(...near.map(s=>s.b[0])),
      Math.max(...near.map(s=>s.b[2])),
      Math.min(...near.map(s=>s.b[1])),
      Math.max(...near.map(s=>s.b[3]))
    ] : [10, lb.w0-10, y-10, y+10];

    const walls = getWallsFromStripRegion(span);
    wallsPerRow.push(walls);
  }

  // Build ROIs & draw
  buildROIsFromRowsAndWalls(rowY, wallsPerRow, preview.naturalWidth, preview.naturalHeight);
  drawGuides(rowY, wallsPerRow, preview.naturalWidth, preview.naturalHeight);

  // store phones for analyze
  window.__phones = phones.map(p=>({x1:p.b[0],y1:p.b[1],x2:p.b[2],y2:p.b[3]}));
  setStatus('YOLO done. Click Analyze.');
});

function kmeans1D(values, k){
  values=[...values].sort((a,b)=>a-b);
  const centers=[]; for(let i=0;i<k;i++) centers.push(values[Math.floor(i*(values.length-1)/(k-1))]);
  for(let it=0;it<15;it++){
    const groups=Array.from({length:k},()=>[]);
    for(const v of values){ let bi=0,bd=Infinity; for(let i=0;i<k;i++){const d=Math.abs(v-centers[i]); if(d<bd){bd=d;bi=i}} groups[bi].push(v); }
    for(let i=0;i<k;i++){ if(groups[i].length) centers[i]=groups[i].reduce((a,b)=>a+b,0)/groups[i].length; }
  }
  return {centers};
}

// Use OpenCV on the original image inside the strip span to get 13 vertical walls (tick marks)
function getWallsFromStripRegion([x1,x2,y1,y2]){
  if(!cvReady){
    const walls=[]; for(let i=0;i<13;i++) walls.push(x1 + i*(x2-x1)/12); return walls;
  }
  const W=preview.naturalWidth, H=preview.naturalHeight;
  const sx=Math.max(0,Math.floor(x1)), ex=Math.min(W,Math.ceil(x2));
  const sy=Math.max(0,Math.floor(y1-8)), ey=Math.min(H,Math.ceil(y2+8));
  const w=ex-sx, h=ey-sy; if(w<20||h<6){const walls=[];for(let i=0;i<13;i++) walls.push(x1+i*(x2-x1)/12);return walls;}
  const c=document.createElement('canvas'); c.width=w; c.height=h; const cx=c.getContext('2d');
  cx.drawImage(preview, sx,sy,w,h, 0,0,w,h);
  const imgData=cx.getImageData(0,0,w,h);
  const mat=cv.matFromImageData(imgData);
  const gray=new cv.Mat(); cv.cvtColor(mat,gray,cv.COLOR_RGBA2GRAY);
  const norm=new cv.Mat(); cv.normalize(gray,norm,0,255,cv.NORM_MINMAX);
  const th=new cv.Mat(); cv.threshold(norm,th,0,255,cv.THRESH_BINARY|cv.THRESH_OTSU);
  const k=cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(3,9));
  const k2=cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(1,7));
  const m1=new cv.Mat(); cv.morphologyEx(th,m1,cv.MORPH_OPEN,k);
  const m2=new cv.Mat(); cv.morphologyEx(m1,m2,cv.MORPH_CLOSE,k2);
  const proj=new Float32Array(w);
  for(let x=0;x<w;x++){ let s=0; for(let y=0;y<h;y++) if(m2.ucharPtr(y,x)[0]>0) s++; proj[x]=s; }
  const sm=new Float32Array(w);
  for(let x=0;x<w;x++){ let s=0,cnt=0; for(let d=-4;d<=4;d++){const xx=x+d; if(xx>=0&&xx<w){s+=proj[xx];cnt++;}} sm[x]=s/cnt;}
  const walls=[]; for(let i=0;i<13;i++){ const guess=Math.round(i*(w-1)/12); let best=guess,bv=-1; for(let d=-8;d<=8;d++){const x=Math.max(0,Math.min(w-1,guess+d)); if(sm[x]>bv){bv=sm[x];best=x;}} walls.push(sx+best); }
  [mat,gray,norm,th,k,k2,m1,m2].forEach(m=>m.delete());
  return walls.sort((a,b)=>a-b);
}

/* ======= build ROIs / draw ======= */
function buildROIsFromRowsAndWalls(rowsY, perRowWalls, W, H){
  rois=[];
  const gaps=[]; for(let i=1;i<rowsY.length;i++) gaps.push(rowsY[i]-rowsY[i-1]);
  const avgGap=gaps.length?gaps.reduce((a,b)=>a+b,0)/gaps.length:H/6;
  for(let r=0;r<ROWS;r++){
    const yB=rowsY[r];
    const gap=(r<ROWS-1?rowsY[r+1]-rowsY[r]:avgGap);
    const h=Math.max(10,Math.round(gap*SLOT_H_FRAC));
    const yT=Math.max(0,Math.round(yB - h - gap*SLOT_TOP_PAD));
    const yBot=Math.max(yT+8, Math.round(yB - gap*SLOT_TOP_PAD));
    const walls=perRowWalls[r]||Array.from({length:13},(_,i)=> i*(W-1)/12 );
    for(let c=0;c<COLS;c++){
      const x0=Math.round(walls[c]), x1=Math.round(walls[c+1]);
      rois.push({x:x0,y:yT,w:Math.max(1,x1-x0),h:yBot-yT,row:r,col:c});
    }
  }
}
function drawGuides(rowsY, perRowWalls, W, H){
  sizeOverlayToImage(W,H);
  clearOverlay();
  if(showGuides.checked){
    rowsY.forEach(y=> line(0,y,W,y,'#32d0ff',2));
    perRowWalls.forEach(w=>w.forEach(x=> line(x,10,x,28,'#fff',2)));
  }
  rois.forEach(r=>rect(r,'#fff',1.6));
}

/* ======= Analyze (map phones ‚Üí slots + roster) ======= */
analyzeBtn.addEventListener('click', ()=>{
  if(!rois.length){ alert('Run YOLO or use Manual to place lines.'); return; }
  const phones = window.__phones || [];
  occ = rois.map(r=>{
    return phones.some(p=>{
      const ix1=Math.max(r.x,p.x1), iy1=Math.max(r.y,p.y1);
      const ix2=Math.min(r.x+r.w,p.x2), iy2=Math.min(r.y+r.h,p.y2);
      const inter=Math.max(0,ix2-ix1)*Math.max(0,iy2-iy1);
      const slotA=r.w*r.h;
      return inter/slotA>=0.15; // overlap threshold
    });
  });

  clearOverlay();
  for(let i=0;i<rois.length;i++){
    const r=rois[i]; ctx.fillStyle = occ[i] ? 'rgba(0,200,0,.35)' : 'rgba(255,0,0,.35)';
    ctx.fillRect(r.x,r.y,r.w,r.h); rect(r,'#fff',1.4);
  }

  const names=namesForBox(boxSel.value||'');
  resultsBody.innerHTML='';
  for(let i=0;i<TOTAL;i++){
    const slot=i+1, expected=names[slot]||'';
    const status = occ[i] ? (expected?'present':'unexpected phone') : (expected?'missing':'empty');
    const tr=document.createElement('tr');
    tr.className = status==='missing'?'missing':(status==='present'?'ok':'');
    tr.innerHTML=`<td>${slot}</td><td>${expected}</td><td><span class="pill">${status}</span></td>`;
    resultsBody.appendChild(tr);
  }
  [...miniGrid.children].forEach((d,i)=>{ d.classList.toggle('present',!!occ[i]); d.classList.toggle('empty',!!occ[i]===false); d.classList.toggle('empty',!occ[i]); });
  setStatus('Done. Green = phone, Red = empty.');
});

/* ======= Manual fallback (drag) ======= */
manualBtn.addEventListener('click', ()=>{
  if(!preview.src){ alert('Upload a photo first.'); return; }
  manual=true; modePill.textContent='Mode: Manual';
  const W=preview.naturalWidth, H=preview.naturalHeight;
  if(!rowY.length){ for(let i=0;i<ROWS;i++) rowY[i]=Math.round((i+1)*(H/(ROWS+1))); }
  const walls = Array.from({length:13},(_,i)=> Math.round(i*(W-1)/12));
  wallsPerRow = Array.from({length:ROWS},()=>walls);
  buildROIsFromRowsAndWalls(rowY, wallsPerRow, W, H);
  drawGuides(rowY, wallsPerRow, W, H);
  setStatus('Drag near a cyan line to move a row; near a white line to move a wall, then Analyze.');
});
let drag=null;
overlay.addEventListener('pointerdown', e=>{
  if(!manual) return;
  const pt=toImg(e);
  let bestD=1e9, bi=-1;
  for(let i=0;i<rowY.length;i++){ const d=Math.abs(pt.y-rowY[i]); if(d<bestD){bestD=d; bi=i;} }
  if(bestD<22){ drag={type:'row', idx:bi}; return; }
  let bestW=1e9, wi=-1; const w=wallsPerRow[0]||[];
  for(let i=0;i<w.length;i++){ const d=Math.abs(pt.x-w[i]); if(d<bestW){bestW=d; wi=i;} }
  if(bestW<22){ drag={type:'wall', idx:wi}; }
});
overlay.addEventListener('pointermove', e=>{
  if(!drag||!manual) return;
  const pt=toImg(e), W=preview.naturalWidth, H=preview.naturalHeight;
  if(drag.type==='row'){ rowY[drag.idx]=clamp(Math.round(pt.y),0,H-1); }
  else{ const x=clamp(Math.round(pt.x),0,W-1); for(let r=0;r<ROWS;r++) wallsPerRow[r][drag.idx]=x; }
  buildROIsFromRowsAndWalls(rowY, wallsPerRow, W, H);
  drawGuides(rowY, wallsPerRow, W, H);
});
window.addEventListener('pointerup', ()=> drag=null);
function toImg(ev){
  const r=overlay.getBoundingClientRect();
  const dpr=window.devicePixelRatio||1;
  const cw=overlay.width/dpr, ch=overlay.height/dpr;
  const x=(ev.clientX-r.left)/cw*preview.naturalWidth;
  const y=(ev.clientY-r.top )/ch*preview.naturalHeight;
  return {x,y};
}

/* ======= reset & grid ======= */
resetBtn.addEventListener('click', ()=>{
  rois=[]; rowY=[]; wallsPerRow=[]; occ=[]; manual=false; window.__phones=[];
  resultsBody.innerHTML=''; clearOverlay(); preview.style.display='none'; photo.value='';
  setStatus('Reset. Upload a new photo.');
});
(function initGrid(){ for(let i=0;i<TOTAL;i++){ const d=document.createElement('div'); d.className='slot'; d.innerHTML=`<span>#${i+1}</span>`; miniGrid.appendChild(d);} })();
window.addEventListener('resize', ()=>{ if(preview.src) sizeOverlayToImage(preview.naturalWidth, preview.naturalHeight);});
</script>
</body>
</html>
