<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Phone Box ‚Äì Auto/Manual Align + Robust Slot Detection</title>
<style>
  :root{--bg:#0b1020;--card:#10183a;--mut:#9ab0e0}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:#fff;font-family:system-ui,-apple-system,Inter,Roboto}
  header{padding:12px 16px;border-bottom:1px solid #ffffff22;font-weight:800}
  main{max-width:1200px;margin:0 auto;padding:12px;display:grid;grid-template-columns:1.25fr .75fr;gap:16px}
  .card{background:#10183a;border:1px solid #ffffff22;border-radius:16px;padding:14px}
  label{display:block;margin:8px 0 6px;color:var(--mut);font-size:14px}
  input[type=file],select,button{width:100%;padding:12px 14px;border-radius:12px;border:1px solid #ffffff33;background:#0f1738;color:#fff;font-size:16px}
  button.primary{background:linear-gradient(180deg,#37c2f2,#1aa1d9);border:none;font-weight:800}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:10px}
  .pill{display:inline-block;padding:.25rem .6rem;border-radius:999px;background:#ffffff24;font-size:12px}
  #stage{position:relative;border:1px dashed #ffffff33;border-radius:12px;overflow:hidden;background:#0c1333;min-height:260px;touch-action:none}
  #preview{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:none;z-index:0}
  #overlay{position:absolute;inset:0;pointer-events:auto;z-index:1}
  .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:6px;margin:10px 0}
  .slot{background:#0f1738;border:1px solid #ffffff24;aspect-ratio:3/5;border-radius:8px;position:relative}
  .slot.present{outline:2px solid rgba(0,200,0,.9)}
  .slot.empty{outline:2px solid rgba(255,0,0,.9)}
  .slot span{position:absolute;inset:auto 6px 6px 6px;font-size:12px;color:#9ab0ff}
  table{width:100%;border-collapse:collapse;margin-top:10px}
  th,td{border-bottom:1px solid #ffffff19;padding:8px 6px;text-align:left}
  tr.missing{background:#ff50501a}
  .modes{display:flex;gap:8px;flex-wrap:wrap}
  .modes button{flex:1}
  .fine{font-size:12px;color:#9ab0e0}
  @media (max-width:900px){ main{grid-template-columns:1fr} }
</style>
</head>
<body>
<header>üì± Phone Box ‚Äî Auto/Manual alignment above blue numbers + robust ‚Äúphone present‚Äù detection with live tuning.</header>

<main>
  <section class="card">
    <div id="stage">
      <img id="preview" alt="preview">
      <canvas id="overlay"></canvas>
    </div>
    <div class="toolbar">
      <span class="pill" id="status">Upload a photo.</span>
      <span class="pill" id="modePill">Mode: View</span>
    </div>

    <div class="grid" id="miniGrid"></div>

    <table>
      <thead><tr><th>Slot</th><th>Expected</th><th>Status</th></tr></thead>
      <tbody id="results"></tbody>
    </table>
  </section>

  <section class="card">
    <label>Box</label>
    <select id="box"></select>

    <label>Roster CSV (auto-loads <code>data/roster.csv</code>)</label>
    <div style="display:flex;gap:8px;align-items:center">
      <small id="rosterStatus">Loading‚Ä¶</small>
      <input id="rosterFile" type="file" accept=".csv">
    </div>

    <label>Upload photo</label>
    <input id="photo" type="file" accept="image/*" capture="environment">

    <div class="modes" style="margin-top:8px">
      <button id="btnAuto" class="primary">Auto align</button>
      <button id="btnManual">Manual align</button>
      <button id="btnAnalyze">Analyze</button>
      <button id="btnReset">Reset</button>
    </div>

    <details open>
      <summary>Auto align options</summary>
      <label>Blue sensitivity (HSV Œî)</label>
      <input type="range" id="blueDelta" min="0" max="40" value="18">
      <small class="fine">Raise if it can‚Äôt find all 5 blue number bars.</small>
    </details>

    <details open>
      <summary>Detection tuning</summary>
      <label>Presence threshold <span id="thVal">0.55</span></label>
      <input id="thresh" type="range" min="0.30" max="0.80" step="0.01" value="0.55">
      <label>Band top % <span id="btVal">6</span></label>
      <input id="bandTop" type="range" min="0" max="20" step="1" value="6">
      <label>Band bottom % <span id="bbVal">60</span></label>
      <input id="bandBot" type="range" min="40" max="80" step="1" value="60">
      <label><input id="showScores" type="checkbox"> Show per-slot scores</label>
    </details>

    <div class="toolbar">
      <label><input id="showGuides" type="checkbox" checked> Show guides</label>
    </div>
  </section>
</main>

<!-- OpenCV.js for alignment & image ops -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script>
/* ========= constants / state ========= */
const ROWS=5, COLS=12, TOTAL=ROWS*COLS;
// Taller ROI and slight gap above blue strip to capture ports/phones
const SLOT_H_FRAC=0.52;
const SLOT_TOP_PAD=0.06;

const stage=document.getElementById('stage');
const overlay=document.getElementById('overlay'); const ctx=overlay.getContext('2d');
const preview=document.getElementById('preview');

const statusEl=document.getElementById('status');
const modePill=document.getElementById('modePill');
const resultsBody=document.getElementById('results');
const miniGrid=document.getElementById('miniGrid');

const btnAuto=document.getElementById('btnAuto');
const btnManual=document.getElementById('btnManual');
const btnAnalyze=document.getElementById('btnAnalyze');
const btnReset=document.getElementById('btnReset');

const blueDelta=document.getElementById('blueDelta');
const showGuides=document.getElementById('showGuides');

const threshEl=document.getElementById('thresh'), thVal=document.getElementById('thVal');
const bandTopEl=document.getElementById('bandTop'), btVal=document.getElementById('btVal');
const bandBotEl=document.getElementById('bandBot'), bbVal=document.getElementById('bbVal');
const showScores=document.getElementById('showScores');

const rosterFile=document.getElementById('rosterFile'); const rosterStatus=document.getElementById('rosterStatus');
const boxSel=document.getElementById('box');
const photo=document.getElementById('photo');

let cvReady=false, mode='view';
let rowY=[], wallsPerRow=[], rois=[], occ=[]; // geometry + predictions
let roster=[];

/* ========= init ========= */
window.Module={onRuntimeInitialized(){ cvReady=true; }};
(function fillBoxes(){
  const ids=[], grades=['9','10','11','12'], letters=['A','B','C','D','E','F'];
  grades.forEach(g=>letters.forEach(l=>ids.push(g+l))); ids.push('SM1','SM2');
  boxSel.innerHTML=ids.map(x=>`<option>${x}</option>`).join('');
})();
(function initGrid(){
  for(let i=0;i<TOTAL;i++){
    const d=document.createElement('div'); d.className='slot'; d.innerHTML=`<span>#${i+1}</span>`;
    miniGrid.appendChild(d);
  }
})();
[threshEl,bandTopEl,bandBotEl].forEach(el=>{
  el.addEventListener('input', ()=>{
    thVal.textContent=(+threshEl.value).toFixed(2);
    btVal.textContent=bandTopEl.value;
    bbVal.textContent=bandBotEl.value;
  });
});
thVal.textContent=(+threshEl.value).toFixed(2);
btVal.textContent=bandTopEl.value; bbVal.textContent=bandBotEl.value;

/* ========= helpers ========= */
function setStatus(t){ statusEl.textContent=t; }
function sizeOverlayToImage(w,h){
  const sw=stage.clientWidth, sh=Math.max(260, Math.round(sw*(h/w)));
  stage.style.height=sh+'px';
  const dpr=window.devicePixelRatio||1;
  overlay.width=Math.round(sw*dpr); overlay.height=Math.round(sh*dpr);
  overlay.style.width=sw+'px'; overlay.style.height=sh+'px';
  const s=sw/w; ctx.setTransform(dpr*s,0,0,dpr*s,0,0);
}
function clearOverlay(){ ctx.clearRect(0,0,overlay.width,overlay.height); }
function line(x1,y1,x2,y2,style='#32d0ff',lw=2){ ctx.strokeStyle=style; ctx.lineWidth=lw/(window.devicePixelRatio||1); ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }
function rect(r,style='#fff',lw=1.6){ ctx.strokeStyle=style; ctx.lineWidth=lw/(window.devicePixelRatio||1); ctx.strokeRect(r.x,r.y,r.w,r.h); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

/* ========= roster load (GH Pages safe) ========= */
function parseCSV(text){
  const rows=[]; let row=[],cur='',q=false; const push=()=>{row.push(cur);cur='';};
  for(let i=0;i<text.length;i++){
    const ch=text[i], nx=text[i+1];
    if(q){ if(ch==='"'&&nx==='"'){cur+='"';i++;} else if(ch==='"'){q=false;} else cur+=ch; }
    else{ if(ch==='"') q=true; else if(ch===',') push();
      else if(ch==='\n'||ch==='\r'){ if(ch==='\r'&&nx==='\n') i++; push(); rows.push(row); row=[]; }
      else cur+=ch; }
  } push(); if(row.length) rows.push(row);
  const header=rows.shift().map(h=>h.trim());
  return rows.filter(r=>r.some(x=>x&&x.trim()!=='')).map(r=>{const o={}; header.forEach((h,i)=>o[h]=r[i]||''); return o;});
}
async function loadRoster(){
  const status=(t)=> rosterStatus.textContent=t;
  const base=(()=>{const p=location.pathname; return p.endsWith('/')?p:p.replace(/[^/]+$/,'');})();
  const candidates=['data/roster.csv','./data/roster.csv',base+'data/roster.csv','/data/roster.csv'];
  status('Loading roster‚Ä¶');
  for(const url of candidates){
    try{ const res=await fetch(url,{cache:'no-store'}); if(res.ok){ roster=parseCSV(await res.text()); status(`Loaded ‚úì (${url})`); return; } }
    catch(e){ console.warn('Roster fetch failed',url,e); }
  }
  status('Could not load roster (upload below).');
}
loadRoster();
rosterFile.addEventListener('change',()=>{
  const f=rosterFile.files[0]; if(!f) return;
  const r=new FileReader(); r.onload=()=>{ roster=parseCSV(r.result||''); rosterStatus.textContent='Loaded from file ‚úì'; }; r.readAsText(f);
});
function namesForBox(id){
  const out={};
  for(const r of roster){
    const sec=(r['Security Number']||r['SecurityNumber']||'').toUpperCase().replace(/\s+/g,'');
    const m=sec.match(/^(SM\d|\d{1,2}[A-F])[- ]?(\d{1,2})$/);
    if(!m) continue; const box=m[1], slot=+m[2];
    if(box===id) out[slot]=r['Full Name']||r['FullName']||'';
  }
  return out;
}

/* ========= image load ========= */
photo.addEventListener('change', e=>{
  const f=e.target.files[0]; if(!f) return;
  const url=URL.createObjectURL(f);
  const im=new Image(); im.onload=()=>{
    preview.src=url; preview.style.display='block';
    sizeOverlayToImage(im.naturalWidth, im.naturalHeight);
    clearOverlay(); rowY=[]; wallsPerRow=[]; rois=[]; occ=[];
    setStatus('Photo loaded. Use Auto align (or Manual).');
  }; im.src=url;
});
window.addEventListener('resize',()=>{ if(preview.src) sizeOverlayToImage(preview.naturalWidth, preview.naturalHeight); });

/* ========= Auto align (find blue bars + tick walls) ========= */
btnAuto.onclick=()=>{
  if(!cvReady||!preview.src) return alert('Need image + OpenCV.');
  const W=preview.naturalWidth, H=preview.naturalHeight;

  // downscale for speed
  const scale=1600/Math.max(W,H);
  const c=document.createElement('canvas'); const cw=Math.round(W*Math.min(1,scale)), ch=Math.round(H*Math.min(1,scale));
  c.width=cw; c.height=ch; c.getContext('2d').drawImage(preview,0,0,W,H,0,0,cw,ch);
  const imgData=c.getContext('2d').getImageData(0,0,cw,ch);
  const src=cv.matFromImageData(imgData);
  const hsv=new cv.Mat(); cv.cvtColor(src,hsv,cv.COLOR_RGBA2RGB); cv.cvtColor(hsv,hsv,cv.COLOR_RGB2HSV);

  const delta=+blueDelta.value;
  const lower=new cv.Mat(hsv.rows,hsv.cols,hsv.type(),[100-delta,60,40,0]);
  const upper=new cv.Mat(hsv.rows,hsv.cols,hsv.type(),[130+delta,255,255,255]);
  const mask=new cv.Mat(); cv.inRange(hsv,lower,upper,mask);
  const k=cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(21,5));
  cv.morphologyEx(mask,mask,cv.MORPH_CLOSE,k); cv.morphologyEx(mask,mask,cv.MORPH_OPEN,k);

  const contours=new cv.MatVector(), hier=new cv.Mat(); cv.findContours(mask,contours,hier,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);
  const bars=[];
  for(let i=0;i<contours.size();i++){
    const r=cv.boundingRect(contours.get(i)); const ar=r.width/r.height;
    if(r.width>cw*0.35 && r.height>6 && ar>8) bars.push(r);
  }
  bars.sort((a,b)=>a.y-b.y); if(bars.length>5) bars.splice(5);
  if(bars.length<5){ setStatus('Could not find 5 number strips. Raise Blue sensitivity or use Manual.'); [src,hsv,lower,upper,mask,contours,hier].forEach(m=>m.delete()); return; }

  // map bar centers to full-res Y
  rowY = bars.map(b => (b.y + b.height/2) / Math.min(1,scale));

  // get 13 vertical walls per row by projecting the strip region at full res
  wallsPerRow=[];
  for(const b of bars){
    const x1=(b.x-10)/Math.min(1,scale), x2=(b.x+b.width+10)/Math.min(1,scale);
    const y1=(b.y-8)/Math.min(1,scale),  y2=(b.y+b.height+8)/Math.min(1,scale);
    wallsPerRow.push( getWallsFromStripRegion([x1,x2,y1,y2]) );
  }
  buildROIs(rowY, wallsPerRow, W, H);
  drawGuides(rowY, wallsPerRow, W, H);
  setStatus('Auto aligned. If slightly off, switch to Manual and drag.');

  [src,hsv,lower,upper,mask,contours,hier].forEach(m=>m.delete());
};
function getWallsFromStripRegion([x1,x2,y1,y2]){
  const W=preview.naturalWidth, H=preview.naturalHeight;
  const sx=Math.max(0,Math.floor(x1)), ex=Math.min(W,Math.ceil(x2));
  const sy=Math.max(0,Math.floor(y1)), ey=Math.min(H,Math.ceil(y2));
  const w=ex-sx, h=ey-sy; if(w<20||h<6){const walls=[]; for(let i=0;i<13;i++) walls.push(x1+i*(x2-x1)/12); return walls;}
  const c=document.createElement('canvas'); c.width=w; c.height=h; const cx=c.getContext('2d'); cx.drawImage(preview,sx,sy,w,h,0,0,w,h);
  const mat=cv.matFromImageData(cx.getImageData(0,0,w,h));
  const gray=new cv.Mat(); cv.cvtColor(mat,gray,cv.COLOR_RGBA2GRAY);
  const norm=new cv.Mat(); cv.normalize(gray,norm,0,255,cv.NORM_MINMAX);
  const th=new cv.Mat(); cv.threshold(norm,th,0,255,cv.THRESH_BINARY|cv.THRESH_OTSU);
  const k=cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(3,9));
  const k2=cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(1,7));
  const m1=new cv.Mat(); cv.morphologyEx(th,m1,cv.MORPH_OPEN,k);
  const m2=new cv.Mat(); cv.morphologyEx(m1,m2,cv.MORPH_CLOSE,k2);
  const proj=new Float32Array(w); for(let x=0;x<w;x++){ let s=0; for(let y=0;y<h;y++) if(m2.ucharPtr(y,x)[0]>0) s++; proj[x]=s; }
  const sm=new Float32Array(w); for(let x=0;x<w;x++){ let s=0,cnt=0; for(let d=-4;d<=4;d++){const xx=x+d; if(xx>=0&&xx<w){s+=proj[xx];cnt++;}} sm[x]=s/cnt; }
  const walls=[]; for(let i=0;i<13;i++){ const guess=Math.round(i*(w-1)/12); let best=guess,bv=-1; for(let d=-8;d<=8;d++){const x=Math.max(0,Math.min(w-1,guess+d)); if(sm[x]>bv){bv=sm[x];best=x;}} walls.push(sx+best); }
  [mat,gray,norm,th,k,k2,m1,m2].forEach(m=>m.delete());
  return walls.sort((a,b)=>a-b);
}

/* ========= Manual align (drag) ========= */
btnManual.onclick=()=>{
  if(!preview.src) return alert('Upload a photo first.');
  const W=preview.naturalWidth, H=preview.naturalHeight;
  if(!rowY.length){ for(let i=0;i<ROWS;i++) rowY[i]=Math.round((i+1)*(H/(ROWS+1))); }
  const walls = Array.from({length:13},(_,i)=> Math.round(i*(W-1)/12));
  wallsPerRow = Array.from({length:ROWS},()=>walls);
  buildROIs(rowY, wallsPerRow, W, H);
  drawGuides(rowY, wallsPerRow, W, H);
  setStatus('Drag near cyan line (row) or white line (wall). Then Analyze.');
  mode='manual'; modePill.textContent='Mode: Manual';
};
let drag=null;
overlay.addEventListener('pointerdown', e=>{
  if(mode!=='manual') return;
  const pt=toImg(e);
  let bestD=1e9, bi=-1; for(let i=0;i<rowY.length;i++){ const d=Math.abs(pt.y-rowY[i]); if(d<bestD){bestD=d; bi=i;} }
  if(bestD<22){ drag={type:'row', idx:bi}; return; }
  let bestW=1e9, wi=-1; const w=wallsPerRow[0]||[]; for(let i=0;i<w.length;i++){ const d=Math.abs(pt.x-w[i]); if(d<bestW){bestW=d; wi=i;} }
  if(bestW<22){ drag={type:'wall', idx:wi}; }
});
overlay.addEventListener('pointermove', e=>{
  if(!drag||mode!=='manual') return;
  const pt=toImg(e), W=preview.naturalWidth, H=preview.naturalHeight;
  if(drag.type==='row'){ rowY[drag.idx]=clamp(Math.round(pt.y),0,H-1); }
  else{ const x=clamp(Math.round(pt.x),0,W-1); for(let r=0;r<ROWS;r++) wallsPerRow[r][drag.idx]=x; }
  buildROIs(rowY, wallsPerRow, W, H);
  drawGuides(rowY, wallsPerRow, W, H);
});
window.addEventListener('pointerup', ()=> drag=null);
function toImg(ev){
  const r=overlay.getBoundingClientRect();
  const dpr=window.devicePixelRatio||1;
  const cw=overlay.width/dpr, ch=overlay.height/dpr;
  const x=(ev.clientX-r.left)/cw*preview.naturalWidth;
  const y=(ev.clientY-r.top )/ch*preview.naturalHeight;
  return {x,y};
}

/* ========= Build ROIs / Draw ========= */
function buildROIs(rowsY, perRowWalls, W, H){
  rois=[];
  const gaps=[]; for(let i=1;i<rowsY.length;i++) gaps.push(rowsY[i]-rowsY[i-1]);
  const avgGap=gaps.length?gaps.reduce((a,b)=>a+b,0)/gaps.length:H/6;
  for(let r=0;r<ROWS;r++){
    const yB=rowsY[r];
    const gap=(r<ROWS-1?rowsY[r+1]-rowsY[r]:avgGap);
    const h=Math.max(10,Math.round(gap*SLOT_H_FRAC));
    const yT=Math.max(0,Math.round(yB - h - gap*SLOT_TOP_PAD));
    const yBot=Math.max(yT+8, Math.round(yB - gap*SLOT_TOP_PAD));
    const walls=perRowWalls[r];
    for(let c=0;c<COLS;c++){
      const x0=Math.round(walls[c]), x1=Math.round(walls[c+1]);
      rois.push({x:x0,y:yT,w:Math.max(1,x1-x0),h:yBot-yT,row:r,col:c});
    }
  }
}
function drawGuides(rowsY, perRowWalls, W, H){
  sizeOverlayToImage(W,H);
  clearOverlay();
  if(showGuides.checked){
    rowsY.forEach(y=> line(0,y,W,y,'#32d0ff',2));
    perRowWalls.forEach(w=> w.forEach(x=> line(x,10,x,28,'#fff',2)));
  }
  rois.forEach(r=>rect(r,'#fff',1.6));
}

/* ========= Robust slot confidence ========= */
function lapVar(matGray){
  const lap16=new cv.Mat(), lap=new cv.Mat();
  cv.Laplacian(matGray, lap16, cv.CV_16S, 3, 1, 0, cv.BORDER_DEFAULT);
  cv.convertScaleAbs(lap16, lap);
  const mean=new cv.Mat(), std=new cv.Mat(); cv.meanStdDev(lap, mean, std);
  const v = std.doubleAt(0,0)**2;
  [lap16,lap,mean,std].forEach(m=>m.delete());
  return v;
}
function slotConfidence(r){
  const c=document.createElement('canvas'); c.width=r.w; c.height=r.h;
  const cx=c.getContext('2d', {willReadFrequently:true});
  cx.drawImage(preview, r.x,r.y,r.w,r.h, 0,0,r.w,r.h);
  const imgData=cx.getImageData(0,0,r.w,r.h);
  const mat=cv.matFromImageData(imgData);
  const gray=new cv.Mat(); cv.cvtColor(mat,gray,cv.COLOR_RGBA2GRAY);

  const y0=Math.round(r.h*(+bandTopEl.value/100));
  const y1=Math.round(r.h*(+bandBotEl.value/100));
  const xL=Math.round(r.w*0.10), xR=Math.round(r.w*0.90);
  const wS=Math.max(12,xR-xL), hS=Math.max(12,y1-y0);

  // Edge density
  const roi=gray.roi(new cv.Rect(xL,y0,wS,hS));
  const sob16=new cv.Mat(), sob=new cv.Mat();
  cv.Sobel(roi,sob16,cv.CV_16S,0,1,3,1,0,cv.BORDER_DEFAULT);
  cv.convertScaleAbs(sob16,sob);
  const blur=new cv.Mat(); cv.GaussianBlur(sob,blur,new cv.Size(3,3),0);
  const thr=new cv.Mat(); cv.threshold(blur,thr,0,255,cv.THRESH_BINARY|cv.THRESH_OTSU);
  let edgeFrac=0;
  for(let y=0;y<thr.rows;y++){ const p=thr.ptr(y); let c1=0; for(let x=0;x<thr.cols;x++) if(p[x]) c1++; edgeFrac=Math.max(edgeFrac, c1/thr.cols); }

  // Darkness vs foam
  const bandTop = Math.min(r.h-4, y0 + Math.round(hS*0.55));
  const bandH   = Math.max(6, Math.round(r.h*0.18));
  const bandY   = Math.min(r.h-bandH, bandTop);
  const band=gray.roi(new cv.Rect(Math.round(r.w*0.12), bandY, Math.round(r.w*0.76), bandH));
  const m1=new cv.Mat(), s1=new cv.Mat(); cv.meanStdDev(band,m1,s1);
  const bandMean=m1.doubleAt(0,0);

  const foamTop=gray.roi(new cv.Rect(Math.round(r.w*0.12), 0, Math.round(r.w*0.76), Math.max(4,Math.round(r.h*0.08))));
  const m2=new cv.Mat(), s2=new cv.Mat(); cv.meanStdDev(foamTop,m2,s2);
  const foamMean=m2.doubleAt(0,0);
  const darkGain= Math.max(0, Math.min(1, (foamMean-bandMean)/30 ));

  // Texture (Laplacian variance)
  const lv=lapVar(band);
  const tex = Math.max(0, Math.min(1, lv/300.0 ));

  const conf = Math.max(0, Math.min(1, 0.45*edgeFrac + 0.35*darkGain + 0.20*tex ));
  [mat,gray,roi,sob16,sob,blur,thr,band,foamTop,m1,s1,m2,s2].forEach(m=>m.delete());
  return {conf, parts:{edgeFrac,darkGain,tex}};
}

/* ========= Analyze ========= */
btnAnalyze.onclick=()=>{
  if(rois.length!==TOTAL) return alert('Align slots first.');
  const T=+threshEl.value;

  occ = rois.map(r=>{
    const {conf,parts}=slotConfidence(r);
    r.__score=conf; r.__parts=parts;
    return conf>=T;
  });

  clearOverlay();
  for(let i=0;i<rois.length;i++){
    const r=rois[i];
    ctx.fillStyle = occ[i] ? 'rgba(0,200,0,.35)' : 'rgba(255,0,0,.35)';
    ctx.fillRect(r.x,r.y,r.w,r.h); rect(r,'#fff',1.4);

    if(showScores.checked){
      ctx.fillStyle='rgba(0,0,0,.65)'; ctx.fillRect(r.x+4, r.y+4, 64, 36);
      ctx.fillStyle='#fff'; ctx.font='12px system-ui';
      ctx.fillText((r.__score||0).toFixed(2), r.x+8, r.y+18);
      const parts=r.__parts||{edgeFrac:0, darkGain:0, tex:0};
      const tot=parts.edgeFrac+parts.darkGain+parts.tex+1e-6;
      const y=r.y+24; const x=r.x+8, w=56, h=6;
      const w1=w*(parts.edgeFrac/tot), w2=w*(parts.darkGain/tot), w3=w*(parts.tex/tot);
      ctx.fillStyle='#7fc8ff'; ctx.fillRect(x, y, w1, h);
      ctx.fillStyle='#ffd54a'; ctx.fillRect(x+w1, y, w2, h);
      ctx.fillStyle='#a5f0a0'; ctx.fillRect(x+w1+w2, y, w3, h);
    }
  }

  const names=namesForBox(boxSel.value||'');
  resultsBody.innerHTML='';
  for(let i=0;i<TOTAL;i++){
    const slot=i+1, expected=names[slot]||'';
    const status = occ[i] ? (expected?'present':'unexpected phone') : (expected?'missing':'empty');
    const tr=document.createElement('tr');
    tr.className = status==='missing'?'missing':(status==='present'?'ok':'');
    tr.innerHTML=`<td>${slot}</td><td>${expected}</td><td><span class="pill">${status}</span></td>`;
    resultsBody.appendChild(tr);
  }
  [...miniGrid.children].forEach((d,i)=>{ d.classList.toggle('present',!!occ[i]); d.classList.toggle('empty',!occ[i]); });
  setStatus('Done. Tune the slider if needed.');
};

/* ========= Reset ========= */
btnReset.onclick=()=>{
  rowY=[]; wallsPerRow=[]; rois=[]; occ=[];
  resultsBody.innerHTML=''; clearOverlay(); preview.style.display='none'; photo.value='';
  setStatus('Reset. Upload a new photo.');
};

/* ========= util ========= */
function buildROIs(rowsY, perRowWalls, W, H){
  rois=[];
  const gaps=[]; for(let i=1;i<rowsY.length;i++) gaps.push(rowsY[i]-rowsY[i-1]);
  const avgGap=gaps.length?gaps.reduce((a,b)=>a+b,0)/gaps.length:H/6;
  for(let r=0;r<ROWS;r++){
    const yB=rowsY[r]; const gap=(r<ROWS-1?rowsY[r+1]-rowsY[r]:avgGap);
    const h=Math.max(10,Math.round(gap*SLOT_H_FRAC));
    const yT=Math.max(0,Math.round(yB - h - gap*SLOT_TOP_PAD));
    const yBot=Math.max(yT+8, Math.round(yB - gap*SLOT_TOP_PAD));
    const walls=perRowWalls[r];
    for(let c=0;c<COLS;c++){
      const x0=Math.round(walls[c]), x1=Math.round(walls[c+1]);
      rois.push({x:x0,y:yT,w:Math.max(1,x1-x0),h:yBot-yT,row:r,col:c});
    }
  }
}
function toImg(ev){
  const r=overlay.getBoundingClientRect();
  const dpr=window.devicePixelRatio||1;
  const cw=overlay.width/dpr, ch=overlay.height/dpr;
  const x=(ev.clientX-r.left)/cw*preview.naturalWidth;
  const y=(ev.clientY-r.top )/ch*preview.naturalHeight;
  return {x,y};
}
</script>
</body>
</html>
