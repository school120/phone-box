<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Phone Box Scanner ‚Äî Auto + Manual Fallback</title>
<style>
  :root{--bg:#0b1020;--card:#10183a;--mut:#9ab0e0}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:#fff;font-family:system-ui,-apple-system,Inter,Roboto,Segoe UI}
  header{padding:12px 16px;border-bottom:1px solid #ffffff22;font-weight:800}
  main{max-width:1200px;margin:0 auto;padding:12px;display:grid;grid-template-columns:1.15fr .85fr;gap:16px}
  .card{background:var(--card);border:1px solid #ffffff22;border-radius:16px;padding:14px}
  label{display:block;margin:8px 0 6px;color:var(--mut);font-size:14px}
  input[type=file],select,button{width:100%;padding:12px 14px;border-radius:12px;border:1px solid #ffffff33;background:#0f1738;color:#fff;font-size:16px}
  button.primary{background:linear-gradient(180deg,#3bc2f2,#1aa1d9);border:none;font-weight:800}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:10px}
  .pill{display:inline-block;padding:.25rem .6rem;border-radius:999px;background:#ffffff24;font-size:12px}
  #stage{position:relative;border:1px dashed #ffffff33;border-radius:12px;overflow:hidden;background:#0c1333;min-height:260px;touch-action:none}
  #preview{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:none;z-index:0}
  #overlay{position:absolute;inset:0;pointer-events:none;z-index:1}
  .handle{position:absolute;z-index:2;touch-action:none}
  .hline{width:100%;height:0;border-top:2px solid #32d0ff}
  .vwall{height:40px;width:0;border-left:3px solid #fff;top:8px}
  .dot{width:16px;height:16px;border-radius:50%;background:#ffd54a;border:2px solid #000;transform:translate(-50%,-50%)}
  .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:6px;margin:10px 0}
  .slot{background:#0f1738;border:1px solid #ffffff24;aspect-ratio:3/5;border-radius:8px;position:relative}
  .slot.present{outline:2px solid rgba(0,200,0,.85)}
  .slot.empty{outline:2px solid rgba(255,0,0,.85)}
  .slot span{position:absolute;inset:auto 6px 6px 6px;font-size:12px;color:#9ab0ff}
  table{width:100%;border-collapse:collapse;margin-top:10px}
  th,td{border-bottom:1px solid #ffffff19;padding:8px 6px;text-align:left}
  tr.missing{background:#ff50501a}
  details{margin-top:8px}
  @media (max-width: 900px){ main{grid-template-columns:1fr} header{font-size:18px} }
</style>
</head>
<body>
<header>üì± Phone Box ‚Äî Auto detection (normal) with **manual fallback** to place row lines and walls.</header>

<main>
  <section class="card">
    <div id="stage">
      <img id="preview" alt="preview">
      <canvas id="overlay"></canvas>
      <!-- manual fallback handles -->
      <div id="h1" class="handle hline" style="display:none;"></div>
      <div id="h2" class="handle hline" style="display:none;"></div>
      <div id="h3" class="handle hline" style="display:none;"></div>
      <div id="h4" class="handle hline" style="display:none;"></div>
      <div id="h5" class="handle hline" style="display:none;"></div>
      <div id="wl" class="handle vwall" style="display:none;left:20px;"></div>
      <div id="wr" class="handle vwall" style="display:none;right:20px;"></div>
      <div id="hint" class="handle dot" style="display:none;"></div>
    </div>

    <div class="toolbar">
      <span class="pill" id="status">Upload a photo to begin.</span>
      <span class="pill" id="modePill">Mode: Auto</span>
    </div>

    <div class="grid" id="miniGrid"></div>

    <table>
      <thead><tr><th>Slot</th><th>Expected</th><th>Status</th></tr></thead>
      <tbody id="results"></tbody>
    </table>
  </section>

  <section class="card">
    <label>Box</label>
    <select id="box"></select>

    <label>Roster CSV (auto-loads /data/roster.csv)</label>
    <div style="display:flex;gap:8px;align-items:center">
      <small id="rosterStatus">Loading‚Ä¶</small>
      <input id="rosterFile" type="file" accept=".csv">
    </div>

    <label>Upload photo</label>
    <input id="photo" type="file" accept="image/*" capture="environment">

    <div class="toolbar">
      <button id="btnAuto" class="primary" disabled>Auto detect (normal)</button>
      <button id="btnManual">Manual fallback</button>
      <button id="btnAnalyze">Analyze</button>
      <button id="btnReset">Reset</button>
      <label><input id="showGuides" type="checkbox" checked> Show guides</label>
    </div>

    <details>
      <summary>Advanced</summary>
      <label>Blue sensitivity (HSV Œî)</label>
      <input type="range" id="blueDelta" min="0" max="40" value="18">
      <small>Raise if auto can‚Äôt find all 5 blue bars.</small>
    </details>
  </section>
</main>

<!-- OpenCV.js -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script>
/* ----------------- constants & state ----------------- */
const ROWS=5, COLS=12, TOTAL=ROWS*COLS;
const stage = document.getElementById('stage');
const preview = document.getElementById('preview');
const overlay = document.getElementById('overlay'); const ctx = overlay.getContext('2d');
const statusEl = document.getElementById('status'); const modePill=document.getElementById('modePill');
const showGuides = document.getElementById('showGuides');
const btnAuto = document.getElementById('btnAuto'); const btnManual=document.getElementById('btnManual');
const btnAnalyze=document.getElementById('btnAnalyze'); const btnReset=document.getElementById('btnReset');
const photo = document.getElementById('photo'); const blueDelta=document.getElementById('blueDelta');
const resultsBody=document.getElementById('results'); const miniGrid=document.getElementById('miniGrid');
const rosterFile=document.getElementById('rosterFile'); const rosterStatus=document.getElementById('rosterStatus'); const boxSel=document.getElementById('box');

let cvReady=false, current=null;
let bars=[], wallsPerRow=[], rois=[], occ=[];
let manual=false; // fallback mode
let rowY = new Array(ROWS).fill(null); // y of blue bars (manual or auto)
let wallL=null, wallR=null;            // global walls (manual or auto)

const hEls=[...Array(5)].map((_,i)=>document.getElementById('h'+(i+1)));
const wlEl=document.getElementById('wl'), wrEl=document.getElementById('wr'), hintEl=document.getElementById('hint');

/* ----------------- UI helpers ----------------- */
function setStatus(t){ statusEl.textContent=t; }
function sizeOverlayToImage(w,h){
  const sw=stage.clientWidth, sh=Math.max(260, Math.round(sw*(h/w)));
  stage.style.height=sh+'px';
  const dpr=window.devicePixelRatio||1;
  overlay.width=Math.round(sw*dpr); overlay.height=Math.round(sh*dpr);
  overlay.style.width=sw+'px'; overlay.style.height=sh+'px';
  const scale=sw/w; ctx.setTransform(dpr*scale,0,0,dpr*scale,0,0);
}
function clearOverlay(){ ctx.clearRect(0,0,overlay.width,overlay.height); }
function line(x1,y1,x2,y2,style='rgba(50,208,255,.9)',lw=2){ ctx.strokeStyle=style; ctx.lineWidth=lw/(window.devicePixelRatio||1); ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }
function rect(r,style='rgba(255,255,255,.95)',lw=1.6){ ctx.strokeStyle=style; ctx.lineWidth=lw/(window.devicePixelRatio||1); ctx.strokeRect(r.x,r.y,r.w,r.h); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

/* ----------------- box list ----------------- */
(function fillBoxes(){
  const ids=[], grades=['9','10','11','12'], letters=['A','B','C','D','E','F'];
  grades.forEach(g=>letters.forEach(l=>ids.push(g+l))); ids.push('SM1','SM2');
  boxSel.innerHTML=ids.map(x=>`<option>${x}</option>`).join('');
})();

/* ----------------- roster ----------------- */
let roster=[];
function parseCSV(text){
  const rows=[]; let row=[],cur='',q=false; const push=()=>{row.push(cur);cur='';};
  for(let i=0;i<text.length;i++){
    const ch=text[i], nx=text[i+1];
    if(q){ if(ch==='"'&&nx==='"'){cur+='"';i++;} else if(ch==='"'){q=false;} else cur+=ch; }
    else{ if(ch==='"') q=true; else if(ch===',') push();
      else if(ch==='\n'||ch==='\r'){ if(ch==='\r'&&nx==='\n') i++; push(); rows.push(row); row=[]; }
      else cur+=ch; }
  } push(); if(row.length) rows.push(row);
  const header=rows.shift().map(h=>h.trim());
  return rows.filter(r=>r.some(x=>x&&x.trim()!=='')).map(r=>{const o={}; header.forEach((h,i)=>o[h]=r[i]||''); return o;});
}
async function loadRoster(){
  rosterStatus.textContent='Loading /data/roster.csv‚Ä¶';
  try{ const res=await fetch('/data/roster.csv',{cache:'no-store'}); if(res.ok){ roster=parseCSV(await res.text()); rosterStatus.textContent='Loaded ‚úì'; return; } }catch{}
  rosterStatus.textContent='Could not load /data/roster.csv (upload below).';
}
function namesForBox(id){
  const out={};
  for(const r of roster){
    const sec=(r['Security Number']||r['SecurityNumber']||'').toUpperCase().replace(/\s+/g,'');
    const m=sec.match(/^(SM\d|\d{1,2}[A-F])[- ]?(\d{1,2})$/);
    if(!m) continue; const box=m[1], slot=+m[2];
    if(box===id) out[slot]=r['Full Name']||r['FullName']||'';
  }
  return out;
}
loadRoster();
rosterFile.addEventListener('change',()=>{
  const f=rosterFile.files[0]; if(!f) return;
  const r=new FileReader(); r.onload=()=>{ roster=parseCSV(r.result||''); rosterStatus.textContent='Loaded from file ‚úì'; };
  r.readAsText(f);
});

/* ----------------- OpenCV lifecycle ----------------- */
let ready=false;
window.Module={onRuntimeInitialized(){ cvReady=true; btnAuto.disabled=false; setStatus('OpenCV ready. Upload a photo.'); }};
window.addEventListener('resize',()=>{ if(current) sizeOverlayToImage(current.mat.cols,current.mat.rows); });

/* ----------------- image load ----------------- */
photo.addEventListener('change', e=>{
  const f=e.target.files[0]; if(!f) return;
  const url=URL.createObjectURL(f);
  const im=new Image(); im.onload=()=>{
    preview.src=url; preview.style.display='block';
    const mat=cv.imread(im);
    current={mat};
    sizeOverlayToImage(mat.cols, mat.rows);
    resetEverything(false);
    setStatus('Photo loaded. Try ‚ÄúAuto detect (normal)‚Äù, or switch to Manual.');
  };
  im.onerror=()=>setStatus('Could not load image.');
  im.src=url;
});

/* ----------------- Auto mode ----------------- */
btnAuto.addEventListener('click', ()=>{
  if(!cvReady || !current) return alert('Need OpenCV & a photo.');
  manual=false; toggleHandles(false);
  modePill.textContent='Mode: Auto';

  const src=current.mat;
  const scale=1600/Math.max(src.cols,src.rows);
  const scaled=new cv.Mat();
  if(scale<1) cv.resize(src,scaled,new cv.Size(0,0),scale,scale,cv.INTER_AREA); else src.copyTo(scaled);

  // HSV ‚Üí blue bars
  const hsv=new cv.Mat(); cv.cvtColor(scaled,hsv,cv.COLOR_RGBA2RGB); cv.cvtColor(hsv,hsv,cv.COLOR_RGB2HSV);
  const delta=+blueDelta.value;
  const lower=new cv.Mat(hsv.rows,hsv.cols,hsv.type(),[100-delta,60,40,0]);
  const upper=new cv.Mat(hsv.rows,hsv.cols,hsv.type(),[130+delta,255,255,255]);
  const mask=new cv.Mat(); cv.inRange(hsv,lower,upper,mask);
  const k=cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(21,5));
  cv.morphologyEx(mask,mask,cv.MORPH_CLOSE,k);
  cv.morphologyEx(mask,mask,cv.MORPH_OPEN,k);

  const contours=new cv.MatVector(), hier=new cv.Mat();
  cv.findContours(mask,contours,hier,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);
  bars=[];
  for(let i=0;i<contours.size();i++){
    const r=cv.boundingRect(contours.get(i)); const ar=r.width/r.height;
    if(r.width>scaled.cols*0.35 && r.height>6 && ar>8) bars.push(r);
  }
  bars.sort((a,b)=>a.y-b.y);
  if(bars.length>ROWS) bars=bars.slice(0,ROWS);
  if(bars.length<ROWS){ setStatus('Could not find 5 blue bars. Raise Blue sensitivity or use Manual.'); cleanup(); return; }

  const rowsY = bars.map(b=>b.y+b.height/2);
  rowY = rowsY.map(v=>v); // for analysis & overlay

  // find vertical separators per row using Hough lines
  wallsPerRow=[];
  for(const b of bars){
    const roi=scaled.roi(new cv.Rect(Math.max(0,b.x-20), Math.max(0,b.y-8), Math.min(scaled.cols-b.x+20,b.width+40), Math.min(scaled.rows-b.y+16,b.height+16)));
    const gray=new cv.Mat(); cv.cvtColor(roi,gray,cv.COLOR_RGBA2GRAY);
    const edges=new cv.Mat(); cv.Canny(gray,edges,60,160,3,true);
    const lines=new cv.Mat(); cv.HoughLinesP(edges,lines,1,Math.PI/180,30,18,6);
    let xs=[];
    for(let i=0;i<lines.rows;i++){
      const [x1,y1,x2,y2]=lines.intPtr(i);
      const ang=Math.abs(Math.atan2(y2-y1,x2-x1)*180/Math.PI);
      if(ang>80) xs.push((x1+x2)/2 + (b.x-20));
    }
    xs.sort((a,b)=>a-b);
    let walls;
    if(xs.length>=10){
      const samples=new cv.Mat(xs.length,1,cv.CV_32F);
      for(let i=0;i<xs.length;i++) samples.floatPtr(i,0)[0]=xs[i];
      const labels=new cv.Mat(), centers=new cv.Mat();
      cv.kmeans(samples,13,labels,new cv.TermCriteria(cv.TermCriteria_EPS+cv.TermCriteria_MAX_ITER,20,1.0),3,cv.KMEANS_PP_CENTERS,centers);
      walls = Array.from({length:13},(_,i)=>centers.floatPtr(i,0)[0]).sort((a,b)=>a-b);
      samples.delete(); labels.delete(); centers.delete();
    }else{
      walls = Array.from({length:13},(_,i)=> b.x + i*(b.width)/12 );
    }
    wallsPerRow.push(walls);
    gray.delete(); edges.delete(); lines.delete(); roi.delete();
  }

  buildROIsFromRowsAndWalls(rowsY, wallsPerRow, scaled.cols, scaled.rows);
  drawGuides(rowsY, wallsPerRow, scaled.cols, scaled.rows);
  setStatus('Auto done. If alignment is off, click ‚ÄúManual fallback‚Äù and drag the lines.');
  cleanup();
  function cleanup(){ [scaled,hsv,mask,lower,upper,contours,hier].forEach(m=>{try{m.delete()}catch{}}); }
});

/* ----------------- Manual fallback ----------------- */
btnManual.addEventListener('click', ()=>{
  if(!current) return alert('Upload a photo first.');
  manual=true; modePill.textContent='Mode: Manual';
  setStatus('Drag the 5 cyan row lines so they sit ON the blue bars with numbers. Drag white walls to 1 and 12. Then ‚ÄúAnalyze‚Äù.');

  // show handles
  toggleHandles(true);
  // initial placement: equal spacing for rows, walls near edges
  const H=current.mat.rows, W=current.mat.cols;
  for(let i=0;i<ROWS;i++){ rowY[i]=Math.round((i+1)*(H/(ROWS+1))); }
  wallL=Math.round(W*0.08); wallR=Math.round(W*0.92);
  layoutHandles(); drawGuidesFromManual();
});

function toggleHandles(show){
  [...hEls, wlEl, wrEl].forEach(el=>{ el.style.display = show? 'block':'none'; });
  hintEl.style.display = show? 'block':'none';
}
function layoutHandles(){
  // position DOM handles in image coordinates
  const stageRect=overlay.getBoundingClientRect();
  const scale = stageRect.width / (overlay.width/(window.devicePixelRatio||1));
  // translate image y to CSS top
  const yToTop = y => (y * scale) + stageRect.top, xToLeft = x => (x * scale) + stageRect.left;

  // set widths to container width
  hEls.forEach((el,i)=>{
    el.style.left = 0;
    el.style.width='100%';
    el.style.top = (rowY[i] * (stageRect.height / (overlay.height/(window.devicePixelRatio||1)))) + 'px';
  });
  wlEl.style.left = (wallL * (stageRect.width / (overlay.width/(window.devicePixelRatio||1)))) + 'px';
  wrEl.style.left = (wallR * (stageRect.width / (overlay.width/(window.devicePixelRatio||1)))) + 'px';
}
function drawGuidesFromManual(){
  const W=current.mat.cols, H=current.mat.rows;
  const rowsY=rowY.map(y=>y);
  const walls = Array.from({length:13},(_,i)=>wallL + i*(wallR-wallL)/12);
  const perRow = Array.from({length:ROWS},()=>walls);
  buildROIsFromRowsAndWalls(rowsY, perRow, W, H);
  drawGuides(rowsY, perRow, W, H);
}

// drag logic
let dragging=null; // {type:'row'|'wl'|'wr', idx}
stage.addEventListener('pointerdown', e=>{
  if(!manual) return;
  const r=overlay.getBoundingClientRect();
  const ix = (e.clientX - r.left) / (overlay.width/(window.devicePixelRatio||1)) * current.mat.cols;
  const iy = (e.clientY - r.top ) / (overlay.height/(window.devicePixelRatio||1)) * current.mat.rows;

  // find nearest row line or walls (hitboxes)
  for(let i=0;i<ROWS;i++){
    if(Math.abs(iy-rowY[i]) < 20){ dragging={type:'row',idx:i}; return; }
  }
  if(Math.abs(ix-wallL) < 20){ dragging={type:'wl'}; return; }
  if(Math.abs(ix-wallR) < 20){ dragging={type:'wr'}; return; }
});
stage.addEventListener('pointermove', e=>{
  if(!manual || !dragging) return;
  const r=overlay.getBoundingClientRect();
  const ix = (e.clientX - r.left) / (overlay.width/(window.devicePixelRatio||1)) * current.mat.cols;
  const iy = (e.clientY - r.top ) / (overlay.height/(window.devicePixelRatio||1)) * current.mat.rows;
  if(dragging.type==='row'){ rowY[dragging.idx]=clamp(Math.round(iy), 0, current.mat.rows-1); }
  if(dragging.type==='wl'){ wallL=clamp(Math.round(ix), 0, wallR-20); }
  if(dragging.type==='wr'){ wallR=clamp(Math.round(ix), wallL+20, current.mat.cols-1); }
  layoutHandles(); drawGuidesFromManual();
});
window.addEventListener('pointerup', ()=> dragging=null);

/* ----------------- Build ROIs & draw ----------------- */
function buildROIsFromRowsAndWalls(rowsY, perRowWalls, W, H){
  rois=[];
  const gaps=[]; for(let i=1;i<rowsY.length;i++) gaps.push(rowsY[i]-rowsY[i-1]);
  const avgGap = gaps.length? gaps.reduce((a,b)=>a+b,0)/gaps.length : H/6;

  for(let r=0;r<ROWS;r++){
    const yB = rowsY[r];
    const gap = (r<ROWS-1? rowsY[r+1]-rowsY[r] : avgGap);
    const h   = Math.max(12, Math.round(gap*0.70));
    const yT  = Math.max(0, Math.round(yB - h));
    const walls = perRowWalls[r];
    for(let c=0;c<COLS;c++){
      const x0=Math.round(walls[c]), x1=Math.round(walls[c+1]);
      rois.push({x:x0,y:yT,w:Math.max(1,x1-x0),h:yB-yT,row:r,col:c});
    }
  }
}
function drawGuides(rowsY, perRowWalls, W, H){
  sizeOverlayToImage(W,H);
  clearOverlay();
  if(showGuides.checked){
    rowsY.forEach(y => line(0,y,W,y,'rgba(50,208,255,.95)',2));
    perRowWalls.forEach(w=>w.forEach(x=>line(x,10,x,28,'rgba(255,255,255,.85)',2)));
  }
  rois.forEach(r=>rect(r));
}

/* ----------------- Analyze ----------------- */
btnAnalyze.addEventListener('click', ()=>{
  if(!current || rois.length!==TOTAL){ return alert('Need rows & slots. Use Auto or Manual first.'); }
  occ = rois.map(r => detectCap(current.mat, r));
  paintOverlay();
  const names = namesForBox(boxSel.value||'');
  resultsBody.innerHTML='';
  for(let i=0;i<TOTAL;i++){
    const slot=i+1, expected=names[slot]||'';
    const status = occ[i] ? (expected?'present':'unexpected phone') : (expected?'missing':'empty');
    const tr=document.createElement('tr');
    tr.className = status==='missing'?'missing':(status==='present'?'ok':'');
    tr.innerHTML=`<td>${slot}</td><td>${expected}</td><td><span class="pill">${status}</span></td>`;
    resultsBody.appendChild(tr);
  }
  [...miniGrid.children].forEach((d,i)=>{ d.classList.toggle('present',!!occ[i]); d.classList.toggle('empty',!occ[i]); });
  setStatus('Done: Green = phone, Red = empty.');
});
function paintOverlay(){
  clearOverlay();
  for(let i=0;i<rois.length;i++){
    const r=rois[i]; ctx.fillStyle = occ[i] ? 'rgba(0,200,0,.35)' : 'rgba(255,0,0,.35)';
    ctx.fillRect(r.x,r.y,r.w,r.h); rect(r,'rgba(255,255,255,.95)',1.4);
  }
}

/* ----------------- Seam detector (robust) ----------------- */
function detectCap(img, r){
  const roi = img.roi(new cv.Rect(r.x, r.y, r.w, r.h));
  const gray = new cv.Mat(); cv.cvtColor(roi, gray, cv.COLOR_RGBA2GRAY);

  const y0=Math.round(r.h*0.06), y1=Math.round(r.h*0.60), xL=Math.round(r.w*0.08), xR=Math.round(r.w*0.92);
  const search = gray.roi(new cv.Rect(xL, y0, Math.max(12,xR-xL), Math.max(12,y1-y0)));

  const sob16=new cv.Mat(), sob=new cv.Mat();
  cv.Sobel(search, sob16, cv.CV_16S, 0, 1, 3, 1, 0, cv.BORDER_DEFAULT);
  cv.convertScaleAbs(sob16, sob);
  const blur=new cv.Mat(); cv.GaussianBlur(sob, blur, new cv.Size(3,3), 0);
  const thr=new cv.Mat(); cv.threshold(blur, thr, 0, 255, cv.THRESH_BINARY|cv.THRESH_OTSU);

  const hS=thr.rows, wS=thr.cols;
  const rowFrac=new Float32Array(hS);
  for(let y=0;y<hS;y++){ const p=thr.ptr(y); let c=0; for(let x=0;x<wS;x++) if(p[x]) c++; rowFrac[y]=c/wS; }
  const sm=new Float32Array(hS);
  for(let y=0;y<hS;y++){ let s=0,c=0; for(let k=-3;k<=3;k++){ const yy=y+k; if(yy>=0&&yy<hS){ s+=rowFrac[yy]; c++; } } sm[y]=s/c; }
  let peakY=0, peakVal=-1; for(let y=0;y<hS;y++){ if(sm[y]>peakVal){ peakVal=sm[y]; peakY=y; } }
  const seamCoverage=peakVal; const seamY=y0+peakY;

  // Foam baseline & dark check below seam
  const refTopH=Math.max(4,Math.round(r.h*0.10));
  const refTop = gray.roi(new cv.Rect(Math.round(r.w*0.10), 0, Math.round(r.w*0.80), refTopH));
  const refL   = gray.roi(new cv.Rect(0, y0, Math.max(5,Math.round(r.w*0.10)), Math.max(8,Math.round(r.h*0.25))));
  const refR   = gray.roi(new cv.Rect(r.w-Math.max(5,Math.round(r.w*0.10)), y0, Math.max(5,Math.round(r.w*0.10)), Math.max(8,Math.round(r.h*0.25))));
  const stats = m => { const mm=new cv.Mat(), ss=new cv.Mat(); cv.meanStdDev(m,mm,ss); const o={mean:mm.doubleAt(0,0), std:ss.doubleAt(0,0)}; mm.delete(); ss.delete(); return o; };
  const a=stats(refTop), b=stats(refL), c=stats(refR);
  const foamMean=(a.mean+b.mean+c.mean)/3, foamStd=Math.max(6,(a.std+b.std+c.std)/3);

  const bandTop=Math.min(r.h-4, seamY + Math.round(r.h*0.02));
  const bandH=Math.max(6, Math.round(r.h*0.18));
  const bandY=Math.min(r.h-bandH, bandTop);
  const band=gray.roi(new cv.Rect(Math.round(r.w*0.12), bandY, Math.round(r.w*0.76), bandH));
  const bm=new cv.Mat(), bs=new cv.Mat(); cv.meanStdDev(band,bm,bs);
  const bMean=bm.doubleAt(0,0); bm.delete(); bs.delete();
  const darkThr = foamMean - 0.9*foamStd - 9;
  let darkCnt=0; for(let y=0;y<band.rows;y++){ const p=band.ptr(y); for(let x=0;x<band.cols;x++) if(p[x]<darkThr) darkCnt++; }
  const bandDarkFrac = darkCnt / (band.rows*band.cols);

  const present = (seamCoverage>=0.32 && (foamMean-bMean>=8 || bandDarkFrac>=0.20)) || (seamCoverage>=0.44);

  // cleanup
  roi.delete(); gray.delete(); search.delete(); sob16.delete(); sob.delete(); blur.delete(); thr.delete();
  refTop.delete(); refL.delete(); refR.delete(); band.delete();
  return present;
}

/* ----------------- misc ----------------- */
btnReset.addEventListener('click', ()=> resetEverything(true));
function resetEverything(hideImage){
  bars=[]; wallsPerRow=[]; rois=[]; occ=[]; rowY=new Array(ROWS).fill(null); wallL=null; wallR=null;
  toggleHandles(false); manual=false; modePill.textContent='Mode: Auto';
  resultsBody.innerHTML=''; clearOverlay();
  if(hideImage){ preview.style.display='none'; current=null; }
  setStatus('Reset.');
}

/* mini grid */
(function initGrid(){ for(let i=0;i<TOTAL;i++){ const d=document.createElement('div'); d.className='slot'; d.innerHTML=`<span>#${i+1}</span>`; miniGrid.appendChild(d);} })();
</script>
</body>
</html>
