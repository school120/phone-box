<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Phone Box Overlay + Roster (12Ã—5) â€” Mobile</title>

<!-- Dependencies -->
<script defer src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.3/dist/tesseract.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

<style>
  :root{--bg:#0b1020;--card:#11183a;--muted:#9ab0e0;--accent:#32d0ff}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:#fff;font-family:system-ui,-apple-system,Inter,Roboto,Segoe UI}
  header{padding:14px 16px;border-bottom:1px solid #ffffff1a;font-weight:800}
  main{max-width:1200px;margin:0 auto;padding:12px;display:grid;grid-template-columns:1.1fr 0.9fr;gap:16px}
  .card{background:var(--card);border:1px solid #ffffff1a;border-radius:16px;padding:14px;box-shadow:0 10px 30px #0008}
  label{display:block;margin:10px 0 6px;color:var(--muted);font-size:14px}
  input[type="file"], select, button{width:100%;padding:14px 16px;border-radius:12px;border:1px solid #ffffff2b;background:#0f1738;color:#fff;font-size:16px}
  button.primary{background:linear-gradient(180deg,#3bc2f2,#1aa1d9);border:none;font-weight:800}
  small{color:var(--muted)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  #stage{position:relative;border:1px dashed #ffffff33;border-radius:12px;overflow:hidden;background:#0c1333}
  #img{width:100%;display:none}
  #overlay{position:absolute;inset:0;pointer-events:none}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:12px}
  .pill{display:inline-block;padding:.2rem .6rem;border-radius:999px;background:#ffffff24;font-size:12px}
  .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:6px;margin:10px 0}
  .slot{background:#0f1738;border:1px solid #ffffff24;aspect-ratio:3/5;border-radius:8px;position:relative}
  .slot span{position:absolute;inset:auto 6px 6px 6px;font-size:12px;color:#9ab0ff}
  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid #ffffff1f;padding:10px 6px;text-align:left}
  tr.missing{background:#ff50501a}
  tr.ok{opacity:.9}
  .hint{font-size:13px;color:#9ab0ff}
  @media (max-width: 900px){
    main{grid-template-columns:1fr}
    header{font-size:18px}
    .row{grid-template-columns:1fr}
  }
</style>
</head>
<body>
<header>ðŸ“± Phone Box Overlay + Roster (auto numbers â†’ 12Ã—5) â€” Mobile</header>

<main>
  <section class="card" id="left">
    <div id="stage">
      <img id="img" alt="preview">
      <canvas id="overlay"></canvas>
    </div>
    <div class="grid" id="boxGrid"></div>
    <table>
      <thead><tr><th>Slot</th><th>Expected</th><th>Status</th></tr></thead>
      <tbody id="results"></tbody>
    </table>
  </section>

  <section class="card">
    <label>Box</label>
    <select id="box"></select>

    <label style="margin-top:10px">Roster source</label>
    <select id="rosterSource">
      <option value="repo">Use ./data/roster.csv (repo)</option>
      <option value="upload">Upload CSVâ€¦</option>
    </select>
    <input id="rosterFile" type="file" accept=".csv" style="display:none;margin-top:6px"/>

    <label style="margin-top:10px">Upload a box photo</label>
    <input id="photo" type="file" accept="image/*" capture="environment">

    <div class="row" style="margin-top:10px">
      <div>
        <label>Row height % (above numbers)</label>
        <input id="rowPct" type="range" min="45" max="95" step="5" value="70">
      </div>
      <div>
        <label>Edge crop % (ignore sides)</label>
        <input id="edgePct" type="range" min="0" max="15" step="1" value="5">
      </div>
    </div>

    <div class="toolbar">
      <button id="scan" class="primary">Scan & Overlay</button>
      <button id="analyze" disabled>Analyze & Compare</button>
    </div>

    <div class="toolbar">
      <label class="hint"><input id="fastMode" type="checkbox" style="vertical-align:middle"> Fast mode (skip OCR; equal 12 per row)</label>
      <span id="progress" class="pill"></span>
    </div>

    <small id="status"></small>
  </section>
</main>

<script>
/* ===== State & UI ===== */
const img = document.getElementById('img');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');

const statusEl = document.getElementById('status');
const progressEl = document.getElementById('progress');

const showRowHeight = ()=> parseInt(document.getElementById('rowPct').value,10)/100;
const showEdgeCrop  = ()=> parseInt(document.getElementById('edgePct').value,10)/100;
const fastModeEl = document.getElementById('fastMode');

const analyzeBtn = document.getElementById('analyze');
const scanBtn = document.getElementById('scan');
const rosterSource = document.getElementById('rosterSource');
const rosterFile = document.getElementById('rosterFile');
const boxSel = document.getElementById('box');
const resultsBody = document.getElementById('results');
const boxGrid = document.getElementById('boxGrid');

let current=null;         // {image, W, H}
let rowTops=[];           // 5 y-positions
let boundsByRow=[];       // 5Ã—13 ints
let LR=[];                // 5Ã—[L,R] (in pixels)
let rois=[];              // 60 rects {x,y,w,h,row,col}
let roster=[];            // CSV rows
let worker=null;          // Tesseract worker
let workerReady=false;

/* ===== Boxes ===== */
(function fillBoxes(){
  const ids=[], grades=['9','10','11','12'], letters=['A','B','C','D','E','F'];
  grades.forEach(g=>letters.forEach(l=>ids.push(g+l)));
  ids.push('SM1','SM2');
  boxSel.innerHTML = ids.map(x=>`<option>${x}</option>`).join('');
})();

/* ===== Roster ===== */
rosterSource.addEventListener('change', ()=>{
  rosterFile.style.display = rosterSource.value==='upload' ? 'block' : 'none';
  if(rosterSource.value==='repo') loadRosterFromRepo();
});
rosterFile.addEventListener('change', ()=>{
  if(rosterFile.files[0]) loadRosterFromFile(rosterFile.files[0]);
});
function loadRosterFromRepo(){
  Papa.parse('./data/roster.csv', {download:true, header:true, complete:(r)=>{ roster=r.data||[]; setStatus('Roster loaded from repo.'); }});
}
function loadRosterFromFile(f){
  Papa.parse(f, {header:true, complete:(r)=>{ roster=r.data||[]; setStatus('Roster loaded from file.'); }});
}
loadRosterFromRepo();

/* ===== Photo ===== */
document.getElementById('photo').addEventListener('change', (e)=>{
  const f = e.target.files[0]; if(!f) return;
  const url = URL.createObjectURL(f);
  const im = new Image();
  im.onload = () => {
    current = { image: im, W: im.naturalWidth, H: im.naturalHeight };
    img.src = url; img.style.display='block';
    fitCanvas();
    setStatus('Photo loaded. Tap â€œScan & Overlayâ€.');
  };
  im.src = url;
});

function fitCanvas(){
  if(!current) return;
  const stage = document.getElementById('stage').getBoundingClientRect();
  const W = stage.width;
  const H = W * (current.H / current.W);
  overlay.width = W; overlay.height = H;
  document.getElementById('left').style.aspectRatio = `${current.W}/${current.H}`;
  draw();
}
window.addEventListener('resize', fitCanvas);

function setStatus(t){ statusEl.textContent = t||''; }
function setProgress(t){ progressEl.textContent = t||''; }

/* ===== Scan & Overlay ===== */
scanBtn.addEventListener('click', async ()=>{
  if(!current){ alert('Upload a photo first.'); return; }
  analyzeBtn.disabled = true;
  setStatus('Scanningâ€¦'); setProgress('preparing');

  // 1) Detect 5 blue bars (fast)
  rowTops = await findBlueBars(current.image, showEdgeCrop());
  if(rowTops.length!==5){ setStatus('Could not find 5 blue bars. Try a straighter photo or adjust Edge crop %.'); draw(); return; }
  setProgress('found rows');

  // 2) For each row: find L/R from blue content (fast, no OCR)
  LR = await findLRForRows(current.image, rowTops, showEdgeCrop());
  // 3) Bounds: OCR centers if available; fallback to equal 12 within L/R.
  boundsByRow = [];

  const useOCR = !fastModeEl.checked;
  if(useOCR){
    await ensureWorker(); // try to init; if fails, we continue with fallback
  }

  const gaps=[]; for(let i=1;i<rowTops.length;i++) gaps.push(rowTops[i]-rowTops[i-1]);
  const avgGap = gaps.reduce((a,b)=>a+b,0)/gaps.length;
  const bandH = Math.max(20, Math.round(avgGap*0.32));

  for(let r=0;r<5;r++){
    setProgress(`row ${r+1}/5`);
    const [L,R] = LR[r];

    if(useOCR && workerReady){
      const y0 = Math.max(0, rowTops[r]-3);
      const y1 = Math.min(current.H-1, rowTops[r] + bandH);
      const crop = cropRectCanvas(current.image, 0, y0, current.W, y1-y0+1);

      // Per-row timeout so we never get stuck
      const rowResult = await withTimeout(recognizeDigits(crop), 6000).catch(()=>null);

      let centers=null;
      if(rowResult && rowResult.length){
        const xs = rowResult.map(o=>o.x).sort((a,b)=>a-b);
        centers = normalizeToTwelve(xs);
      }

      if(centers){
        const bounds = toBoundsFromCenters(centers, L, R);
        boundsByRow.push(bounds);
      }else{
        boundsByRow.push(equalBounds(L, R, 12));
      }
    } else {
      boundsByRow.push(equalBounds(L, R, 12));
    }
  }

  // 4) Build ROIs above each row
  rois = [];
  const pct = showRowHeight();
  for(let r=0;r<5;r++){
    const yBottom = rowTops[r];
    const yTop = Math.max(0, Math.round(yBottom - avgGap*pct));
    const b = boundsByRow[r];
    for(let i=0;i<12;i++){
      const x0=b[i], x1=b[i+1];
      const inset = Math.round((x1-x0)*0.10); // avoid the foam walls
      rois.push({ x:x0+inset, y:yTop, w:Math.max(1,(x1-x0-2*inset)), h:yBottom-yTop, row:r, col:i });
    }
  }

  draw();
  analyzeBtn.disabled = false;
  setProgress('ready'); setStatus('Overlay ready. Tap â€œAnalyze & Compareâ€.');
});

/* ===== Analyze & Compare ===== */
analyzeBtn.addEventListener('click', ()=>{
  if(!rois.length) return alert('Scan & Overlay first.');
  if(!boxSel.value) return alert('Choose a Box (e.g., 9B, 10C, SM1).');
  if(!roster || roster.length===0) return alert('Load the roster (repo CSV or upload).');

  const names = namesForBox(boxSel.value);
  drawNamesGrid(names);

  const rows=[];
  for(let i=0;i<rois.length;i++){
    const slot = i+1;
    const expected = names[slot] || '';
    const occ = slotOccupied(cropROI(rois[i]));
    const status = occ ? (expected?'present':'unexpected phone') : (expected?'missing':'empty');
    rows.push({slot, expected, status});
  }

  resultsBody.innerHTML='';
  rows.forEach(r=>{
    const tr=document.createElement('tr');
    tr.className = r.status==='missing' ? 'missing' : (r.status==='present' ? 'ok' : '');
    tr.innerHTML=`<td>${r.slot}</td><td>${r.expected||''}</td><td><span class="pill">${r.status}</span></td>`;
    resultsBody.appendChild(tr);
  });
  setStatus('Compared to roster.');
});

/* ===== Drawing ===== */
function draw(){
  ctx.clearRect(0,0,overlay.width,overlay.height);
  if(!current) return;
  const sx = overlay.width/current.W, sy = overlay.height/current.H;

  // cyan row lines
  if(rowTops.length){
    ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--accent')||'#32d0ff';
    ctx.lineWidth=2;
    for(const y of rowTops){
      ctx.beginPath(); ctx.moveTo(0, y*sy); ctx.lineTo(overlay.width, y*sy); ctx.stroke();
    }
  }
  // L/R ticks (yellow) & white bounds
  if(boundsByRow.length){
    for(let r=0;r<5;r++){
      const y=rowTops[r]*sy;
      // L/R
      if(LR[r]){
        ctx.strokeStyle='#ffd84a'; ctx.lineWidth=1.5;
        const [L,Rr]=LR[r];
        const h=40;
        ctx.beginPath(); ctx.moveTo(L*sx,y-h); ctx.lineTo(L*sx,y+h); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(Rr*sx,y-h); ctx.lineTo(Rr*sx,y+h); ctx.stroke();
      }
      // bounds
      ctx.strokeStyle='#fff'; ctx.lineWidth=1.5;
      boundsByRow[r].forEach(x=>{
        const xx=x*sx; ctx.beginPath(); ctx.moveTo(xx, y-40); ctx.lineTo(xx, y+40); ctx.stroke();
      });
    }
  }
  // slot rectangles
  if(rois.length){
    ctx.strokeStyle='rgba(255,255,255,.95)'; ctx.lineWidth=2;
    for(const r of rois){ ctx.strokeRect(r.x*sx, r.y*sy, r.w*sx, r.h*sy); }
  }
}

/* ===== Roster helpers ===== */
function namesForBox(boxId){
  const out={};
  for(const row of roster){
    const sec = (row['Security Number']||row['SecurityNumber']||'').toString().toUpperCase().replace(/\s+/g,'');
    const m = sec.match(/^(SM\d|\d{1,2}[A-F])[- ]?(\d{1,2})$/);
    if(!m) continue;
    const box=m[1], slot=parseInt(m[2],10);
    if(box===boxId) out[slot] = row['Full Name']||row['FullName']||'';
  }
  return out;
}
function drawNamesGrid(namesBySlot={}){
  boxGrid.innerHTML='';
  for(let r=0;r<5;r++){
    for(let c=0;c<12;c++){
      const idx=r*12+c+1;
      const d=document.createElement('div'); d.className='slot';
      const s=document.createElement('span'); s.textContent=namesBySlot[idx]||`#${idx}`;
      d.appendChild(s); boxGrid.appendChild(d);
    }
  }
}

/* ===== Image color + geometry ===== */
function cropRectCanvas(imgEl, x,y,w,h){
  const c=document.createElement('canvas'); c.width=w; c.height=h;
  c.getContext('2d').drawImage(imgEl, x,y,w,h, 0,0,w,h);
  return c;
}
function rgb2hsv(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b), d=max-min;
  let h=0; if(d!==0){ if(max===r) h=((g-b)/d)%6; else if(max===g) h=(b-r)/d+2; else h=(r-g)/d+4; h*=60; if(h<0) h+=360; }
  const s=max===0?0:d/max, v=max; return {h,s,v};
}

/* ---- Blue bar detection (fast) ---- */
async function findBlueBars(imgEl, edgeCrop){
  const maxW=1200;
  const r=Math.min(1, maxW/imgEl.naturalWidth);
  const W=Math.round(imgEl.naturalWidth*r), H=Math.round(imgEl.naturalHeight*r);
  const c=document.createElement('canvas'); c.width=W; c.height=H;
  c.getContext('2d').drawImage(imgEl,0,0,W,H);
  const {data}=c.getContext('2d').getImageData(0,0,W,H);

  const hueMin=190, hueMax=265, sMin=0.30, vMin=0.22;
  const x0=Math.round(W*edgeCrop), x1=Math.round(W*(1-edgeCrop));
  const frac=new Float32Array(H);

  for(let y=0;y<H;y++){
    let cnt=0, blue=0;
    for(let x=x0;x<=x1;x+=2){
      const i=(y*W+x)*4; const {h,s,v}=rgb2hsv(data[i],data[i+1],data[i+2]);
      if((h>hueMin&&h<hueMax)&&s>=sMin&&v>=vMin) blue++; cnt++;
    }
    frac[y]=cnt?blue/cnt:0;
  }
  const s = smooth(frac,6);
  const peaks = topPeaks(s,5,Math.round(H/8));
  const win=Math.round(H*0.035), tops=[];
  for(const p of peaks){
    let M=0; for(let y=Math.max(0,p-win); y<=Math.min(H-1,p+win); y++) M=Math.max(M,s[y]);
    const T=M*0.5;
    let top=p; for(let y=p;y>=0;y--){ if(s[y]>=T) top=y; else break; }
    tops.push(top);
  }
  return tops.sort((a,b)=>a-b).map(y=>Math.round(y/r));
}
function smooth(a,w){const o=new Float32Array(a.length); for(let i=0;i<a.length;i++){let s=0,c=0; for(let k=-w;k<=w;k++){const j=i+k; if(j<0||j>=a.length) continue; s+=a[j]; c++;} o[i]=s/c;} return o;}
function topPeaks(s,count,minDist){const idx=[...s].map((v,i)=>[v,i]).sort((a,b)=>b[0]-a[0]); const out=[]; for(const [,i] of idx){ if(out.every(j=>Math.abs(j-i)>minDist)) out.push(i); if(out.length>=count) break; } return out.sort((a,b)=>a-b);}

/* ---- Per-row L/R from blue content ---- */
async function findLRForRows(imgEl, tops, edgeCrop){
  const maxW=1200; const r=Math.min(1, maxW/imgEl.naturalWidth);
  const W=Math.round(imgEl.naturalWidth*r), H=Math.round(imgEl.naturalHeight*r);
  const can=document.createElement('canvas'); can.width=W; can.height=H; const g=can.getContext('2d'); g.drawImage(imgEl,0,0,W,H);
  const im=g.getImageData(0,0,W,H);
  const scaleX = imgEl.naturalWidth/W;

  // estimate band height
  const gaps=[]; for(let i=1;i<tops.length;i++) gaps.push((tops[i]-tops[i-1])*r);
  const avgGap = gaps.reduce((a,b)=>a+b,0)/gaps.length || H/5;
  const bandH = Math.max(6, Math.round(avgGap*0.22));

  const out=[];
  for(const yBig of tops){
    const ySm = Math.max(0, Math.round(yBig*r));
    const col = blueAmountByColumn(im, ySm+1, Math.min(H-1, ySm+bandH));
    const [L,R]=largestRun(col, Math.round(W*edgeCrop));
    out.push([ Math.round(L*scaleX), Math.round(R*scaleX) ]);
  }
  return out;
}
function blueAmountByColumn(im, y0,y1){
  const {data,width:W}=im; const col=new Float32Array(W).fill(0);
  for(let x=0;x<W;x++){
    let s=0; for(let y=y0;y<=y1;y++){
      const i=(y*W+x)*4; const {h,s:S,v}=rgb2hsv(data[i],data[i+1],data[i+2]);
      if((h>190&&h<265)&&S>=0.30&&v>=0.22) s++;
    }
    col[x]=s;
  }
  return smooth(col,6);
}
function largestRun(col, pad){
  const W=col.length, L=pad, R=W-pad-1;
  const thr = quantile([...col].slice(L,R+1), 0.55);
  const mask=new Uint8Array(W);
  for(let x=L;x<=R;x++) mask[x]=col[x]>=thr?1:0;
  // pick widest contiguous run
  let best=[L,R], width=0, s=null;
  for(let x=L;x<=R;x++){
    if(mask[x] && s===null) s=x;
    if((!mask[x] || x===R) && s!==null){
      const e = (!mask[x] && x> L) ? x-1 : x;
      const w=e-s; if(w>width){width=w; best=[s,e];}
      s=null;
    }
  }
  return best;
}
function quantile(a,q){const b=[...a].sort((x,y)=>x-y); const i=Math.max(0,Math.min(b.length-1,Math.floor(q*(b.length-1)))); return b[i];}

/* ---- Bounds helpers ---- */
function equalBounds(L,R,n){ const step=(R-L)/n; const b=[Math.round(L)]; for(let i=1;i<n;i++) b.push(Math.round(L+i*step)); b.push(Math.round(R)); return b; }
function normalizeToTwelve(centers){
  centers=centers.slice().sort((a,b)=>a-b);
  while(centers.length>12){ // merge closest
    let bi=0, best=1e9; for(let i=0;i<centers.length-1;i++){const g=centers[i+1]-centers[i]; if(g<best){best=g;bi=i;}}
    centers.splice(bi,2,(centers[bi]+centers[bi+1])/2);
  }
  while(centers.length<12){ // insert in widest gap
    let bi=0, best=-1; for(let i=0;i<centers.length-1;i++){const g=centers[i+1]-centers[i]; if(g>best){best=g;bi=i;}}
    centers.splice(bi+1,0,(centers[bi]+centers[bi+1])/2);
  }
  return centers;
}
function toBoundsFromCenters(centers, L, R){
  const bounds=[];
  const stepAvg=(centers[11]-centers[0])/11;
  bounds.push(Math.max(L, Math.round(centers[0]-stepAvg/2)));
  for(let i=0;i<11;i++) bounds.push(Math.round((centers[i]+centers[i+1])/2));
  bounds.push(Math.min(R, Math.round(centers[11]+stepAvg/2)));
  // ensure monotonic and inside [L..R]
  bounds[0]=Math.max(bounds[0], L);
  for(let i=1;i<bounds.length;i++) bounds[i]=Math.max(bounds[i], bounds[i-1]+1);
  bounds[bounds.length-1]=Math.min(bounds[bounds.length-1], R);
  return bounds;
}

/* ---- OCR (robust, non-blocking) ---- */
async function ensureWorker(){
  if(workerReady) return;
  try{
    setProgress('loading OCRâ€¦');
    worker = await Tesseract.createWorker({ logger: m => { if(m.status) setProgress(m.status.replace('_',' ') ) }});
    await worker.loadLanguage('eng');
    await worker.initialize('eng');
    await worker.setParameters({
      tessedit_char_whitelist: '0123456789',
      tessedit_pageseg_mode: '7'
    });
    workerReady=true;
  }catch(e){
    workerReady=false; // fallback will be used
  }
}
async function recognizeDigits(cropCanvas){
  const { data } = await worker.recognize(cropCanvas);
  const words = data.words || [];
  // keep digit clusters intact (10/11/12 OK)
  const xs = words
    .map(w => ({ txt:(w.text||'').replace(/\D/g,''), x:(w.bbox.x0+w.bbox.x1)/2 }))
    .filter(w => w.txt.length>0)
    .map(w => ({ x:w.x }));
  // dedupe close centers
  xs.sort((a,b)=>a.x-b.x);
  const out=[]; const minGap=14;
  for(const p of xs){ if(!out.length || Math.abs(p.x - out[out.length-1].x) >= minGap) out.push(p); }
  return out;
}
function withTimeout(promise, ms){
  return new Promise((resolve, reject)=>{
    const t=setTimeout(()=>reject(new Error('timeout')), ms);
    promise.then(v=>{clearTimeout(t); resolve(v);}).catch(e=>{clearTimeout(t); reject(e);});
  });
}

/* ---- Presence detection ---- */
function cropROI(r){
  const c=document.createElement('canvas'); c.width=r.w; c.height=r.h;
  c.getContext('2d').drawImage(current.image, r.x,r.y,r.w,r.h, 0,0,r.w,r.h);
  return c;
}
function slotOccupied(c){
  const k=c.getContext('2d');
  const cx=Math.round(c.width*0.20), cw=Math.round(c.width*0.60);
  const cy=Math.round(c.height*0.15), ch=Math.round(c.height*0.60);
  const {data}=k.getImageData(cx,cy,cw,ch);
  const cols=new Float32Array(cw).fill(0); const dark=130;
  for(let y=0;y<ch;y++){ for(let x=0;x<cw;x++){ const i=(y*cw+x)*4; const L=0.299*data[i]+0.587*data[i+1]+0.114*data[i+2]; if(L<dark) cols[x]++; } }
  for(let x=0;x<cw;x++) cols[x]/=ch;
  let best=0,run=0; for(let x=0;x<cw;x++){ if(cols[x]>0.5){ run++; best=Math.max(best,run);} else run=0; }
  return best>=Math.round(cw*0.25);
}
</script>
</body>
</html>
