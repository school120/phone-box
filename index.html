<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Phone Box Checker – Auto Mode (No Corner Taps)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Simple utility classes so we don't rely on Tailwind @apply */
    .card { background:#fff; border-radius:1rem; box-shadow:0 4px 20px rgba(0,0,0,.08); padding:1rem; }
    .btn { padding:.5rem .75rem; border:1px solid #ddd; border-radius:1rem; }
    .btn-primary { background:#111827; color:#fff; border-color:#111827; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
</head>
<body class="min-h-screen bg-gray-50 text-gray-900">
  <div id="root" class="p-4 sm:p-6"></div>
  <script>
  const { useEffect, useRef, useState } = React;

  // === Fixed grid to match your cabinets (12 rows × 5 cols = 60) ===
  const GRID = { rows: 12, cols: 5 };
  const STORAGE_KEYS = { roster: 'roster' };

  const Storage = {
    save: (k,v)=> localStorage.setItem(k, JSON.stringify(v)),
    load: (k,f)=> { try { const r = localStorage.getItem(k); return r? JSON.parse(r): f; } catch { return f; } }
  };

  // Parse Security Number → {box, slot}
  // Supports: 9B11, 10F7, 12C42, SM112, SM1-12, SM1 12
  function parseSecurityNumber(sn=''){
    const s=String(sn).trim().toUpperCase(); if(!s) return null;
    let m=s.match(/^\s*(SM\d+)\s*[- ]?\s*(\d{1,2})\s*$/); if(m) return {box:m[1], slot: parseInt(m[2],10)};
    m=s.match(/^(.*?)(\d{1,2})$/); if(!m) return null; const box=m[1]; const slot=parseInt(m[2],10);
    if(!(slot>=1 && slot<=60)) return null; return {box, slot};
  }

  function Header(){
    return React.createElement('div',{className:'mb-2'},[
      React.createElement('h1',{className:'text-2xl font-bold'},'Phone Box Checker – Auto Mode (No Corner Taps)'),
      React.createElement('p',{className:'text-xs text-gray-600'},'Just take a photo. We assume a 12×5 grid, detect presence, OCR the label under each slot to read last name + slot number, infer the box from the roster (9–12 A–F, SM1/SM2), and list who is missing.')
    ]);
  }

  function App(){
    const [roster, setRoster] = useState(Storage.load(STORAGE_KEYS.roster, []));
    const [imageURL, setImageURL] = useState(null);
    const [busy, setBusy] = useState(false);
    const [results, setResults] = useState(null);

    const imgRef = useRef(null); const canvasRef = useRef(null);

    // Auto-load roster.csv from repo root if present
    useEffect(()=>{ (async()=>{ try{ const res=await fetch('roster.csv',{cache:'no-store'}); if(res.ok){ const text=await res.text(); const parsed=Papa.parse(text,{header:true,skipEmptyLines:true}); const rows=parsed.data.map(r=>({ personId:String(r['Person ID']||r.personId||'').trim(), fullName:String(r['Full Name']||r.fullName||'').trim(), securityNumber:String(r['Security Number']||r.securityNumber||'').trim(), grade:String(r['Current Grade']||r.grade||'').trim(), email:String(r['Email 1']||r.email||'').trim() })).filter(r=>r.personId && r.fullName); if(rows.length) setRoster(rows); } }catch(e){} })(); },[]);

    const onUploadCSV = (file)=>{
      Papa.parse(file,{header:true,skipEmptyLines:true,complete:(res)=>{ const rows=res.data.map(r=>({ personId:String(r['Person ID']||'').trim(), fullName:String(r['Full Name']||'').trim(), securityNumber:String(r['Security Number']||'').trim(), grade:String(r['Current Grade']||'').trim(), email:String(r['Email 1']||'').trim() })).filter(r=>r.personId && r.fullName); setRoster(rows); Storage.save(STORAGE_KEYS.roster, rows); }});
    };

    const onPhoto = (file)=>{ setImageURL(URL.createObjectURL(file)); setResults(null); };

    const analyze = async ()=>{
      if(!imageURL) { alert('Take/Upload a photo first.'); return; }
      if(!window.cv) { alert('OpenCV not ready yet.'); return; }
      setBusy(true);

      const img = imgRef.current; const canvas = canvasRef.current; const W=img.naturalWidth, H=img.naturalHeight; const ctx=canvas.getContext('2d'); canvas.width=W; canvas.height=H; ctx.drawImage(img,0,0,W,H);

      // Presence detection per cell (assumes mostly straight-on photo)
      const cv=window.cv; const src=cv.imread(canvas); const present=[]; const labels=[]; // OCR of label strip per cell
      const cellW=Math.floor(W/GRID.cols), cellH=Math.floor(H/GRID.rows);

      // Single Tesseract worker for all cells
      const worker = await Tesseract.createWorker('eng');
      try{
        for(let r=0;r<GRID.rows;r++){
          for(let c=0;c<GRID.cols;c++){
            const x=c*cellW, y=r*cellH, cw=cellW, ch=cellH;

            // Phone area = upper ~72% of each cell
            const roi=new cv.Rect(x+Math.floor(cw*0.08), y+Math.floor(ch*0.06), Math.floor(cw*0.84), Math.floor(ch*0.72));
            const cell=src.roi(roi);
            const gray=new cv.Mat(); cv.cvtColor(cell,gray,cv.COLOR_RGBA2GRAY); const blur=new cv.Mat(); cv.GaussianBlur(gray,blur,new cv.Size(3,3),0,0,cv.BORDER_DEFAULT); const edges=new cv.Mat(); cv.Canny(blur,edges,50,150);
            const density = cv.countNonZero(edges)/(roi.width*roi.height); present.push(density>0.02);
            gray.delete(); blur.delete(); edges.delete(); cell.delete();

            // Label strip = bottom ~18% of each cell; OCR to get last name + slot number
            const ly = y + Math.floor(ch*0.80); const lh = Math.floor(ch*0.18);
            const lroi = new cv.Rect(x+2, Math.min(ly,H-1), Math.max(1,cw-4), Math.max(1,lh));
            const lcell = src.roi(lroi);
            const lcanvas=document.createElement('canvas'); lcanvas.width=lroi.width; lcanvas.height=lroi.height; cv.imshow(lcanvas, lcell);
            const { data:{ text } } = await worker.recognize(lcanvas);
            labels.push(text.trim());
            lcell.delete();
          }
        }
      } finally { await worker.terminate(); }

      src.delete();

      // Clean OCR to { lastName, slotHint }
      const cellInfo = labels.map((t)=>{
        const clean=t.replace(/[^A-Za-z0-9\-\s]/g,' ').replace(/\s+/g,' ').trim();
        const numMatch = clean.match(/(\d{1,2})/);
        const words = clean.split(' ').filter(Boolean);
        const last = words.find(w=>/^[A-Za-z][A-Za-z\-']+$/.test(w));
        return { label: clean, lastName: last||'', slotHint: numMatch? parseInt(numMatch[1],10): null };
      });

      // Infer box code by matching OCR lastName+slotHint against roster security numbers
      const votes={};
      for(const info of cellInfo){
        if(!info.lastName || !info.slotHint) continue;
        const candidates = roster.filter(r=> r.fullName.toLowerCase().includes(info.lastName.toLowerCase()));
        for(const cand of candidates){ const p=parseSecurityNumber(cand.securityNumber); if(p && p.slot===info.slotHint){ votes[p.box]=(votes[p.box]||0)+1; } }
      }
      const inferredBox = Object.entries(votes).sort((a,b)=> b[1]-a[1])[0]?.[0] || null;

      // Occupied slot numbers (1..60 scanned L→R, top→bottom)
      const occupiedSlots = new Set(); for(let i=0;i<present.length;i++) if(present[i]) occupiedSlots.add(i+1);

      // Compare against roster students for that box
      const missing=[]; const presentStudents=[];
      if(inferredBox){
        const boxStudents = roster.filter(r=>{ const p=parseSecurityNumber(r.securityNumber); return p && p.box===inferredBox; });
        boxStudents.forEach(stu=>{ const p=parseSecurityNumber(stu.securityNumber); if(!p) return; if(occupiedSlots.has(p.slot)) presentStudents.push(stu); else missing.push(stu); });
      }

      setBusy(false);
      setResults({ inferredBox, presentCount: occupiedSlots.size, missing, presentStudents, cellInfo });
    };

    return React.createElement('div',{className:'max-w-5xl mx-auto space-y-4'},[
      React.createElement(Header,{}),

      React.createElement('div',{className:'card'},[
        React.createElement('h2',{className:'text-lg font-semibold mb-2'},'1) Roster'),
        React.createElement('div',{className:'flex flex-wrap items-center gap-2 text-sm'},[
          React.createElement('label',{className:'btn'},['Upload CSV', React.createElement('input',{type:'file',accept:'.csv',className:'hidden',onChange:e=>{ const f=e.target.files?.[0]; if(f) onUploadCSV(f); }})]),
          React.createElement('a',{href:'roster.csv',className:'btn',download:true},'Download current roster.csv'),
          React.createElement('span',{className:'text-xs text-gray-500'},'We read last names + slot numbers under each slot to infer the box; then we compare to Security Numbers to list who is missing.')
        ])
      ]),

      React.createElement('div',{className:'card'},[
        React.createElement('h2',{className:'text-lg font-semibold mb-2'},'2) Take/Upload Photo'),
        React.createElement('div',{className:'flex flex-wrap items-center gap-2 text-sm mb-2'},[
          React.createElement('label',{className:'btn'},['Take/Upload Photo', React.createElement('input',{type:'file',accept:'image/*',capture:'environment',className:'hidden',onChange:e=>{ const f=e.target.files?.[0]; if(f) onPhoto(f); }}) ]),
          React.createElement('button',{className:'btn btn-primary',onClick:analyze,disabled:busy || !imageURL}, busy? 'Analyzing…' : 'Analyze')
        ]),
        React.createElement('div',{className:'bg-gray-100 rounded-xl p-2'},[
          imageURL ? React.createElement('img',{src:imageURL,ref:imgRef,alt:'box',className:'w-full h-auto rounded'}) : React.createElement('div',{className:'text-sm text-gray-500 p-8'},'Add a photo (no corner taps needed).')
        ]),
        React.createElement('canvas',{ref:canvasRef,className:'hidden'})
      ]),

      results && React.createElement('div',{className:'card space-y-2'},[
        React.createElement('h3',{className:'font-semibold'},`Results ${results.inferredBox? '— Box '+results.inferredBox:''}`),
        React.createElement('div',{},`Detected occupied slots: ${results.presentCount}`),
        (results.missing && results.missing.length>0) ? React.createElement('div',{},[
          React.createElement('div',{className:'text-sm text-gray-700 font-medium'},'Missing phones ('+results.missing.length+')'),
          React.createElement('ul',{className:'list-disc list-inside text-sm'}, results.missing.map(stu=> React.createElement('li',{key:stu.personId}, `${stu.fullName} — ${stu.securityNumber}`)))
        ]) : React.createElement('div',{className:'text-green-700 text-sm'},'No missing phones detected for this roster/box.'),
        !results.inferredBox && React.createElement('div',{className:'text-xs text-amber-700'},'Could not infer a box. Make sure roster.csv is loaded and the slot labels show a last name and slot number.')
      ])
    ]);
  }

  ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(App));
  </script>

  <!-- README (short)
    • Fixed 12×5 grid; no corner taps.
    • Uses OpenCV edge density per cell for presence, and Tesseract OCR on the bottom strip of each cell to read labels (last name + slot number).
    • Infers the box by matching OCR (last name + slot number) to your roster Security Numbers (supports 9–12 A–F, SM1/SM2; formats like 9B11, SM112, SM1-12).
    • Place roster.csv in the repo root or upload it at runtime. Recommend a private repo to protect student data.
  -->
</body>
</html>
